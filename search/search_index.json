{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"solverpy : Python Interface for Automated Solvers solverpy is a Python package providing a uniform interface to launch automated problem solvers from Python and process their outputs. Currently supported solvers are: E Prover E Vampire (solver.atp.vampire.Vampire) Prover9 (solver.atp.prover9.Prover9) Lash (solver.atp.lash.Lash) cvc5 (solver.smt.cvc5.Cvc5) Z3 (solver.smt.z3.Z3) Bitwuzla (solver.smt.bitwuzla.Bitwuzla) \ud83d\uddd2\ufe0f Note : The solver binaries/libraries are not part of this Python package and must be installed separately. The binaries must be (by default) in PATH or specified using bin parameter, if you wish to use them from solverpy . Installation $ pip install solverpy Single problem solving To call the solver on one problem instance, start by creating the solver object. from solverpy.solver.smt.cvc5 import Cvc5 cvc5 = Cvc5 ( \"T5\" ) # time limit of 5 seconds The constructor argument is a resource limit string, in this case, a time limit T in seconds. All solvers support T and additional resource limits might be available depending on the solver. Multiple resource limits can be used (separated by - , like T10-R50000 ). The limit string must, however, always start with T . Then call the solve method: result = cvc5 . solve ( \"myproblem.smt2\" , \"--enum-inst\" ) The first argument is the problem filename, the second is the solver-dependent strategy description (typically command line options as a string). The result is a Python dict with results and statistics. The keys and values are solver-specific. Nevertheless, the result always contains keys status (with the value of type str ) and runtime (type float ). \ud83d\udca1 Hint : Call cvc5.run(p,s) instead of cvc5.solve(p,s) to get the raw solver output without any processing. Call cvc5.command(p,s) to output the shell command that is going to be executed to launch the solver. Parallel benchmark evaluation To evaluate a set of strategies on a set of benchmark problems, you just need to provide your experiment description as a Python dict and launch the experiments. from solverpy.benchmark import setups mysetup = ... setups . launch ( mysetup ) The experiment setup ( mysetup ) must have specific keys. The module solverpy.benchmark.setups contains methods to fill in the required keys and values. You must specify at least the following: key type description cores int number of CPU cores to use for parallel evaluation sidlist [str] list of strategies to evaluate bidlist [str] list of problems to evaluate on limit str the resource limit for a single solver run Strategies and strategy id's Strategies are stored in files in the directory solverpy_db/strats which must exist in the current working directory (the directory is adjustable by the SOLVERPY_DB environment variable). The filename of each strategy is used to reference the strategy in sidlist and it is called the strategy id ( sid ). Hence, for every sid in sidlist in mysetup , there must be the file solverpy_db/strats/sid in the current working directory. This file contains the strategy definition (typically command line options) to pass to the solver.solve method. Problems and benchmark id's Benchmark problem sets are represented by benchark id's ( bid ). The benchmark id is a file path relative to the current working directory (adjustable by the SOLVERPY_BENCHMARKS environment variable) pointing either to a file or to a directory. If the path leads to a: directory : Then every regular file directly in this directory is considered a benchmark problem. Directories and hidden files are ignored and no recursive search is performed. This variant is useful when you have a set of problem files, all in one directory. file : Then the file consists of lines containing paths to corresponding problem files. The paths are relative to the directory of the bid file. For example, if the bid is myproblems/subset1 and this file contains (among others) the line category1/problem23.smt2 then the problem must be placed in myproblems/category1/problem23.smt2 (because the directory of the bid file is myproblems ). This variant is useful when your benchmarks are structured in subdirectories and you don't want to merge them into one directory. Experiments example Suppose you have some SMT problems in the directory myproblems and that you want to evaluate your cvc5 strategies buzzard , sparrow , and chickadee , which you have placed in the directory solverpy_db/strats . You can download the archive with files for this example here . You proceed as follows. First, you create the description of your experiments in mysetup . from solverpy.benchmark import setups mysetup = { \"cores\" : 4 , \"limit\" : \"T10\" , \"bidlist\" : [ \"myproblems\" ], \"sidlist\" : [ \"buzzard\" , \"sparrow\" , \"chickadee\" ], } Hint: Add mysetup[\"options\"] = [\"outputs\"] if you want to keep raw solver output files from all solver runs. Hint: Options are slightly more described here . Then you specify that you want to use cvc5 and that you wish to launch an evaluation. These methods update mysetup and fill in some keys required by setups.launch() . setups . cvc5 ( mysetup ) setups . evaluation ( mysetup ) Finally, you launch the experiments. setups . launch ( mysetup ) You will see the progress of the experiments on the screen. Once finished, you will find the following subdirectories inside solverpy_db : directory content results Results by each strategy ( sid ) for each bid . The result for each sid and bid is a JSON file (gzip-ed) with a Python dictionary {problem: result} . solved List of solved problem names by each strategy for each bid . One per line, easy to grep and cat . status Statuses of all problems by each strategy for each bid . Problem name and status at one line, TAB separated. Easy to cut . log Console log for each solverpy experiment run. outputs Raw solver output files for each solver run (only if selected). Now run the script again and notice that it finished much faster. It is because the cached results were reused and no solvers were actually launched. So be careful and always clean the database if you want to force recompute. Simply delete all the directories in solverpy_db except strats (see the script clean_db.sh in the example archive ).","title":"Home"},{"location":"#solverpy-python-interface-for-automated-solvers","text":"solverpy is a Python package providing a uniform interface to launch automated problem solvers from Python and process their outputs. Currently supported solvers are: E Prover E Vampire (solver.atp.vampire.Vampire) Prover9 (solver.atp.prover9.Prover9) Lash (solver.atp.lash.Lash) cvc5 (solver.smt.cvc5.Cvc5) Z3 (solver.smt.z3.Z3) Bitwuzla (solver.smt.bitwuzla.Bitwuzla) \ud83d\uddd2\ufe0f Note : The solver binaries/libraries are not part of this Python package and must be installed separately. The binaries must be (by default) in PATH or specified using bin parameter, if you wish to use them from solverpy .","title":"solverpy: Python Interface for Automated Solvers"},{"location":"#installation","text":"$ pip install solverpy","title":"Installation"},{"location":"#single-problem-solving","text":"To call the solver on one problem instance, start by creating the solver object. from solverpy.solver.smt.cvc5 import Cvc5 cvc5 = Cvc5 ( \"T5\" ) # time limit of 5 seconds The constructor argument is a resource limit string, in this case, a time limit T in seconds. All solvers support T and additional resource limits might be available depending on the solver. Multiple resource limits can be used (separated by - , like T10-R50000 ). The limit string must, however, always start with T . Then call the solve method: result = cvc5 . solve ( \"myproblem.smt2\" , \"--enum-inst\" ) The first argument is the problem filename, the second is the solver-dependent strategy description (typically command line options as a string). The result is a Python dict with results and statistics. The keys and values are solver-specific. Nevertheless, the result always contains keys status (with the value of type str ) and runtime (type float ). \ud83d\udca1 Hint : Call cvc5.run(p,s) instead of cvc5.solve(p,s) to get the raw solver output without any processing. Call cvc5.command(p,s) to output the shell command that is going to be executed to launch the solver.","title":"Single problem solving"},{"location":"#parallel-benchmark-evaluation","text":"To evaluate a set of strategies on a set of benchmark problems, you just need to provide your experiment description as a Python dict and launch the experiments. from solverpy.benchmark import setups mysetup = ... setups . launch ( mysetup ) The experiment setup ( mysetup ) must have specific keys. The module solverpy.benchmark.setups contains methods to fill in the required keys and values. You must specify at least the following: key type description cores int number of CPU cores to use for parallel evaluation sidlist [str] list of strategies to evaluate bidlist [str] list of problems to evaluate on limit str the resource limit for a single solver run","title":"Parallel benchmark evaluation"},{"location":"#strategies-and-strategy-ids","text":"Strategies are stored in files in the directory solverpy_db/strats which must exist in the current working directory (the directory is adjustable by the SOLVERPY_DB environment variable). The filename of each strategy is used to reference the strategy in sidlist and it is called the strategy id ( sid ). Hence, for every sid in sidlist in mysetup , there must be the file solverpy_db/strats/sid in the current working directory. This file contains the strategy definition (typically command line options) to pass to the solver.solve method.","title":"Strategies and strategy id's"},{"location":"#problems-and-benchmark-ids","text":"Benchmark problem sets are represented by benchark id's ( bid ). The benchmark id is a file path relative to the current working directory (adjustable by the SOLVERPY_BENCHMARKS environment variable) pointing either to a file or to a directory. If the path leads to a: directory : Then every regular file directly in this directory is considered a benchmark problem. Directories and hidden files are ignored and no recursive search is performed. This variant is useful when you have a set of problem files, all in one directory. file : Then the file consists of lines containing paths to corresponding problem files. The paths are relative to the directory of the bid file. For example, if the bid is myproblems/subset1 and this file contains (among others) the line category1/problem23.smt2 then the problem must be placed in myproblems/category1/problem23.smt2 (because the directory of the bid file is myproblems ). This variant is useful when your benchmarks are structured in subdirectories and you don't want to merge them into one directory.","title":"Problems and benchmark id's"},{"location":"#experiments-example","text":"Suppose you have some SMT problems in the directory myproblems and that you want to evaluate your cvc5 strategies buzzard , sparrow , and chickadee , which you have placed in the directory solverpy_db/strats . You can download the archive with files for this example here . You proceed as follows. First, you create the description of your experiments in mysetup . from solverpy.benchmark import setups mysetup = { \"cores\" : 4 , \"limit\" : \"T10\" , \"bidlist\" : [ \"myproblems\" ], \"sidlist\" : [ \"buzzard\" , \"sparrow\" , \"chickadee\" ], } Hint: Add mysetup[\"options\"] = [\"outputs\"] if you want to keep raw solver output files from all solver runs. Hint: Options are slightly more described here . Then you specify that you want to use cvc5 and that you wish to launch an evaluation. These methods update mysetup and fill in some keys required by setups.launch() . setups . cvc5 ( mysetup ) setups . evaluation ( mysetup ) Finally, you launch the experiments. setups . launch ( mysetup ) You will see the progress of the experiments on the screen. Once finished, you will find the following subdirectories inside solverpy_db : directory content results Results by each strategy ( sid ) for each bid . The result for each sid and bid is a JSON file (gzip-ed) with a Python dictionary {problem: result} . solved List of solved problem names by each strategy for each bid . One per line, easy to grep and cat . status Statuses of all problems by each strategy for each bid . Problem name and status at one line, TAB separated. Easy to cut . log Console log for each solverpy experiment run. outputs Raw solver output files for each solver run (only if selected). Now run the script again and notice that it finished much faster. It is because the cached results were reused and no solvers were actually launched. So be careful and always clean the database if you want to force recompute. Simply delete all the directories in solverpy_db except strats (see the script clean_db.sh in the example archive ).","title":"Experiments example"},{"location":"markdown/","text":"\ud83d\udee0\ufe0f Unicode Symbols for Markdown Documentation \u2139\ufe0f Info Symbol Unicode Meaning Usage Example \u2139\ufe0f U+2139 Information \u2139\ufe0f Use with caution in debug mode. \ud83d\udec8 U+1F6C8 Alternative info symbol \ud83d\udec8 API is subject to change. \ud83d\udcd8 U+1F4D8 Reference/Blue book \ud83d\udcd8 See section 4.2 of the guide. \ud83e\uddfe U+1F9FE Documentation/Receipt \ud83e\uddfe Generated logs are saved to /var/log. \ud83e\udde0 U+1F9E0 Insight/Brain \ud83e\udde0 This technique boosts performance. \ud83d\udcdd Note Symbol Unicode Meaning Usage Example \ud83d\udcdd U+1F4DD Memo/Note \ud83d\udcdd This method is deprecated. \ud83d\uddd2\ufe0f U+1F5D2 Notepad \ud83d\uddd2\ufe0f Make sure to configure both fields. \ud83d\udccc U+1F4CC Pinned Note \ud83d\udccc This setting is environment-specific. \ud83d\udcce U+1F4CE Paperclip/Attached \ud83d\udcce Attached are the config templates. \ud83e\uddd0 U+1F9D0 Observational Note \ud83e\uddd0 Rare edge case: input may be null. \ud83d\udca1 Hint / Tip Symbol Unicode Meaning Usage Example \ud83d\udca1 U+1F4A1 Lightbulb \ud83d\udca1 Try caching the results for speed. \ud83d\udd0d U+1F50D Insight/Search \ud83d\udd0d You can filter logs by severity. \ud83e\udde0 U+1F9E0 Brain/Insight \ud83e\udde0 Consider using memoization here. \ud83d\udd27 U+1F527 Tool/Fix tip \ud83d\udd27 Use the --fix flag to auto-correct. \u26a0\ufe0f Warning Symbol Unicode Meaning Usage Example \u26a0\ufe0f U+26A0 Warning \u26a0\ufe0f Do not delete system files. \u2757 U+2757 Important/Alert \u2757 Backup your data before proceeding. \u2755 U+2755 Light Warning \u2755 This may cause a minor delay. \ud83d\udea7 U+1F6A7 Construction/Partial \ud83d\udea7 Feature under development. \u274c Error / Danger Symbol Unicode Meaning Usage Example \u274c U+274C Error \u274c Invalid configuration file. \ud83d\udd25 U+1F525 Hot Issue \ud83d\udd25 Major performance hit detected. \ud83d\uded1 U+1F6D1 Stop/Critical \ud83d\uded1 Service will shut down immediately. \u2705 Success / Done Symbol Unicode Meaning Usage Example \u2705 U+2705 Success/Passed \u2705 All unit tests passed. \u2611\ufe0f U+2611 Checkbox \u2611\ufe0f Enabled via config. \ud83c\udf89 U+1F389 Celebration \ud83c\udf89 Initial setup complete!","title":"Markdown"},{"location":"options/","text":"SolverPy Options An option is identified by its string name, and represents a boolean yes/no value. Put the option name into the string list under the key \"options\" in the setup. Use no- option, like no-compress , to set the option to no option description default outputs Keep raw solver output files from all runs no compress Compress output files (outputs, trains, results). yes flatten Put all output files in a single directory (replace / with _._ ). yes compress-trains Compress trains. yes debug-trains Dump training data for each file separately. no","title":"Options"},{"location":"options/#solverpy-options","text":"An option is identified by its string name, and represents a boolean yes/no value. Put the option name into the string list under the key \"options\" in the setup. Use no- option, like no-compress , to set the option to no option description default outputs Keep raw solver output files from all runs no compress Compress output files (outputs, trains, results). yes flatten Put all output files in a single directory (replace / with _._ ). yes compress-trains Compress trains. yes debug-trains Dump training data for each file separately. no","title":"SolverPy Options"},{"location":"reference/","text":"API Reference Abstract solver module. Tada! Solver Bases: SolverPyObj Class Solver. jada! Source code in src/solverpy/solver/solver.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 class Solver ( SolverPyObj ): \"\"\" Class Solver. jada! \"\"\" def __init__ ( self , ** kwargs : Any ): SolverPyObj . __init__ ( self , ** kwargs ) def __str__ ( self ) -> str : return self . name def solve ( self , instance : Any , strategy : Any ) -> Any : \"\"\" Run the solver with the strategy on the instatance. Process the output and create the result. Args: instance: solver problem instance (filename, or a bid-problem pair, or custom). strategy: solver strategy (filename, sid, or custom). Returns: output and result \"\"\" output = self . run ( instance , strategy ) result = self . process ( output ) return ( output , result ) def valid ( self , result : \"Result\" ) -> bool : \"\"\"Is the result valid?\"\"\" return bool ( result ) and ( \"status\" in result ) and ( \"runtime\" in result ) def solved ( self , result : \"Result\" ) -> bool : \"\"\"Is the result solved?\"\"\" return bool ( result ) and ( \"status\" in result ) and \\ ( result [ \"status\" ] in self . success ) def run ( self , instance : Any , strategy : Any ) -> str : \"\"\"Run the solver with the strategy on the instatance. Return the output.\"\"\" del instance , strategy # unused arguments raise NotImplementedError () def process ( self , output : str ) -> \"Result\" : \"\"\"Process the solver output and create the result.\"\"\" del output # unused argument raise NotImplementedError () @property def name ( self ) -> str : \"\"\"Solver name.\"\"\" return self . __class__ . __name__ @property def success ( self ) -> frozenset [ str ]: \"\"\"The set of successful statuses.\"\"\" raise NotImplementedError () name : str property Solver name. success : frozenset [ str ] property The set of successful statuses. process ( output ) Process the solver output and create the result. Source code in src/solverpy/solver/solver.py 58 59 60 61 def process ( self , output : str ) -> \"Result\" : \"\"\"Process the solver output and create the result.\"\"\" del output # unused argument raise NotImplementedError () run ( instance , strategy ) Run the solver with the strategy on the instatance. Return the output. Source code in src/solverpy/solver/solver.py 53 54 55 56 def run ( self , instance : Any , strategy : Any ) -> str : \"\"\"Run the solver with the strategy on the instatance. Return the output.\"\"\" del instance , strategy # unused arguments raise NotImplementedError () solve ( instance , strategy ) Run the solver with the strategy on the instatance. Process the output and create the result. Parameters: Name Type Description Default instance Any solver problem instance (filename, or a bid-problem pair, or custom). required strategy Any solver strategy (filename, sid, or custom). required Returns: output and result Source code in src/solverpy/solver/solver.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 def solve ( self , instance : Any , strategy : Any ) -> Any : \"\"\" Run the solver with the strategy on the instatance. Process the output and create the result. Args: instance: solver problem instance (filename, or a bid-problem pair, or custom). strategy: solver strategy (filename, sid, or custom). Returns: output and result \"\"\" output = self . run ( instance , strategy ) result = self . process ( output ) return ( output , result ) solved ( result ) Is the result solved? Source code in src/solverpy/solver/solver.py 48 49 50 51 def solved ( self , result : \"Result\" ) -> bool : \"\"\"Is the result solved?\"\"\" return bool ( result ) and ( \"status\" in result ) and \\ ( result [ \"status\" ] in self . success ) valid ( result ) Is the result valid? Source code in src/solverpy/solver/solver.py 44 45 46 def valid ( self , result : \"Result\" ) -> bool : \"\"\"Is the result valid?\"\"\" return bool ( result ) and ( \"status\" in result ) and ( \"runtime\" in result )","title":"Reference"},{"location":"reference/#api-reference","text":"Abstract solver module. Tada!","title":"API Reference"},{"location":"reference/#solverpy.solver.solver.Solver","text":"Bases: SolverPyObj Class Solver. jada! Source code in src/solverpy/solver/solver.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 class Solver ( SolverPyObj ): \"\"\" Class Solver. jada! \"\"\" def __init__ ( self , ** kwargs : Any ): SolverPyObj . __init__ ( self , ** kwargs ) def __str__ ( self ) -> str : return self . name def solve ( self , instance : Any , strategy : Any ) -> Any : \"\"\" Run the solver with the strategy on the instatance. Process the output and create the result. Args: instance: solver problem instance (filename, or a bid-problem pair, or custom). strategy: solver strategy (filename, sid, or custom). Returns: output and result \"\"\" output = self . run ( instance , strategy ) result = self . process ( output ) return ( output , result ) def valid ( self , result : \"Result\" ) -> bool : \"\"\"Is the result valid?\"\"\" return bool ( result ) and ( \"status\" in result ) and ( \"runtime\" in result ) def solved ( self , result : \"Result\" ) -> bool : \"\"\"Is the result solved?\"\"\" return bool ( result ) and ( \"status\" in result ) and \\ ( result [ \"status\" ] in self . success ) def run ( self , instance : Any , strategy : Any ) -> str : \"\"\"Run the solver with the strategy on the instatance. Return the output.\"\"\" del instance , strategy # unused arguments raise NotImplementedError () def process ( self , output : str ) -> \"Result\" : \"\"\"Process the solver output and create the result.\"\"\" del output # unused argument raise NotImplementedError () @property def name ( self ) -> str : \"\"\"Solver name.\"\"\" return self . __class__ . __name__ @property def success ( self ) -> frozenset [ str ]: \"\"\"The set of successful statuses.\"\"\" raise NotImplementedError ()","title":"Solver"},{"location":"reference/#solverpy.solver.solver.Solver.name","text":"Solver name.","title":"name"},{"location":"reference/#solverpy.solver.solver.Solver.success","text":"The set of successful statuses.","title":"success"},{"location":"reference/#solverpy.solver.solver.Solver.process","text":"Process the solver output and create the result. Source code in src/solverpy/solver/solver.py 58 59 60 61 def process ( self , output : str ) -> \"Result\" : \"\"\"Process the solver output and create the result.\"\"\" del output # unused argument raise NotImplementedError ()","title":"process"},{"location":"reference/#solverpy.solver.solver.Solver.run","text":"Run the solver with the strategy on the instatance. Return the output. Source code in src/solverpy/solver/solver.py 53 54 55 56 def run ( self , instance : Any , strategy : Any ) -> str : \"\"\"Run the solver with the strategy on the instatance. Return the output.\"\"\" del instance , strategy # unused arguments raise NotImplementedError ()","title":"run"},{"location":"reference/#solverpy.solver.solver.Solver.solve","text":"Run the solver with the strategy on the instatance. Process the output and create the result. Parameters: Name Type Description Default instance Any solver problem instance (filename, or a bid-problem pair, or custom). required strategy Any solver strategy (filename, sid, or custom). required Returns: output and result Source code in src/solverpy/solver/solver.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 def solve ( self , instance : Any , strategy : Any ) -> Any : \"\"\" Run the solver with the strategy on the instatance. Process the output and create the result. Args: instance: solver problem instance (filename, or a bid-problem pair, or custom). strategy: solver strategy (filename, sid, or custom). Returns: output and result \"\"\" output = self . run ( instance , strategy ) result = self . process ( output ) return ( output , result )","title":"solve"},{"location":"reference/#solverpy.solver.solver.Solver.solved","text":"Is the result solved? Source code in src/solverpy/solver/solver.py 48 49 50 51 def solved ( self , result : \"Result\" ) -> bool : \"\"\"Is the result solved?\"\"\" return bool ( result ) and ( \"status\" in result ) and \\ ( result [ \"status\" ] in self . success )","title":"solved"},{"location":"reference/#solverpy.solver.solver.Solver.valid","text":"Is the result valid? Source code in src/solverpy/solver/solver.py 44 45 46 def valid ( self , result : \"Result\" ) -> bool : \"\"\"Is the result valid?\"\"\" return bool ( result ) and ( \"status\" in result ) and ( \"runtime\" in result )","title":"valid"}]}
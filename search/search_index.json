{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Python Interface for Automated Solvers SolverPy provides a uniform Python interface for several automated ATP and SMT solvers. Currently supported solvers are E , Vampire , Prover9 , Lash , cvc5 , Z3 , and Bitwuzla . The interface can be used for: \ud83d\udca1 Solving a single problem instance with compatible results. \ud83d\udd27 Benchmark parallel evaluation with database storage. \ud83e\udde0 Machine learning of models and strategies for solver guidance. Installation Install the Python package using pip : $ pip install solverpy Or clone our GitHub repository : $ git clone https://github.com/cbboyan/solverpy.git \ud83d\uddd2\ufe0f Note : The solver binaries/libraries are not part of this Python package and must be installed separately. The binaries must be (by default) in PATH or specified using binary parameter in Setup , if you wish to use them from solverpy . Overview \ud83d\udca1 Single problem solving Single problem solving involves creating a solver object and calling its solve method. from solverpy.solver.smt.cvc5 import Cvc5 cvc5 = Cvc5 ( \"T5\" ) # time limit of 5 seconds result = cvc5 . solve ( \"myproblem.smt2\" , \"--enum-inst\" ) # problem and strategy Strategies are solver-specific, typically command line options as a string. \u2615 The result is a dictionary guaranteed to contain at least two keys: status as a string and runtime in seconds, apart from solver-specific keys. \ud83d\ude0e For more info see solver module. \ud83d\udd27 Benchmark evaluation SolverPy provides dataclass Setup that describes the evaluation configuration. It auromatically connects to database DB to store results, by default, using the Jsons provider. To evaluate a set of strategies on a set of benchmark problems, you just need to provide your experiment description as a Python dict . \ud83d\udca1 Use typed version Setup to avoid typos and type errors. Functions from the setups module are used to fill in the required keys and values. To run the evaluation you setup a solver for an evaluation, then launch it. from solverpy import setups mysetup = setups . Setup ( cores = 4 , bidlist = [ 'problems' ], sidlist = [ \"default\" ], limit = 'T10' , ) setups . cvc5 ( mysetup ) setups . evaluation ( mysetup ) mysetup . launch () \ud83e\udd1e Before launching the evaluation, you need to setup the SolverPy database by creating directories solverpy_db/strats in the current directory. This directory stores the strategy files. For the above example, there should be an empty file solverpy_db/strats/default (default cvc5 strategy). The problem files should be in problems/ directory. \u2615 After the evaluation, you can inspect the results in the database directory solverpy_db/results . \ud83d\ude0e For more info see benchmark module. \ud83e\udde0 Machine learning Similarly, you can use the enigma and cvc5ml from setups module. to setup several loops of interleaved evaluation and model training. \ud83d\ude0e For more info see builder module.","title":"Home"},{"location":"#python-interface-for-automated-solvers","text":"SolverPy provides a uniform Python interface for several automated ATP and SMT solvers. Currently supported solvers are E , Vampire , Prover9 , Lash , cvc5 , Z3 , and Bitwuzla . The interface can be used for: \ud83d\udca1 Solving a single problem instance with compatible results. \ud83d\udd27 Benchmark parallel evaluation with database storage. \ud83e\udde0 Machine learning of models and strategies for solver guidance.","title":"Python Interface for Automated Solvers"},{"location":"#installation","text":"Install the Python package using pip : $ pip install solverpy Or clone our GitHub repository : $ git clone https://github.com/cbboyan/solverpy.git \ud83d\uddd2\ufe0f Note : The solver binaries/libraries are not part of this Python package and must be installed separately. The binaries must be (by default) in PATH or specified using binary parameter in Setup , if you wish to use them from solverpy .","title":"Installation"},{"location":"#overview","text":"","title":"Overview"},{"location":"#single-problem-solving","text":"Single problem solving involves creating a solver object and calling its solve method. from solverpy.solver.smt.cvc5 import Cvc5 cvc5 = Cvc5 ( \"T5\" ) # time limit of 5 seconds result = cvc5 . solve ( \"myproblem.smt2\" , \"--enum-inst\" ) # problem and strategy Strategies are solver-specific, typically command line options as a string. \u2615 The result is a dictionary guaranteed to contain at least two keys: status as a string and runtime in seconds, apart from solver-specific keys. \ud83d\ude0e For more info see solver module.","title":"\ud83d\udca1 Single problem solving"},{"location":"#benchmark-evaluation","text":"SolverPy provides dataclass Setup that describes the evaluation configuration. It auromatically connects to database DB to store results, by default, using the Jsons provider. To evaluate a set of strategies on a set of benchmark problems, you just need to provide your experiment description as a Python dict . \ud83d\udca1 Use typed version Setup to avoid typos and type errors. Functions from the setups module are used to fill in the required keys and values. To run the evaluation you setup a solver for an evaluation, then launch it. from solverpy import setups mysetup = setups . Setup ( cores = 4 , bidlist = [ 'problems' ], sidlist = [ \"default\" ], limit = 'T10' , ) setups . cvc5 ( mysetup ) setups . evaluation ( mysetup ) mysetup . launch () \ud83e\udd1e Before launching the evaluation, you need to setup the SolverPy database by creating directories solverpy_db/strats in the current directory. This directory stores the strategy files. For the above example, there should be an empty file solverpy_db/strats/default (default cvc5 strategy). The problem files should be in problems/ directory. \u2615 After the evaluation, you can inspect the results in the database directory solverpy_db/results . \ud83d\ude0e For more info see benchmark module.","title":"\ud83d\udd27 Benchmark evaluation"},{"location":"#machine-learning","text":"Similarly, you can use the enigma and cvc5ml from setups module. to setup several loops of interleaved evaluation and model training. \ud83d\ude0e For more info see builder module.","title":"\ud83e\udde0 Machine learning"},{"location":"markdown/","text":"\ud83d\udee0\ufe0f Unicode Symbols for Markdown Documentation \u2139\ufe0f Info Symbol Unicode Meaning Usage Example \u2139\ufe0f U+2139 Information \u2139\ufe0f Use with caution in debug mode. \ud83d\udec8 U+1F6C8 Alternative info symbol \ud83d\udec8 API is subject to change. \ud83d\udcd8 U+1F4D8 Reference/Blue book \ud83d\udcd8 See section 4.2 of the guide. \ud83e\uddfe U+1F9FE Documentation/Receipt \ud83e\uddfe Generated logs are saved to /var/log. \ud83e\udde0 U+1F9E0 Insight/Brain \ud83e\udde0 This technique boosts performance. \ud83d\udcdd Note Symbol Unicode Meaning Usage Example \ud83d\udcdd U+1F4DD Memo/Note \ud83d\udcdd This method is deprecated. \ud83d\uddd2\ufe0f U+1F5D2 Notepad \ud83d\uddd2\ufe0f Make sure to configure both fields. \ud83d\udccc U+1F4CC Pinned Note \ud83d\udccc This setting is environment-specific. \ud83d\udcce U+1F4CE Paperclip/Attached \ud83d\udcce Attached are the config templates. \ud83e\uddd0 U+1F9D0 Observational Note \ud83e\uddd0 Rare edge case: input may be null. \ud83d\udca1 Hint / Tip Symbol Unicode Meaning Usage Example \ud83d\udca1 U+1F4A1 Lightbulb \ud83d\udca1 Try caching the results for speed. \ud83d\udd0d U+1F50D Insight/Search \ud83d\udd0d You can filter logs by severity. \ud83e\udde0 U+1F9E0 Brain/Insight \ud83e\udde0 Consider using memoization here. \ud83d\udd27 U+1F527 Tool/Fix tip \ud83d\udd27 Use the --fix flag to auto-correct. \u26a0\ufe0f Warning Symbol Unicode Meaning Usage Example \u26a0\ufe0f U+26A0 Warning \u26a0\ufe0f Do not delete system files. \u2757 U+2757 Important/Alert \u2757 Backup your data before proceeding. \u2755 U+2755 Light Warning \u2755 This may cause a minor delay. \ud83d\udea7 U+1F6A7 Construction/Partial \ud83d\udea7 Feature under development. \u274c Error / Danger Symbol Unicode Meaning Usage Example \u274c U+274C Error \u274c Invalid configuration file. \ud83d\udd25 U+1F525 Hot Issue \ud83d\udd25 Major performance hit detected. \ud83d\uded1 U+1F6D1 Stop/Critical \ud83d\uded1 Service will shut down immediately. \u2705 Success / Done Symbol Unicode Meaning Usage Example \u2705 U+2705 Success/Passed \u2705 All unit tests passed. \u2611\ufe0f U+2611 Checkbox \u2611\ufe0f Enabled via config. \ud83c\udf89 U+1F389 Celebration \ud83c\udf89 Initial setup complete!","title":"Markdown"},{"location":"options/","text":"SolverPy Options An option is identified by its string name, and represents a boolean yes/no value. Put the option name into the string list under the key \"options\" in the setup. Use no- option, like no-compress , to set the option to no option description default outputs Keep raw solver output files from all runs no compress Compress output files (outputs, trains, results). yes flatten Put all output files in a single directory (replace / with _._ ). yes compress-trains Compress trains. yes debug-trains Dump training data for each file separately. no","title":"Options"},{"location":"options/#solverpy-options","text":"An option is identified by its string name, and represents a boolean yes/no value. Put the option name into the string list under the key \"options\" in the setup. Use no- option, like no-compress , to set the option to no option description default outputs Keep raw solver output files from all runs no compress Compress output files (outputs, trains, results). yes flatten Put all output files in a single directory (replace / with _._ ). yes compress-trains Compress trains. yes debug-trains Dump training data for each file separately. no","title":"SolverPy Options"},{"location":"test/","text":"PlantUML Test @startuml Alice -> Bob: Hello Bob -> Alice: Hi there @enduml ![file](diagrams/out/overview.svg)","title":"PlantUML Test"},{"location":"test/#plantuml-test","text":"@startuml Alice -> Bob: Hello Bob -> Alice: Hi there @enduml ![file](diagrams/out/overview.svg)","title":"PlantUML Test"},{"location":"tutorial/","text":"Python Interface for Automated Solvers SolverPy provides a uniform Python interface for several automated ATP and SMT solvers. Currently supported solvers are E , Vampire , Prover9 , Lash , cvc5 , Z3 , and Bitwuzla . The interface can be used for: \ud83d\udca1 Solving a single problem instance with compatible results. \ud83d\udd27 Benchmark parallel evaluation with database storage. \ud83e\udde0 Machine learning of models and strategies for solver guidance. Installation Install the Python package using pip : $ pip install solverpy Or clone our GitHub repository : $ git clone https://github.com/cbboyan/solverpy.git \ud83d\uddd2\ufe0f Note : The solver binaries/libraries are not part of this Python package and must be installed separately. The binaries must be (by default) in PATH or specified using binary parameter in Setup , if you wish to use them from solverpy . Overview \ud83d\udca1 Single problem solving Single problem solving involves creating a solver object and calling its solve method. from solverpy.solver.smt.cvc5 import Cvc5 cvc5 = Cvc5 ( \"T5\" ) # time limit of 5 seconds result = cvc5 . solve ( \"myproblem.smt2\" , \"--enum-inst\" ) # problem and strategy Strategies are solver-specific, typically command line options as a string. \u2615 The result is a dictionary guaranteed to contain at least two keys: status as a string and runtime in seconds, apart from solver-specific keys. \ud83d\udd27 Benchmark evaluation SolverPy provides dataclass Setup that describes the evaluation configuration. It auromatically connects to database DB to store results, by default, using the Jsons provider. To evaluate a set of strategies on a set of benchmark problems, you just need to provide your experiment description as a Python dict . \ud83d\udca1 Use typed version Setup to avoid typos and type errors. Functions from the setups module are used to fill in the required keys and values. To run the evaluation you setup a solver for an evaluation, then launch it. from solverpy import setups mysetup = setups . Setup ( cores = 4 , bidlist = [ 'problems' ], sidlist = [ \"default\" ], limit = 'T10' , ) setups . cvc5 ( mysetup ) setups . evaluation ( mysetup ) mysetup . launch () \ud83e\udd1e Before launching the evaluation, you need to setup the SolverPy database by creating directories solverpy_db/strats in the current directory. This directory stores the strategy files. For the above example, there should be an empty file solverpy_db/strats/default (default cvc5 strategy). The problem files should be in problems/ directory. \u2615 After the evaluation, you can inspect the results in the database directory solverpy_db/results . \ud83e\udde0 Machine learning Single problem solving To call the solver on one problem instance, start by creating the solver object. from solverpy.solver.smt.cvc5 import Cvc5 cvc5 = Cvc5 ( \"T5\" ) # time limit of 5 seconds The constructor argument is a resource limit string, in this case, a time limit T in seconds. All solvers support T and additional resource limits might be available depending on the solver. Multiple resource limits can be used (separated by - , like T10-R50000 ). The limit string must, however, always start with T . Then call the solve method: result = cvc5 . solve ( \"myproblem.smt2\" , \"--enum-inst\" ) The first argument is the problem filename, the second is the solver-dependent strategy description (typically command line options as a string). The result is a Python dict with results and statistics. The keys and values are solver-specific. Nevertheless, the result always contains keys status (with the value of type str ) and runtime (type float ). \ud83d\udca1 Call cvc5.run(p,s) instead of cvc5.solve(p,s) to get the raw solver output without any processing. \ud83d\udca1 Call cvc5.command(p,s) to output the shell command that is going to be executed to launch the solver. Parallel benchmark evaluation To evaluate a set of strategies on a set of benchmark problems, you just need to provide your experiment description as a Python dict and launch the experiments. from solverpy.benchmark import setups mysetup = ... setups . launch ( mysetup ) The experiment setup ( mysetup ) must have specific keys. The module solverpy.benchmark.setups contains methods to fill in the required keys and values. You must specify at least the following: key type description cores int number of CPU cores to use for parallel evaluation sidlist [str] list of strategies to evaluate bidlist [str] list of problems to evaluate on limit str the resource limit for a single solver run Strategies and strategy id's Strategies are stored in files in the directory solverpy_db/strats which must exist in the current working directory (the directory is adjustable by the SOLVERPY_DB environment variable). The filename of each strategy is used to reference the strategy in sidlist and it is called the strategy id ( sid ). Hence, for every sid in sidlist in mysetup , there must be the file solverpy_db/strats/sid in the current working directory. This file contains the strategy definition (typically command line options) to pass to the solver.solve method. Problems and benchmark id's Benchmark problem sets are represented by benchark id's ( bid ). The benchmark id is a file path relative to the current working directory (adjustable by the SOLVERPY_BENCHMARKS environment variable) pointing either to a file or to a directory. If the path leads to a: directory : Then every regular file directly in this directory is considered a benchmark problem. Directories and hidden files are ignored and no recursive search is performed. This variant is useful when you have a set of problem files, all in one directory. file : Then the file consists of lines containing paths to corresponding problem files. The paths are relative to the directory of the bid file. For example, if the bid is myproblems/subset1 and this file contains (among others) the line category1/problem23.smt2 then the problem must be placed in myproblems/category1/problem23.smt2 (because the directory of the bid file is myproblems ). This variant is useful when your benchmarks are structured in subdirectories and you don't want to merge them into one directory. Experiments example Suppose you have some SMT problems in the directory myproblems and that you want to evaluate your cvc5 strategies buzzard , sparrow , and chickadee , which you have placed in the directory solverpy_db/strats . You can download the archive with files for this example here . You proceed as follows. First, you create the description of your experiments in mysetup . from solverpy.benchmark import setups mysetup = { \"cores\" : 4 , \"limit\" : \"T10\" , \"bidlist\" : [ \"myproblems\" ], \"sidlist\" : [ \"buzzard\" , \"sparrow\" , \"chickadee\" ], } Hint: Add mysetup[\"options\"] = [\"outputs\"] if you want to keep raw solver output files from all solver runs. Hint: Options are slightly more described here . Then you specify that you want to use cvc5 and that you wish to launch an evaluation. These methods update mysetup and fill in some keys required by setups.launch() . setups . cvc5 ( mysetup ) setups . evaluation ( mysetup ) Finally, you launch the experiments. setups . launch ( mysetup ) You will see the progress of the experiments on the screen. Once finished, you will find the following subdirectories inside solverpy_db : directory content results Results by each strategy ( sid ) for each bid . The result for each sid and bid is a JSON file (gzip-ed) with a Python dictionary {problem: result} . solved List of solved problem names by each strategy for each bid . One per line, easy to grep and cat . status Statuses of all problems by each strategy for each bid . Problem name and status at one line, TAB separated. Easy to cut . log Console log for each solverpy experiment run. outputs Raw solver output files for each solver run (only if selected). Now run the script again and notice that it finished much faster. It is because the cached results were reused and no solvers were actually launched. So be careful and always clean the database if you want to force recompute. Simply delete all the directories in solverpy_db except strats (see the script clean_db.sh in the example archive ).","title":"Tutorial"},{"location":"tutorial/#python-interface-for-automated-solvers","text":"SolverPy provides a uniform Python interface for several automated ATP and SMT solvers. Currently supported solvers are E , Vampire , Prover9 , Lash , cvc5 , Z3 , and Bitwuzla . The interface can be used for: \ud83d\udca1 Solving a single problem instance with compatible results. \ud83d\udd27 Benchmark parallel evaluation with database storage. \ud83e\udde0 Machine learning of models and strategies for solver guidance.","title":"Python Interface for Automated Solvers"},{"location":"tutorial/#installation","text":"Install the Python package using pip : $ pip install solverpy Or clone our GitHub repository : $ git clone https://github.com/cbboyan/solverpy.git \ud83d\uddd2\ufe0f Note : The solver binaries/libraries are not part of this Python package and must be installed separately. The binaries must be (by default) in PATH or specified using binary parameter in Setup , if you wish to use them from solverpy .","title":"Installation"},{"location":"tutorial/#overview","text":"","title":"Overview"},{"location":"tutorial/#single-problem-solving","text":"Single problem solving involves creating a solver object and calling its solve method. from solverpy.solver.smt.cvc5 import Cvc5 cvc5 = Cvc5 ( \"T5\" ) # time limit of 5 seconds result = cvc5 . solve ( \"myproblem.smt2\" , \"--enum-inst\" ) # problem and strategy Strategies are solver-specific, typically command line options as a string. \u2615 The result is a dictionary guaranteed to contain at least two keys: status as a string and runtime in seconds, apart from solver-specific keys.","title":"\ud83d\udca1 Single problem solving"},{"location":"tutorial/#benchmark-evaluation","text":"SolverPy provides dataclass Setup that describes the evaluation configuration. It auromatically connects to database DB to store results, by default, using the Jsons provider. To evaluate a set of strategies on a set of benchmark problems, you just need to provide your experiment description as a Python dict . \ud83d\udca1 Use typed version Setup to avoid typos and type errors. Functions from the setups module are used to fill in the required keys and values. To run the evaluation you setup a solver for an evaluation, then launch it. from solverpy import setups mysetup = setups . Setup ( cores = 4 , bidlist = [ 'problems' ], sidlist = [ \"default\" ], limit = 'T10' , ) setups . cvc5 ( mysetup ) setups . evaluation ( mysetup ) mysetup . launch () \ud83e\udd1e Before launching the evaluation, you need to setup the SolverPy database by creating directories solverpy_db/strats in the current directory. This directory stores the strategy files. For the above example, there should be an empty file solverpy_db/strats/default (default cvc5 strategy). The problem files should be in problems/ directory. \u2615 After the evaluation, you can inspect the results in the database directory solverpy_db/results .","title":"\ud83d\udd27 Benchmark evaluation"},{"location":"tutorial/#machine-learning","text":"","title":"\ud83e\udde0 Machine learning"},{"location":"tutorial/#single-problem-solving_1","text":"To call the solver on one problem instance, start by creating the solver object. from solverpy.solver.smt.cvc5 import Cvc5 cvc5 = Cvc5 ( \"T5\" ) # time limit of 5 seconds The constructor argument is a resource limit string, in this case, a time limit T in seconds. All solvers support T and additional resource limits might be available depending on the solver. Multiple resource limits can be used (separated by - , like T10-R50000 ). The limit string must, however, always start with T . Then call the solve method: result = cvc5 . solve ( \"myproblem.smt2\" , \"--enum-inst\" ) The first argument is the problem filename, the second is the solver-dependent strategy description (typically command line options as a string). The result is a Python dict with results and statistics. The keys and values are solver-specific. Nevertheless, the result always contains keys status (with the value of type str ) and runtime (type float ). \ud83d\udca1 Call cvc5.run(p,s) instead of cvc5.solve(p,s) to get the raw solver output without any processing. \ud83d\udca1 Call cvc5.command(p,s) to output the shell command that is going to be executed to launch the solver.","title":"Single problem solving"},{"location":"tutorial/#parallel-benchmark-evaluation","text":"To evaluate a set of strategies on a set of benchmark problems, you just need to provide your experiment description as a Python dict and launch the experiments. from solverpy.benchmark import setups mysetup = ... setups . launch ( mysetup ) The experiment setup ( mysetup ) must have specific keys. The module solverpy.benchmark.setups contains methods to fill in the required keys and values. You must specify at least the following: key type description cores int number of CPU cores to use for parallel evaluation sidlist [str] list of strategies to evaluate bidlist [str] list of problems to evaluate on limit str the resource limit for a single solver run","title":"Parallel benchmark evaluation"},{"location":"tutorial/#strategies-and-strategy-ids","text":"Strategies are stored in files in the directory solverpy_db/strats which must exist in the current working directory (the directory is adjustable by the SOLVERPY_DB environment variable). The filename of each strategy is used to reference the strategy in sidlist and it is called the strategy id ( sid ). Hence, for every sid in sidlist in mysetup , there must be the file solverpy_db/strats/sid in the current working directory. This file contains the strategy definition (typically command line options) to pass to the solver.solve method.","title":"Strategies and strategy id's"},{"location":"tutorial/#problems-and-benchmark-ids","text":"Benchmark problem sets are represented by benchark id's ( bid ). The benchmark id is a file path relative to the current working directory (adjustable by the SOLVERPY_BENCHMARKS environment variable) pointing either to a file or to a directory. If the path leads to a: directory : Then every regular file directly in this directory is considered a benchmark problem. Directories and hidden files are ignored and no recursive search is performed. This variant is useful when you have a set of problem files, all in one directory. file : Then the file consists of lines containing paths to corresponding problem files. The paths are relative to the directory of the bid file. For example, if the bid is myproblems/subset1 and this file contains (among others) the line category1/problem23.smt2 then the problem must be placed in myproblems/category1/problem23.smt2 (because the directory of the bid file is myproblems ). This variant is useful when your benchmarks are structured in subdirectories and you don't want to merge them into one directory.","title":"Problems and benchmark id's"},{"location":"tutorial/#experiments-example","text":"Suppose you have some SMT problems in the directory myproblems and that you want to evaluate your cvc5 strategies buzzard , sparrow , and chickadee , which you have placed in the directory solverpy_db/strats . You can download the archive with files for this example here . You proceed as follows. First, you create the description of your experiments in mysetup . from solverpy.benchmark import setups mysetup = { \"cores\" : 4 , \"limit\" : \"T10\" , \"bidlist\" : [ \"myproblems\" ], \"sidlist\" : [ \"buzzard\" , \"sparrow\" , \"chickadee\" ], } Hint: Add mysetup[\"options\"] = [\"outputs\"] if you want to keep raw solver output files from all solver runs. Hint: Options are slightly more described here . Then you specify that you want to use cvc5 and that you wish to launch an evaluation. These methods update mysetup and fill in some keys required by setups.launch() . setups . cvc5 ( mysetup ) setups . evaluation ( mysetup ) Finally, you launch the experiments. setups . launch ( mysetup ) You will see the progress of the experiments on the screen. Once finished, you will find the following subdirectories inside solverpy_db : directory content results Results by each strategy ( sid ) for each bid . The result for each sid and bid is a JSON file (gzip-ed) with a Python dictionary {problem: result} . solved List of solved problem names by each strategy for each bid . One per line, easy to grep and cat . status Statuses of all problems by each strategy for each bid . Problem name and status at one line, TAB separated. Easy to cut . log Console log for each solverpy experiment run. outputs Raw solver output files for each solver run (only if selected). Now run the script again and notice that it finished much faster. It is because the cached results were reused and no solvers were actually launched. So be careful and always clean the database if you want to force recompute. Simply delete all the directories in solverpy_db except strats (see the script clean_db.sh in the example archive ).","title":"Experiments example"},{"location":"api/solverpy/","text":"Solverpy Overview SolverPy Overview Setup Bases: TypedDict Experiment setup configuration. Attributes: Name Type Description limit str Resource limit for solvers. a longer desc? Ok what happens if I put here some really long text? Ok what happens if I put here some really long text? Ok what happens if I put here some really long text? Ok what happens if I put here some really long text? Ok what happens if I put here some really long text? Ok what happens if I put here some really long text? With stuff: code ( 2 + 3 ) call ( code ) cores int Number of cores to be used. ref bool | int | str | None bidfile str sidfile str bidlist list [ str ] sidlist list [ str ] binary str static list [ str ] ntfy str it int loops int news list [ str ] refs list [ str ] options list [ str ] delfix int | str | None force bool shuffle bool dataname str start_dataname str basedataname str db DB builder Builder solver SolverPy trains SvmTrains previous_trains str | tuple [ str ] plugins list [ Plugin ] max_proofs int proofs dict [ str , int ] | None e_training_examples str gen_features str sel_features str posneg_ratio float templates list [ str ] Source code in src/solverpy/setups/setup.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 class Setup ( TypedDict , total = False ): \"\"\" Experiment setup configuration. Attributes: limit: Resource limit for solvers. a longer desc? Ok what happens if I put here some really long text? Ok what happens if I put here some really long text? Ok what happens if I put here some really long text? Ok what happens if I put here some really long text? Ok what happens if I put here some really long text? Ok what happens if I put here some really long text? With stuff: ```python code(2+3) call(code) ``` cores: Number of cores to be used. ref: bidfile: sidfile: bidlist: sidlist: binary: static: ntfy: it: loops: news: refs: options: delfix: force: shuffle: dataname: start_dataname: basedataname: db: builder: solver: trains: previous_trains: plugins: max_proofs: proofs: e_training_examples: gen_features: sel_features: posneg_ratio: templates: \"\"\" limit : str cores : int ref : ( bool | int | str | None ) bidfile : str sidfile : str bidlist : list [ str ] sidlist : list [ str ] binary : str static : list [ str ] ntfy : str it : int loops : int news : list [ str ] refs : list [ str ] options : list [ str ] delfix : ( int | str | None ) force : bool shuffle : bool dataname : str start_dataname : str basedataname : str db : \"DB\" builder : \"Builder\" solver : \"SolverPy\" trains : \"SvmTrains\" previous_trains : str | tuple [ str ] plugins : list [ \"Plugin\" ] max_proofs : int proofs : ( dict [ str , int ] | None ) e_training_examples : str gen_features : str sel_features : str posneg_ratio : float templates : list [ str ]","title":"\u2139\ufe0f Overview"},{"location":"api/solverpy/#solverpy-overview","text":"","title":"Solverpy Overview"},{"location":"api/solverpy/#solverpy--solverpy-overview","text":"","title":"SolverPy Overview"},{"location":"api/solverpy/#solverpy.Setup","text":"Bases: TypedDict Experiment setup configuration. Attributes: Name Type Description limit str Resource limit for solvers. a longer desc? Ok what happens if I put here some really long text? Ok what happens if I put here some really long text? Ok what happens if I put here some really long text? Ok what happens if I put here some really long text? Ok what happens if I put here some really long text? Ok what happens if I put here some really long text? With stuff: code ( 2 + 3 ) call ( code ) cores int Number of cores to be used. ref bool | int | str | None bidfile str sidfile str bidlist list [ str ] sidlist list [ str ] binary str static list [ str ] ntfy str it int loops int news list [ str ] refs list [ str ] options list [ str ] delfix int | str | None force bool shuffle bool dataname str start_dataname str basedataname str db DB builder Builder solver SolverPy trains SvmTrains previous_trains str | tuple [ str ] plugins list [ Plugin ] max_proofs int proofs dict [ str , int ] | None e_training_examples str gen_features str sel_features str posneg_ratio float templates list [ str ] Source code in src/solverpy/setups/setup.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 class Setup ( TypedDict , total = False ): \"\"\" Experiment setup configuration. Attributes: limit: Resource limit for solvers. a longer desc? Ok what happens if I put here some really long text? Ok what happens if I put here some really long text? Ok what happens if I put here some really long text? Ok what happens if I put here some really long text? Ok what happens if I put here some really long text? Ok what happens if I put here some really long text? With stuff: ```python code(2+3) call(code) ``` cores: Number of cores to be used. ref: bidfile: sidfile: bidlist: sidlist: binary: static: ntfy: it: loops: news: refs: options: delfix: force: shuffle: dataname: start_dataname: basedataname: db: builder: solver: trains: previous_trains: plugins: max_proofs: proofs: e_training_examples: gen_features: sel_features: posneg_ratio: templates: \"\"\" limit : str cores : int ref : ( bool | int | str | None ) bidfile : str sidfile : str bidlist : list [ str ] sidlist : list [ str ] binary : str static : list [ str ] ntfy : str it : int loops : int news : list [ str ] refs : list [ str ] options : list [ str ] delfix : ( int | str | None ) force : bool shuffle : bool dataname : str start_dataname : str basedataname : str db : \"DB\" builder : \"Builder\" solver : \"SolverPy\" trains : \"SvmTrains\" previous_trains : str | tuple [ str ] plugins : list [ \"Plugin\" ] max_proofs : int proofs : ( dict [ str , int ] | None ) e_training_examples : str gen_features : str sel_features : str posneg_ratio : float templates : list [ str ]","title":"Setup"},{"location":"api/solverpy/benchmark/","text":"Benchmark Overview","title":"\u2139\ufe0f Overview"},{"location":"api/solverpy/benchmark/#benchmark-overview","text":"","title":"Benchmark Overview"},{"location":"api/solverpy/benchmark/evaluation/","text":"module evaluation","title":"\ud83e\udd16 evaluation"},{"location":"api/solverpy/benchmark/evaluation/#module-evaluation","text":"","title":"module evaluation"},{"location":"api/solverpy/benchmark/summary/","text":"module summary","title":"\ud83e\udd16 summary"},{"location":"api/solverpy/benchmark/summary/#module-summary","text":"","title":"module summary"},{"location":"api/solverpy/benchmark/db/","text":"Db Overview","title":"\u2139\ufe0f Overview"},{"location":"api/solverpy/benchmark/db/#db-overview","text":"","title":"Db Overview"},{"location":"api/solverpy/benchmark/db/cachedprovider/","text":"module cachedprovider","title":"\ud83e\udd16 cachedprovider"},{"location":"api/solverpy/benchmark/db/cachedprovider/#module-cachedprovider","text":"","title":"module cachedprovider"},{"location":"api/solverpy/benchmark/db/db/","text":"module db","title":"\ud83e\udd16 db"},{"location":"api/solverpy/benchmark/db/db/#module-db","text":"","title":"module db"},{"location":"api/solverpy/benchmark/db/provider/","text":"module provider Provider Bases: SolverPyObj A data provider that stores and/or queries results of tasks. Source code in src/solverpy/benchmark/db/provider.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 class Provider ( SolverPyObj ): \"\"\"A data provider that stores and/or queries results of tasks.\"\"\" def __init__ ( self , bid : str , sid : str , limit : ( str | None ) = None , caching : bool = False , ): self . bid = bid self . sid = sid self . limit = limit self . caching = caching self . _uptodate = False \"call store for cached results.\" @classmethod def Maker ( cls , ** kwargs ) -> \"ProviderMaker\" : class MakerMaker ( SolverPyObj ): def __init__ ( self ): SolverPyObj . __init__ ( self , cls_name = cls . __name__ , ** kwargs , ) def __call__ ( self , bid : str , sid : str , limit : ( str | None ) = None , ): return cls ( bid , sid , limit , ** kwargs ) return MakerMaker () def query ( self , task : \"SolverTask\" , ) -> ( dict [ str , Any ] | None ): \"\"\"Return the cached result for `task` or None if not available.\"\"\" del task # unused argument return None def store ( self , task : \"SolverTask\" , result : dict [ str , Any ], ): \"\"\"New result for `task` was found. Update the cache.\"\"\" del task , result # unused arguments pass def cached ( self , task : \"SolverTask\" , result : dict [ str , Any ], ): \"\"\"Announcement that the cached `result` for `task` was found.\"\"\" if self . caching : self . store ( task , result ) def commit ( self ) -> None : \"\"\"Save/flush the data.\"\"\" pass def check ( self , task : \"SolverTask\" ) -> None : if ( self . bid != task . bid ) or ( self . sid != task . sid ): raise Exception ( \"Error: Operation on invalid bid/sid in a provider.\" ) cached ( task , result ) Announcement that the cached result for task was found. Source code in src/solverpy/benchmark/db/provider.py 64 65 66 67 68 69 70 71 def cached ( self , task : \"SolverTask\" , result : dict [ str , Any ], ): \"\"\"Announcement that the cached `result` for `task` was found.\"\"\" if self . caching : self . store ( task , result ) commit () Save/flush the data. Source code in src/solverpy/benchmark/db/provider.py 73 74 75 def commit ( self ) -> None : \"\"\"Save/flush the data.\"\"\" pass query ( task ) Return the cached result for task or None if not available. Source code in src/solverpy/benchmark/db/provider.py 47 48 49 50 51 52 53 def query ( self , task : \"SolverTask\" , ) -> ( dict [ str , Any ] | None ): \"\"\"Return the cached result for `task` or None if not available.\"\"\" del task # unused argument return None store ( task , result ) New result for task was found. Update the cache. Source code in src/solverpy/benchmark/db/provider.py 55 56 57 58 59 60 61 62 def store ( self , task : \"SolverTask\" , result : dict [ str , Any ], ): \"\"\"New result for `task` was found. Update the cache.\"\"\" del task , result # unused arguments pass","title":"\ud83e\udd16 provider"},{"location":"api/solverpy/benchmark/db/provider/#module-provider","text":"","title":"module provider"},{"location":"api/solverpy/benchmark/db/provider/#solverpy.benchmark.db.provider.Provider","text":"Bases: SolverPyObj A data provider that stores and/or queries results of tasks. Source code in src/solverpy/benchmark/db/provider.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 class Provider ( SolverPyObj ): \"\"\"A data provider that stores and/or queries results of tasks.\"\"\" def __init__ ( self , bid : str , sid : str , limit : ( str | None ) = None , caching : bool = False , ): self . bid = bid self . sid = sid self . limit = limit self . caching = caching self . _uptodate = False \"call store for cached results.\" @classmethod def Maker ( cls , ** kwargs ) -> \"ProviderMaker\" : class MakerMaker ( SolverPyObj ): def __init__ ( self ): SolverPyObj . __init__ ( self , cls_name = cls . __name__ , ** kwargs , ) def __call__ ( self , bid : str , sid : str , limit : ( str | None ) = None , ): return cls ( bid , sid , limit , ** kwargs ) return MakerMaker () def query ( self , task : \"SolverTask\" , ) -> ( dict [ str , Any ] | None ): \"\"\"Return the cached result for `task` or None if not available.\"\"\" del task # unused argument return None def store ( self , task : \"SolverTask\" , result : dict [ str , Any ], ): \"\"\"New result for `task` was found. Update the cache.\"\"\" del task , result # unused arguments pass def cached ( self , task : \"SolverTask\" , result : dict [ str , Any ], ): \"\"\"Announcement that the cached `result` for `task` was found.\"\"\" if self . caching : self . store ( task , result ) def commit ( self ) -> None : \"\"\"Save/flush the data.\"\"\" pass def check ( self , task : \"SolverTask\" ) -> None : if ( self . bid != task . bid ) or ( self . sid != task . sid ): raise Exception ( \"Error: Operation on invalid bid/sid in a provider.\" )","title":"Provider"},{"location":"api/solverpy/benchmark/db/provider/#solverpy.benchmark.db.provider.Provider.cached","text":"Announcement that the cached result for task was found. Source code in src/solverpy/benchmark/db/provider.py 64 65 66 67 68 69 70 71 def cached ( self , task : \"SolverTask\" , result : dict [ str , Any ], ): \"\"\"Announcement that the cached `result` for `task` was found.\"\"\" if self . caching : self . store ( task , result )","title":"cached"},{"location":"api/solverpy/benchmark/db/provider/#solverpy.benchmark.db.provider.Provider.commit","text":"Save/flush the data. Source code in src/solverpy/benchmark/db/provider.py 73 74 75 def commit ( self ) -> None : \"\"\"Save/flush the data.\"\"\" pass","title":"commit"},{"location":"api/solverpy/benchmark/db/provider/#solverpy.benchmark.db.provider.Provider.query","text":"Return the cached result for task or None if not available. Source code in src/solverpy/benchmark/db/provider.py 47 48 49 50 51 52 53 def query ( self , task : \"SolverTask\" , ) -> ( dict [ str , Any ] | None ): \"\"\"Return the cached result for `task` or None if not available.\"\"\" del task # unused argument return None","title":"query"},{"location":"api/solverpy/benchmark/db/provider/#solverpy.benchmark.db.provider.Provider.store","text":"New result for task was found. Update the cache. Source code in src/solverpy/benchmark/db/provider.py 55 56 57 58 59 60 61 62 def store ( self , task : \"SolverTask\" , result : dict [ str , Any ], ): \"\"\"New result for `task` was found. Update the cache.\"\"\" del task , result # unused arguments pass","title":"store"},{"location":"api/solverpy/benchmark/db/providers/","text":"Providers Overview","title":"\u2139\ufe0f Overview"},{"location":"api/solverpy/benchmark/db/providers/#providers-overview","text":"","title":"Providers Overview"},{"location":"api/solverpy/benchmark/db/providers/jsons/","text":"module jsons","title":"\ud83e\udd16 jsons"},{"location":"api/solverpy/benchmark/db/providers/jsons/#module-jsons","text":"","title":"module jsons"},{"location":"api/solverpy/benchmark/db/providers/loader/","text":"module loader","title":"\ud83e\udd16 loader"},{"location":"api/solverpy/benchmark/db/providers/loader/#module-loader","text":"","title":"module loader"},{"location":"api/solverpy/benchmark/db/providers/solved/","text":"module solved delfix ( problem , fix ) Delete a prefix of a problem name. Source code in src/solverpy/benchmark/db/providers/solved.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 def delfix ( problem : str , fix : ( str | int | None ), ) -> str : \"\"\"Delete a prefix of a problem name.\"\"\" if not fix : # covers None, 0, \"\" (also False) return problem if ( type ( fix ) is str ) and problem . startswith ( fix ): return problem [ len ( fix ):] if ( type ( fix ) is int ) and problem . count ( \"/\" ) >= fix : parts = problem . split ( \"/\" ) return \"/\" . join ( parts [ fix :]) logger . warning ( f \"Uknown delfix value type { type ( fix ) } of ' { fix } '\" ) return problem","title":"\ud83e\udd16 solved"},{"location":"api/solverpy/benchmark/db/providers/solved/#module-solved","text":"","title":"module solved"},{"location":"api/solverpy/benchmark/db/providers/solved/#solverpy.benchmark.db.providers.solved.delfix","text":"Delete a prefix of a problem name. Source code in src/solverpy/benchmark/db/providers/solved.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 def delfix ( problem : str , fix : ( str | int | None ), ) -> str : \"\"\"Delete a prefix of a problem name.\"\"\" if not fix : # covers None, 0, \"\" (also False) return problem if ( type ( fix ) is str ) and problem . startswith ( fix ): return problem [ len ( fix ):] if ( type ( fix ) is int ) and problem . count ( \"/\" ) >= fix : parts = problem . split ( \"/\" ) return \"/\" . join ( parts [ fix :]) logger . warning ( f \"Uknown delfix value type { type ( fix ) } of ' { fix } '\" ) return problem","title":"delfix"},{"location":"api/solverpy/benchmark/db/providers/status/","text":"module status","title":"\ud83e\udd16 status"},{"location":"api/solverpy/benchmark/db/providers/status/#module-status","text":"","title":"module status"},{"location":"api/solverpy/benchmark/path/","text":"Path Overview","title":"\u2139\ufe0f Overview"},{"location":"api/solverpy/benchmark/path/#path-overview","text":"","title":"Path Overview"},{"location":"api/solverpy/benchmark/path/bids/","text":"module bids","title":"\ud83e\udd16 bids"},{"location":"api/solverpy/benchmark/path/bids/#module-bids","text":"","title":"module bids"},{"location":"api/solverpy/benchmark/path/sids/","text":"module sids","title":"\ud83e\udd16 sids"},{"location":"api/solverpy/benchmark/path/sids/#module-sids","text":"","title":"module sids"},{"location":"api/solverpy/benchmark/reports/","text":"Reports Overview","title":"\u2139\ufe0f Overview"},{"location":"api/solverpy/benchmark/reports/#reports-overview","text":"","title":"Reports Overview"},{"location":"api/solverpy/benchmark/reports/data/","text":"module data","title":"\ud83e\udd16 data"},{"location":"api/solverpy/benchmark/reports/data/#module-data","text":"","title":"module data"},{"location":"api/solverpy/benchmark/reports/markdown/","text":"module markdown","title":"\ud83e\udd16 markdown"},{"location":"api/solverpy/benchmark/reports/markdown/#module-markdown","text":"","title":"module markdown"},{"location":"api/solverpy/benchmark/reports/progress/","text":"module progress","title":"\ud83e\udd16 progress"},{"location":"api/solverpy/benchmark/reports/progress/#module-progress","text":"","title":"module progress"},{"location":"api/solverpy/builder/","text":"Builder Overview","title":"\u2139\ufe0f Overview"},{"location":"api/solverpy/builder/#builder-overview","text":"","title":"Builder Overview"},{"location":"api/solverpy/builder/autotuner/","text":"module autotuner","title":"\ud83e\udd16 autotuner"},{"location":"api/solverpy/builder/autotuner/#module-autotuner","text":"","title":"module autotuner"},{"location":"api/solverpy/builder/builder/","text":"module builder Builder Bases: SolverPyObj Build the model from the training samples. Source code in src/solverpy/builder/builder.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 class Builder ( SolverPyObj ): \"\"\"Build the model from the training samples.\"\"\" def __init__ ( self , dataname : str ): \"\"\"Construct the builder and store the dataname.\"\"\" SolverPyObj . __init__ ( self , dataname = dataname ) self . _strats = [] self . _dataname = dataname def path ( self ) -> str : \"\"\"Return the model filename.\"\"\" return os . path . join ( bids . dbpath ( NAME ), self . _dataname ) def reset ( self , dataname : str ) -> None : \"\"\"Reset the dataname, for example, when a new loop is initiated.\"\"\" self . _dataname = dataname def build ( self ) -> None : \"\"\"Build the model(s). Save the list of new strategies `self._strats`.\"\"\" raise NotImplementedError () def apply ( self , sid : str , model : str ) -> list [ str ]: \"\"\"Combine the `model` with strategy `sid`.\"\"\" del sid , model raise NotImplementedError () @property def strategies ( self ): \"\"\"Return all created strategies.\"\"\" return self . _strats def applies ( self , sidlist : list [ str ], model : str ) -> list [ str ]: \"\"\"Combine the `model` with several strategies `sidlist`.\"\"\" new = [] for ref in sidlist : new . extend ( self . apply ( ref , model )) return new strategies property Return all created strategies. __init__ ( dataname ) Construct the builder and store the dataname. Source code in src/solverpy/builder/builder.py 15 16 17 18 19 def __init__ ( self , dataname : str ): \"\"\"Construct the builder and store the dataname.\"\"\" SolverPyObj . __init__ ( self , dataname = dataname ) self . _strats = [] self . _dataname = dataname applies ( sidlist , model ) Combine the model with several strategies sidlist . Source code in src/solverpy/builder/builder.py 43 44 45 46 47 48 def applies ( self , sidlist : list [ str ], model : str ) -> list [ str ]: \"\"\"Combine the `model` with several strategies `sidlist`.\"\"\" new = [] for ref in sidlist : new . extend ( self . apply ( ref , model )) return new apply ( sid , model ) Combine the model with strategy sid . Source code in src/solverpy/builder/builder.py 33 34 35 36 def apply ( self , sid : str , model : str ) -> list [ str ]: \"\"\"Combine the `model` with strategy `sid`.\"\"\" del sid , model raise NotImplementedError () build () Build the model(s). Save the list of new strategies self._strats . Source code in src/solverpy/builder/builder.py 29 30 31 def build ( self ) -> None : \"\"\"Build the model(s). Save the list of new strategies `self._strats`.\"\"\" raise NotImplementedError () path () Return the model filename. Source code in src/solverpy/builder/builder.py 21 22 23 def path ( self ) -> str : \"\"\"Return the model filename.\"\"\" return os . path . join ( bids . dbpath ( NAME ), self . _dataname ) reset ( dataname ) Reset the dataname, for example, when a new loop is initiated. Source code in src/solverpy/builder/builder.py 25 26 27 def reset ( self , dataname : str ) -> None : \"\"\"Reset the dataname, for example, when a new loop is initiated.\"\"\" self . _dataname = dataname","title":"\ud83e\udd16 builder"},{"location":"api/solverpy/builder/builder/#module-builder","text":"","title":"module builder"},{"location":"api/solverpy/builder/builder/#solverpy.builder.builder.Builder","text":"Bases: SolverPyObj Build the model from the training samples. Source code in src/solverpy/builder/builder.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 class Builder ( SolverPyObj ): \"\"\"Build the model from the training samples.\"\"\" def __init__ ( self , dataname : str ): \"\"\"Construct the builder and store the dataname.\"\"\" SolverPyObj . __init__ ( self , dataname = dataname ) self . _strats = [] self . _dataname = dataname def path ( self ) -> str : \"\"\"Return the model filename.\"\"\" return os . path . join ( bids . dbpath ( NAME ), self . _dataname ) def reset ( self , dataname : str ) -> None : \"\"\"Reset the dataname, for example, when a new loop is initiated.\"\"\" self . _dataname = dataname def build ( self ) -> None : \"\"\"Build the model(s). Save the list of new strategies `self._strats`.\"\"\" raise NotImplementedError () def apply ( self , sid : str , model : str ) -> list [ str ]: \"\"\"Combine the `model` with strategy `sid`.\"\"\" del sid , model raise NotImplementedError () @property def strategies ( self ): \"\"\"Return all created strategies.\"\"\" return self . _strats def applies ( self , sidlist : list [ str ], model : str ) -> list [ str ]: \"\"\"Combine the `model` with several strategies `sidlist`.\"\"\" new = [] for ref in sidlist : new . extend ( self . apply ( ref , model )) return new","title":"Builder"},{"location":"api/solverpy/builder/builder/#solverpy.builder.builder.Builder.strategies","text":"Return all created strategies.","title":"strategies"},{"location":"api/solverpy/builder/builder/#solverpy.builder.builder.Builder.__init__","text":"Construct the builder and store the dataname. Source code in src/solverpy/builder/builder.py 15 16 17 18 19 def __init__ ( self , dataname : str ): \"\"\"Construct the builder and store the dataname.\"\"\" SolverPyObj . __init__ ( self , dataname = dataname ) self . _strats = [] self . _dataname = dataname","title":"__init__"},{"location":"api/solverpy/builder/builder/#solverpy.builder.builder.Builder.applies","text":"Combine the model with several strategies sidlist . Source code in src/solverpy/builder/builder.py 43 44 45 46 47 48 def applies ( self , sidlist : list [ str ], model : str ) -> list [ str ]: \"\"\"Combine the `model` with several strategies `sidlist`.\"\"\" new = [] for ref in sidlist : new . extend ( self . apply ( ref , model )) return new","title":"applies"},{"location":"api/solverpy/builder/builder/#solverpy.builder.builder.Builder.apply","text":"Combine the model with strategy sid . Source code in src/solverpy/builder/builder.py 33 34 35 36 def apply ( self , sid : str , model : str ) -> list [ str ]: \"\"\"Combine the `model` with strategy `sid`.\"\"\" del sid , model raise NotImplementedError ()","title":"apply"},{"location":"api/solverpy/builder/builder/#solverpy.builder.builder.Builder.build","text":"Build the model(s). Save the list of new strategies self._strats . Source code in src/solverpy/builder/builder.py 29 30 31 def build ( self ) -> None : \"\"\"Build the model(s). Save the list of new strategies `self._strats`.\"\"\" raise NotImplementedError ()","title":"build"},{"location":"api/solverpy/builder/builder/#solverpy.builder.builder.Builder.path","text":"Return the model filename. Source code in src/solverpy/builder/builder.py 21 22 23 def path ( self ) -> str : \"\"\"Return the model filename.\"\"\" return os . path . join ( bids . dbpath ( NAME ), self . _dataname )","title":"path"},{"location":"api/solverpy/builder/builder/#solverpy.builder.builder.Builder.reset","text":"Reset the dataname, for example, when a new loop is initiated. Source code in src/solverpy/builder/builder.py 25 26 27 def reset ( self , dataname : str ) -> None : \"\"\"Reset the dataname, for example, when a new loop is initiated.\"\"\" self . _dataname = dataname","title":"reset"},{"location":"api/solverpy/builder/cvc5ml/","text":"module cvc5ml Cvc5ML Bases: AutoTuner Source code in src/solverpy/builder/cvc5ml.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 class Cvc5ML ( AutoTuner ): def __init__ ( self , trains : Setup , devels : ( Setup | None ) = None , tuneargs : ( dict [ str , Any ] | None ) = None , ): AutoTuner . __init__ ( self , trains , devels , tuneargs , ) def template ( self , sid : str ) -> str : \"`sid` must be base strategy without parameters\" if sid . endswith ( \"-ml\" ): logger . debug ( f \"strategy { sid } already ml-enhanced\" ) return sid sidml = f \" { sid } -ml\" if os . path . exists ( sids . path ( sidml )): logger . debug ( f \"ml strategy { sidml } already exists\" ) return sidml dbpath = bids . dbpath ( NAME ) mod = f \" { dbpath } /@@@model:default@@@/model.lgb\" strat = sids . load ( sid ) . rstrip () strat = self . mlstrat ( strat , mod ) sids . save ( sidml , strat ) logger . debug ( f \"created parametric ml strategy { sidml } inherited from { sid } : \\n { strat } \" ) return sidml def mlstrat ( self , strat : str , model : str ) -> str : adds = \" \\n \" . join ([ f \"--ml-engine\" , f \"--ml-model= { model } \" , f \"--ml-usage=@@@usage:1.0@@@\" , f \"--ml-fallback=@@@fallback:0@@@\" , f \"--ml-selector=@@@sel:orig@@@\" , f \"--ml-selector-value=@@@val:0.5@@@\" , ]) return f \" { strat } \\n { adds } \" def apply ( self , sid : str , model : str ) -> list [ str ]: ( base , args ) = sids . split ( sid ) tpl = self . template ( base ) sidml = sids . fmt ( tpl , dict ( args , model = model )) logger . debug ( f \"new strategy: { sidml } \" ) return [ sidml ] template ( sid ) sid must be base strategy without parameters Source code in src/solverpy/builder/cvc5ml.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 def template ( self , sid : str ) -> str : \"`sid` must be base strategy without parameters\" if sid . endswith ( \"-ml\" ): logger . debug ( f \"strategy { sid } already ml-enhanced\" ) return sid sidml = f \" { sid } -ml\" if os . path . exists ( sids . path ( sidml )): logger . debug ( f \"ml strategy { sidml } already exists\" ) return sidml dbpath = bids . dbpath ( NAME ) mod = f \" { dbpath } /@@@model:default@@@/model.lgb\" strat = sids . load ( sid ) . rstrip () strat = self . mlstrat ( strat , mod ) sids . save ( sidml , strat ) logger . debug ( f \"created parametric ml strategy { sidml } inherited from { sid } : \\n { strat } \" ) return sidml","title":"\ud83e\udd16 cvc5ml"},{"location":"api/solverpy/builder/cvc5ml/#module-cvc5ml","text":"","title":"module cvc5ml"},{"location":"api/solverpy/builder/cvc5ml/#solverpy.builder.cvc5ml.Cvc5ML","text":"Bases: AutoTuner Source code in src/solverpy/builder/cvc5ml.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 class Cvc5ML ( AutoTuner ): def __init__ ( self , trains : Setup , devels : ( Setup | None ) = None , tuneargs : ( dict [ str , Any ] | None ) = None , ): AutoTuner . __init__ ( self , trains , devels , tuneargs , ) def template ( self , sid : str ) -> str : \"`sid` must be base strategy without parameters\" if sid . endswith ( \"-ml\" ): logger . debug ( f \"strategy { sid } already ml-enhanced\" ) return sid sidml = f \" { sid } -ml\" if os . path . exists ( sids . path ( sidml )): logger . debug ( f \"ml strategy { sidml } already exists\" ) return sidml dbpath = bids . dbpath ( NAME ) mod = f \" { dbpath } /@@@model:default@@@/model.lgb\" strat = sids . load ( sid ) . rstrip () strat = self . mlstrat ( strat , mod ) sids . save ( sidml , strat ) logger . debug ( f \"created parametric ml strategy { sidml } inherited from { sid } : \\n { strat } \" ) return sidml def mlstrat ( self , strat : str , model : str ) -> str : adds = \" \\n \" . join ([ f \"--ml-engine\" , f \"--ml-model= { model } \" , f \"--ml-usage=@@@usage:1.0@@@\" , f \"--ml-fallback=@@@fallback:0@@@\" , f \"--ml-selector=@@@sel:orig@@@\" , f \"--ml-selector-value=@@@val:0.5@@@\" , ]) return f \" { strat } \\n { adds } \" def apply ( self , sid : str , model : str ) -> list [ str ]: ( base , args ) = sids . split ( sid ) tpl = self . template ( base ) sidml = sids . fmt ( tpl , dict ( args , model = model )) logger . debug ( f \"new strategy: { sidml } \" ) return [ sidml ]","title":"Cvc5ML"},{"location":"api/solverpy/builder/cvc5ml/#solverpy.builder.cvc5ml.Cvc5ML.template","text":"sid must be base strategy without parameters Source code in src/solverpy/builder/cvc5ml.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 def template ( self , sid : str ) -> str : \"`sid` must be base strategy without parameters\" if sid . endswith ( \"-ml\" ): logger . debug ( f \"strategy { sid } already ml-enhanced\" ) return sid sidml = f \" { sid } -ml\" if os . path . exists ( sids . path ( sidml )): logger . debug ( f \"ml strategy { sidml } already exists\" ) return sidml dbpath = bids . dbpath ( NAME ) mod = f \" { dbpath } /@@@model:default@@@/model.lgb\" strat = sids . load ( sid ) . rstrip () strat = self . mlstrat ( strat , mod ) sids . save ( sidml , strat ) logger . debug ( f \"created parametric ml strategy { sidml } inherited from { sid } : \\n { strat } \" ) return sidml","title":"template"},{"location":"api/solverpy/builder/enigma/","text":"module enigma","title":"\ud83e\udd16 enigma"},{"location":"api/solverpy/builder/enigma/#module-enigma","text":"","title":"module enigma"},{"location":"api/solverpy/builder/svm/","text":"module svm deconflict ( xs , ys ) Find conflicting positive and negative samples and remove the negative ones. Source code in src/solverpy/builder/svm.py 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 def deconflict ( xs : \"spmatrix\" , ys : \"ndarray\" ) -> tuple [ \"spmatrix\" , \"ndarray\" ]: \"Find conflicting positive and negative samples and remove the negative ones.\" assert xs . shape [ 0 ] == ys . shape [ 0 ] logger . info ( \"Looking up conflicting samples.\" ) logger . debug ( \"building samples map\" ) dups = defaultdict ( list ) for i in range ( xs . shape [ 0 ]): row = xs . getrow ( i ) key = ( tuple ( row . indices ), tuple ( row . data )) dups [ key ] . append ( i ) logger . debug ( \"marking conflicting negative samples\" ) todel = set () for ids in dups . values (): if len ( ids ) < 2 : continue td = [] onepos = False for i in ids : if ys [ i ] == 0 : td . append ( i ) # mark negative indicies to be removed else : onepos = True # there is at least one positive if onepos : todel . update ( td ) logger . debug ( \"deleting marked rows\" ) keep = [ i for i in range ( xs . shape [ 0 ]) if i not in todel ] xs0 = xs [ keep ] # type: ignore ys0 = ys [ keep ] logger . info ( \" \\n \" . join ([ \"Data shape difference:\" , f \" \\t { xs . shape } --> { xs0 . shape } \" , f \" \\t { ys . shape } --> { ys0 . shape } \" , ])) return ( xs0 , ys0 )","title":"\ud83e\udd16 svm"},{"location":"api/solverpy/builder/svm/#module-svm","text":"","title":"module svm"},{"location":"api/solverpy/builder/svm/#solverpy.builder.svm.deconflict","text":"Find conflicting positive and negative samples and remove the negative ones. Source code in src/solverpy/builder/svm.py 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 def deconflict ( xs : \"spmatrix\" , ys : \"ndarray\" ) -> tuple [ \"spmatrix\" , \"ndarray\" ]: \"Find conflicting positive and negative samples and remove the negative ones.\" assert xs . shape [ 0 ] == ys . shape [ 0 ] logger . info ( \"Looking up conflicting samples.\" ) logger . debug ( \"building samples map\" ) dups = defaultdict ( list ) for i in range ( xs . shape [ 0 ]): row = xs . getrow ( i ) key = ( tuple ( row . indices ), tuple ( row . data )) dups [ key ] . append ( i ) logger . debug ( \"marking conflicting negative samples\" ) todel = set () for ids in dups . values (): if len ( ids ) < 2 : continue td = [] onepos = False for i in ids : if ys [ i ] == 0 : td . append ( i ) # mark negative indicies to be removed else : onepos = True # there is at least one positive if onepos : todel . update ( td ) logger . debug ( \"deleting marked rows\" ) keep = [ i for i in range ( xs . shape [ 0 ]) if i not in todel ] xs0 = xs [ keep ] # type: ignore ys0 = ys [ keep ] logger . info ( \" \\n \" . join ([ \"Data shape difference:\" , f \" \\t { xs . shape } --> { xs0 . shape } \" , f \" \\t { ys . shape } --> { ys0 . shape } \" , ])) return ( xs0 , ys0 )","title":"deconflict"},{"location":"api/solverpy/builder/autotune/","text":"Autotune Overview","title":"\u2139\ufe0f Overview"},{"location":"api/solverpy/builder/autotune/#autotune-overview","text":"","title":"Autotune Overview"},{"location":"api/solverpy/builder/autotune/autotune/","text":"module autotune","title":"\ud83e\udd16 autotune"},{"location":"api/solverpy/builder/autotune/autotune/#module-autotune","text":"","title":"module autotune"},{"location":"api/solverpy/builder/autotune/build/","text":"module build","title":"\ud83e\udd16 build"},{"location":"api/solverpy/builder/autotune/build/#module-build","text":"","title":"module build"},{"location":"api/solverpy/builder/autotune/check/","text":"module check","title":"\ud83e\udd16 check"},{"location":"api/solverpy/builder/autotune/check/#module-check","text":"","title":"module check"},{"location":"api/solverpy/builder/autotune/listener/","text":"module listener","title":"\ud83e\udd16 listener"},{"location":"api/solverpy/builder/autotune/listener/#module-listener","text":"","title":"module listener"},{"location":"api/solverpy/builder/autotune/tune/","text":"module tune","title":"\ud83e\udd16 tune"},{"location":"api/solverpy/builder/autotune/tune/#module-tune","text":"","title":"module tune"},{"location":"api/solverpy/builder/plugins/","text":"Plugins Overview","title":"\u2139\ufe0f Overview"},{"location":"api/solverpy/builder/plugins/#plugins-overview","text":"","title":"Plugins Overview"},{"location":"api/solverpy/builder/plugins/cvc5/","text":"module cvc5","title":"\ud83e\udd16 cvc5"},{"location":"api/solverpy/builder/plugins/cvc5/#module-cvc5","text":"","title":"module cvc5"},{"location":"api/solverpy/builder/plugins/enigma/","text":"module enigma","title":"\ud83e\udd16 enigma"},{"location":"api/solverpy/builder/plugins/enigma/#module-enigma","text":"","title":"module enigma"},{"location":"api/solverpy/builder/plugins/multi/","text":"module multi","title":"\ud83e\udd16 multi"},{"location":"api/solverpy/builder/plugins/multi/#module-multi","text":"","title":"module multi"},{"location":"api/solverpy/builder/plugins/svm/","text":"module svm","title":"\ud83e\udd16 svm"},{"location":"api/solverpy/builder/plugins/svm/#module-svm","text":"","title":"module svm"},{"location":"api/solverpy/builder/plugins/trains/","text":"module trains Trains Bases: Decorator Source code in src/solverpy/builder/plugins/trains.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 class Trains ( Decorator ): def __init__ ( self , dataname : str , filename : str = \"train.in\" ): Decorator . __init__ ( self , pid = \"trains\" , dataname = dataname , filename = filename , ) self . _lock = multiprocessing . Manager () . Lock () self . _enabled = True self . reset ( dataname , filename ) def enable ( self ): self . _enabled = True def disable ( self ): self . _enabled = False def reset ( self , dataname : ( str | None ) = None , filename : str = \"train.in\" , ) -> None : if dataname : self . _dataname = dataname self . _filename = filename def path ( self , dataname : ( str | None ) = None , filename : ( str | None ) = None , ) -> Any : dataname = dataname or self . _dataname filename = filename or self . _filename return os . path . join ( bids . dbpath ( NAME ), dataname , filename ) def exists ( self ) -> bool : return os . path . isfile ( self . path ()) def link ( self , src : str ): if not os . path . isfile ( src ): logger . warning ( f \"Link source not found: { src } .\" ) return rellink ( src , self . path ()) def register ( self , solver : \"SolverPy\" ) -> None : super () . register ( solver ) self . _solver = solver def finished ( self , instance : tuple [ str , str ], strategy : str , output : str , result : dict [ str , Any ], ): if not ( output and self . _solver . solved ( result )): return samples = self . extract ( instance , strategy , output , result ) self . save ( instance , strategy , samples ) def extract ( self , instance : tuple [ str , str ], strategy : str , output : str , result : dict [ str , Any ], ) -> Any : del instance , strategy , output , result # unused arguments \"Extract training samples from `output`.\" raise NotImplementedError () def save ( self , instance : tuple [ str , str ], strategy : str , samples : str , ) -> None : if ( not samples ) or ( not self . _enabled ): return self . _lock . acquire () try : os . makedirs ( os . path . dirname ( self . path ()), exist_ok = True ) with open ( self . path (), \"a\" ) as fa : fa . write ( samples ) self . stats ( instance , strategy , samples ) finally : self . _lock . release () def stats ( self , instance : tuple [ str , str ], strategy : str , samples : str , ): \"Save optional statistics.\" del instance , strategy , samples # unused arguments pass stats ( instance , strategy , samples ) Save optional statistics. Source code in src/solverpy/builder/plugins/trains.py 116 117 118 119 120 121 122 123 124 def stats ( self , instance : tuple [ str , str ], strategy : str , samples : str , ): \"Save optional statistics.\" del instance , strategy , samples # unused arguments pass","title":"\ud83e\udd16 trains"},{"location":"api/solverpy/builder/plugins/trains/#module-trains","text":"","title":"module trains"},{"location":"api/solverpy/builder/plugins/trains/#solverpy.builder.plugins.trains.Trains","text":"Bases: Decorator Source code in src/solverpy/builder/plugins/trains.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 class Trains ( Decorator ): def __init__ ( self , dataname : str , filename : str = \"train.in\" ): Decorator . __init__ ( self , pid = \"trains\" , dataname = dataname , filename = filename , ) self . _lock = multiprocessing . Manager () . Lock () self . _enabled = True self . reset ( dataname , filename ) def enable ( self ): self . _enabled = True def disable ( self ): self . _enabled = False def reset ( self , dataname : ( str | None ) = None , filename : str = \"train.in\" , ) -> None : if dataname : self . _dataname = dataname self . _filename = filename def path ( self , dataname : ( str | None ) = None , filename : ( str | None ) = None , ) -> Any : dataname = dataname or self . _dataname filename = filename or self . _filename return os . path . join ( bids . dbpath ( NAME ), dataname , filename ) def exists ( self ) -> bool : return os . path . isfile ( self . path ()) def link ( self , src : str ): if not os . path . isfile ( src ): logger . warning ( f \"Link source not found: { src } .\" ) return rellink ( src , self . path ()) def register ( self , solver : \"SolverPy\" ) -> None : super () . register ( solver ) self . _solver = solver def finished ( self , instance : tuple [ str , str ], strategy : str , output : str , result : dict [ str , Any ], ): if not ( output and self . _solver . solved ( result )): return samples = self . extract ( instance , strategy , output , result ) self . save ( instance , strategy , samples ) def extract ( self , instance : tuple [ str , str ], strategy : str , output : str , result : dict [ str , Any ], ) -> Any : del instance , strategy , output , result # unused arguments \"Extract training samples from `output`.\" raise NotImplementedError () def save ( self , instance : tuple [ str , str ], strategy : str , samples : str , ) -> None : if ( not samples ) or ( not self . _enabled ): return self . _lock . acquire () try : os . makedirs ( os . path . dirname ( self . path ()), exist_ok = True ) with open ( self . path (), \"a\" ) as fa : fa . write ( samples ) self . stats ( instance , strategy , samples ) finally : self . _lock . release () def stats ( self , instance : tuple [ str , str ], strategy : str , samples : str , ): \"Save optional statistics.\" del instance , strategy , samples # unused arguments pass","title":"Trains"},{"location":"api/solverpy/builder/plugins/trains/#solverpy.builder.plugins.trains.Trains.stats","text":"Save optional statistics. Source code in src/solverpy/builder/plugins/trains.py 116 117 118 119 120 121 122 123 124 def stats ( self , instance : tuple [ str , str ], strategy : str , samples : str , ): \"Save optional statistics.\" del instance , strategy , samples # unused arguments pass","title":"stats"},{"location":"api/solverpy/setups/","text":"Setups Overview Setup Bases: TypedDict Experiment setup configuration. Attributes: Name Type Description limit str Resource limit for solvers. a longer desc? Ok what happens if I put here some really long text? Ok what happens if I put here some really long text? Ok what happens if I put here some really long text? Ok what happens if I put here some really long text? Ok what happens if I put here some really long text? Ok what happens if I put here some really long text? With stuff: code ( 2 + 3 ) call ( code ) cores int Number of cores to be used. ref bool | int | str | None bidfile str sidfile str bidlist list [ str ] sidlist list [ str ] binary str static list [ str ] ntfy str it int loops int news list [ str ] refs list [ str ] options list [ str ] delfix int | str | None force bool shuffle bool dataname str start_dataname str basedataname str db DB builder Builder solver SolverPy trains SvmTrains previous_trains str | tuple [ str ] plugins list [ Plugin ] max_proofs int proofs dict [ str , int ] | None e_training_examples str gen_features str sel_features str posneg_ratio float templates list [ str ] Source code in src/solverpy/setups/setup.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 class Setup ( TypedDict , total = False ): \"\"\" Experiment setup configuration. Attributes: limit: Resource limit for solvers. a longer desc? Ok what happens if I put here some really long text? Ok what happens if I put here some really long text? Ok what happens if I put here some really long text? Ok what happens if I put here some really long text? Ok what happens if I put here some really long text? Ok what happens if I put here some really long text? With stuff: ```python code(2+3) call(code) ``` cores: Number of cores to be used. ref: bidfile: sidfile: bidlist: sidlist: binary: static: ntfy: it: loops: news: refs: options: delfix: force: shuffle: dataname: start_dataname: basedataname: db: builder: solver: trains: previous_trains: plugins: max_proofs: proofs: e_training_examples: gen_features: sel_features: posneg_ratio: templates: \"\"\" limit : str cores : int ref : ( bool | int | str | None ) bidfile : str sidfile : str bidlist : list [ str ] sidlist : list [ str ] binary : str static : list [ str ] ntfy : str it : int loops : int news : list [ str ] refs : list [ str ] options : list [ str ] delfix : ( int | str | None ) force : bool shuffle : bool dataname : str start_dataname : str basedataname : str db : \"DB\" builder : \"Builder\" solver : \"SolverPy\" trains : \"SvmTrains\" previous_trains : str | tuple [ str ] plugins : list [ \"Plugin\" ] max_proofs : int proofs : ( dict [ str , int ] | None ) e_training_examples : str gen_features : str sel_features : str posneg_ratio : float templates : list [ str ]","title":"\u2139\ufe0f Overview"},{"location":"api/solverpy/setups/#setups-overview","text":"","title":"Setups Overview"},{"location":"api/solverpy/setups/#solverpy.setups.Setup","text":"Bases: TypedDict Experiment setup configuration. Attributes: Name Type Description limit str Resource limit for solvers. a longer desc? Ok what happens if I put here some really long text? Ok what happens if I put here some really long text? Ok what happens if I put here some really long text? Ok what happens if I put here some really long text? Ok what happens if I put here some really long text? Ok what happens if I put here some really long text? With stuff: code ( 2 + 3 ) call ( code ) cores int Number of cores to be used. ref bool | int | str | None bidfile str sidfile str bidlist list [ str ] sidlist list [ str ] binary str static list [ str ] ntfy str it int loops int news list [ str ] refs list [ str ] options list [ str ] delfix int | str | None force bool shuffle bool dataname str start_dataname str basedataname str db DB builder Builder solver SolverPy trains SvmTrains previous_trains str | tuple [ str ] plugins list [ Plugin ] max_proofs int proofs dict [ str , int ] | None e_training_examples str gen_features str sel_features str posneg_ratio float templates list [ str ] Source code in src/solverpy/setups/setup.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 class Setup ( TypedDict , total = False ): \"\"\" Experiment setup configuration. Attributes: limit: Resource limit for solvers. a longer desc? Ok what happens if I put here some really long text? Ok what happens if I put here some really long text? Ok what happens if I put here some really long text? Ok what happens if I put here some really long text? Ok what happens if I put here some really long text? Ok what happens if I put here some really long text? With stuff: ```python code(2+3) call(code) ``` cores: Number of cores to be used. ref: bidfile: sidfile: bidlist: sidlist: binary: static: ntfy: it: loops: news: refs: options: delfix: force: shuffle: dataname: start_dataname: basedataname: db: builder: solver: trains: previous_trains: plugins: max_proofs: proofs: e_training_examples: gen_features: sel_features: posneg_ratio: templates: \"\"\" limit : str cores : int ref : ( bool | int | str | None ) bidfile : str sidfile : str bidlist : list [ str ] sidlist : list [ str ] binary : str static : list [ str ] ntfy : str it : int loops : int news : list [ str ] refs : list [ str ] options : list [ str ] delfix : ( int | str | None ) force : bool shuffle : bool dataname : str start_dataname : str basedataname : str db : \"DB\" builder : \"Builder\" solver : \"SolverPy\" trains : \"SvmTrains\" previous_trains : str | tuple [ str ] plugins : list [ \"Plugin\" ] max_proofs : int proofs : ( dict [ str , int ] | None ) e_training_examples : str gen_features : str sel_features : str posneg_ratio : float templates : list [ str ]","title":"Setup"},{"location":"api/solverpy/setups/common/","text":"module common","title":"\ud83e\udd16 common"},{"location":"api/solverpy/setups/common/#module-common","text":"","title":"module common"},{"location":"api/solverpy/setups/loop/","text":"module loop","title":"\ud83e\udd16 loop"},{"location":"api/solverpy/setups/loop/#module-loop","text":"","title":"module loop"},{"location":"api/solverpy/setups/setup/","text":"module setup Setup Bases: TypedDict Experiment setup configuration. Attributes: Name Type Description limit str Resource limit for solvers. a longer desc? Ok what happens if I put here some really long text? Ok what happens if I put here some really long text? Ok what happens if I put here some really long text? Ok what happens if I put here some really long text? Ok what happens if I put here some really long text? Ok what happens if I put here some really long text? With stuff: code ( 2 + 3 ) call ( code ) cores int Number of cores to be used. ref bool | int | str | None bidfile str sidfile str bidlist list [ str ] sidlist list [ str ] binary str static list [ str ] ntfy str it int loops int news list [ str ] refs list [ str ] options list [ str ] delfix int | str | None force bool shuffle bool dataname str start_dataname str basedataname str db DB builder Builder solver SolverPy trains SvmTrains previous_trains str | tuple [ str ] plugins list [ Plugin ] max_proofs int proofs dict [ str , int ] | None e_training_examples str gen_features str sel_features str posneg_ratio float templates list [ str ] Source code in src/solverpy/setups/setup.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 class Setup ( TypedDict , total = False ): \"\"\" Experiment setup configuration. Attributes: limit: Resource limit for solvers. a longer desc? Ok what happens if I put here some really long text? Ok what happens if I put here some really long text? Ok what happens if I put here some really long text? Ok what happens if I put here some really long text? Ok what happens if I put here some really long text? Ok what happens if I put here some really long text? With stuff: ```python code(2+3) call(code) ``` cores: Number of cores to be used. ref: bidfile: sidfile: bidlist: sidlist: binary: static: ntfy: it: loops: news: refs: options: delfix: force: shuffle: dataname: start_dataname: basedataname: db: builder: solver: trains: previous_trains: plugins: max_proofs: proofs: e_training_examples: gen_features: sel_features: posneg_ratio: templates: \"\"\" limit : str cores : int ref : ( bool | int | str | None ) bidfile : str sidfile : str bidlist : list [ str ] sidlist : list [ str ] binary : str static : list [ str ] ntfy : str it : int loops : int news : list [ str ] refs : list [ str ] options : list [ str ] delfix : ( int | str | None ) force : bool shuffle : bool dataname : str start_dataname : str basedataname : str db : \"DB\" builder : \"Builder\" solver : \"SolverPy\" trains : \"SvmTrains\" previous_trains : str | tuple [ str ] plugins : list [ \"Plugin\" ] max_proofs : int proofs : ( dict [ str , int ] | None ) e_training_examples : str gen_features : str sel_features : str posneg_ratio : float templates : list [ str ]","title":"\ud83e\udd16 setup"},{"location":"api/solverpy/setups/setup/#module-setup","text":"","title":"module setup"},{"location":"api/solverpy/setups/setup/#solverpy.setups.setup.Setup","text":"Bases: TypedDict Experiment setup configuration. Attributes: Name Type Description limit str Resource limit for solvers. a longer desc? Ok what happens if I put here some really long text? Ok what happens if I put here some really long text? Ok what happens if I put here some really long text? Ok what happens if I put here some really long text? Ok what happens if I put here some really long text? Ok what happens if I put here some really long text? With stuff: code ( 2 + 3 ) call ( code ) cores int Number of cores to be used. ref bool | int | str | None bidfile str sidfile str bidlist list [ str ] sidlist list [ str ] binary str static list [ str ] ntfy str it int loops int news list [ str ] refs list [ str ] options list [ str ] delfix int | str | None force bool shuffle bool dataname str start_dataname str basedataname str db DB builder Builder solver SolverPy trains SvmTrains previous_trains str | tuple [ str ] plugins list [ Plugin ] max_proofs int proofs dict [ str , int ] | None e_training_examples str gen_features str sel_features str posneg_ratio float templates list [ str ] Source code in src/solverpy/setups/setup.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 class Setup ( TypedDict , total = False ): \"\"\" Experiment setup configuration. Attributes: limit: Resource limit for solvers. a longer desc? Ok what happens if I put here some really long text? Ok what happens if I put here some really long text? Ok what happens if I put here some really long text? Ok what happens if I put here some really long text? Ok what happens if I put here some really long text? Ok what happens if I put here some really long text? With stuff: ```python code(2+3) call(code) ``` cores: Number of cores to be used. ref: bidfile: sidfile: bidlist: sidlist: binary: static: ntfy: it: loops: news: refs: options: delfix: force: shuffle: dataname: start_dataname: basedataname: db: builder: solver: trains: previous_trains: plugins: max_proofs: proofs: e_training_examples: gen_features: sel_features: posneg_ratio: templates: \"\"\" limit : str cores : int ref : ( bool | int | str | None ) bidfile : str sidfile : str bidlist : list [ str ] sidlist : list [ str ] binary : str static : list [ str ] ntfy : str it : int loops : int news : list [ str ] refs : list [ str ] options : list [ str ] delfix : ( int | str | None ) force : bool shuffle : bool dataname : str start_dataname : str basedataname : str db : \"DB\" builder : \"Builder\" solver : \"SolverPy\" trains : \"SvmTrains\" previous_trains : str | tuple [ str ] plugins : list [ \"Plugin\" ] max_proofs : int proofs : ( dict [ str , int ] | None ) e_training_examples : str gen_features : str sel_features : str posneg_ratio : float templates : list [ str ]","title":"Setup"},{"location":"api/solverpy/setups/solver/","text":"module solver","title":"\ud83e\udd16 solver"},{"location":"api/solverpy/setups/solver/#module-solver","text":"","title":"module solver"},{"location":"api/solverpy/setups/tuner/","text":"module tuner","title":"\ud83e\udd16 tuner"},{"location":"api/solverpy/setups/tuner/#module-tuner","text":"","title":"module tuner"},{"location":"api/solverpy/solver/","text":"Solver Overview","title":"\u2139\ufe0f Overview"},{"location":"api/solverpy/solver/#solver-overview","text":"","title":"Solver Overview"},{"location":"api/solverpy/solver/object/","text":"module object SolverPyObj Source code in src/solverpy/solver/object.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class SolverPyObj : def __init__ ( self , cls_name : ( str | None ) = None , ** kwargs : Any , ): self . _repr_args : dict [ str , Any ] = dict ( kwargs ) self . _cls_name = cls_name or self . __class__ . __name__ def __repr__ ( self ) -> str : if hasattr ( self , \"_repr_args\" ) and self . _repr_args is not None : ias = [ f \" { x } = { y } \" for ( x , y ) in self . _repr_args . items ()] ias = \",\" . join ( sorted ( ias )) return f \" { self . _cls_name } ( { ias } )\" return object . __repr__ ( self ) def represent ( self ) -> ( str | list [ Any ] | dict [ str , Any ]): \"\"\"Default yaml represeneter\"\"\" return repr ( self ) represent () Default yaml represeneter Source code in src/solverpy/solver/object.py 24 25 26 def represent ( self ) -> ( str | list [ Any ] | dict [ str , Any ]): \"\"\"Default yaml represeneter\"\"\" return repr ( self )","title":"\ud83e\udd16 object"},{"location":"api/solverpy/solver/object/#module-object","text":"","title":"module object"},{"location":"api/solverpy/solver/object/#solverpy.solver.object.SolverPyObj","text":"Source code in src/solverpy/solver/object.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class SolverPyObj : def __init__ ( self , cls_name : ( str | None ) = None , ** kwargs : Any , ): self . _repr_args : dict [ str , Any ] = dict ( kwargs ) self . _cls_name = cls_name or self . __class__ . __name__ def __repr__ ( self ) -> str : if hasattr ( self , \"_repr_args\" ) and self . _repr_args is not None : ias = [ f \" { x } = { y } \" for ( x , y ) in self . _repr_args . items ()] ias = \",\" . join ( sorted ( ias )) return f \" { self . _cls_name } ( { ias } )\" return object . __repr__ ( self ) def represent ( self ) -> ( str | list [ Any ] | dict [ str , Any ]): \"\"\"Default yaml represeneter\"\"\" return repr ( self )","title":"SolverPyObj"},{"location":"api/solverpy/solver/object/#solverpy.solver.object.SolverPyObj.represent","text":"Default yaml represeneter Source code in src/solverpy/solver/object.py 24 25 26 def represent ( self ) -> ( str | list [ Any ] | dict [ str , Any ]): \"\"\"Default yaml represeneter\"\"\" return repr ( self )","title":"represent"},{"location":"api/solverpy/solver/pluginsolver/","text":"module pluginsolver PluginSolver Bases: Solver Source code in src/solverpy/solver/pluginsolver.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 class PluginSolver ( Solver ): def __init__ ( self , plugins : list [ \"Plugin\" ] = [], ** kwargs : Any ): Solver . __init__ ( self , ** kwargs ) self . decorators : list [ \"Decorator\" ] = [] self . translators : list [ \"Translator\" ] = [] self . init ( plugins ) def represent ( self ): return dict ( cls = self . name , decorators = [ repr ( x ) for x in self . decorators ], translators = [ repr ( x ) for x in self . translators ], ) def solve ( self , instance : Any , strategy : Any ) -> \"Result\" : \"\"\" Run the solver with the strategy on the instatance. Update the solver result and announce the final version. Return the updated result. \"\"\" result = Solver . solve ( self , instance , strategy ) output = self . _output self . update ( instance , strategy , output , result ) if not self . valid ( result ): lines = output . split ( \" \\n \" ) if len ( lines ) > 3 : msg = f \" { lines [ 2 ] } \\n { lines [ 3 ] } \" # command and first output line else : msg = output logger . debug ( f \"failed solver run: { self } : { strategy } @ { instance } \\n result: { result } \\n { msg } \" ) return result def init ( self , plugins : list [ \"Plugin\" ]) -> None : \"\"\"Plugins initialization.\"\"\" for plugin in plugins : plugin . register ( self ) def decorate ( self , cmd : str , instance : Any , strategy : Any , ) -> str : \"\"\"Decorate the command for the solver.\"\"\" for plugin in self . decorators : cmd = plugin . decorate ( cmd , instance , strategy ) return cmd def update ( self , instance : Any , strategy : Any , output : str , result : \"Result\" , ) -> None : \"\"\"Update the solver result and announce the final version.\"\"\" for plugin in self . decorators : plugin . update ( instance , strategy , output , result ) for plugin in self . decorators : plugin . finished ( instance , strategy , output , result ) def translate ( self , instance : Any , strategy : Any , ) -> tuple [ Any , Any ]: \"\"\"Translate the instance and strategy for the solver.\"\"\" for plugin in self . translators : ( instance , strategy ) = plugin . translate ( instance , strategy ) return ( instance , strategy ) def call ( self , pid : str , method : str , * args , ** kwargs , ): \"\"\"Call `method` of the plugin(s) `pid`.\"\"\" for plugin in self . translators + self . decorators : if ( plugin . id == pid ): if hasattr ( plugin , method ): handler = getattr ( plugin , method ) handler ( * args , ** kwargs ) else : logger . warning ( f \"Unknown method { method } of plugin { pid } \" ) call ( pid , method , * args , ** kwargs ) Call method of the plugin(s) pid . Source code in src/solverpy/solver/pluginsolver.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 def call ( self , pid : str , method : str , * args , ** kwargs , ): \"\"\"Call `method` of the plugin(s) `pid`.\"\"\" for plugin in self . translators + self . decorators : if ( plugin . id == pid ): if hasattr ( plugin , method ): handler = getattr ( plugin , method ) handler ( * args , ** kwargs ) else : logger . warning ( f \"Unknown method { method } of plugin { pid } \" ) decorate ( cmd , instance , strategy ) Decorate the command for the solver. Source code in src/solverpy/solver/pluginsolver.py 55 56 57 58 59 60 61 62 63 64 def decorate ( self , cmd : str , instance : Any , strategy : Any , ) -> str : \"\"\"Decorate the command for the solver.\"\"\" for plugin in self . decorators : cmd = plugin . decorate ( cmd , instance , strategy ) return cmd init ( plugins ) Plugins initialization. Source code in src/solverpy/solver/pluginsolver.py 50 51 52 53 def init ( self , plugins : list [ \"Plugin\" ]) -> None : \"\"\"Plugins initialization.\"\"\" for plugin in plugins : plugin . register ( self ) solve ( instance , strategy ) Run the solver with the strategy on the instatance. Update the solver result and announce the final version. Return the updated result. Source code in src/solverpy/solver/pluginsolver.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 def solve ( self , instance : Any , strategy : Any ) -> \"Result\" : \"\"\" Run the solver with the strategy on the instatance. Update the solver result and announce the final version. Return the updated result. \"\"\" result = Solver . solve ( self , instance , strategy ) output = self . _output self . update ( instance , strategy , output , result ) if not self . valid ( result ): lines = output . split ( \" \\n \" ) if len ( lines ) > 3 : msg = f \" { lines [ 2 ] } \\n { lines [ 3 ] } \" # command and first output line else : msg = output logger . debug ( f \"failed solver run: { self } : { strategy } @ { instance } \\n result: { result } \\n { msg } \" ) return result translate ( instance , strategy ) Translate the instance and strategy for the solver. Source code in src/solverpy/solver/pluginsolver.py 79 80 81 82 83 84 85 86 87 def translate ( self , instance : Any , strategy : Any , ) -> tuple [ Any , Any ]: \"\"\"Translate the instance and strategy for the solver.\"\"\" for plugin in self . translators : ( instance , strategy ) = plugin . translate ( instance , strategy ) return ( instance , strategy ) update ( instance , strategy , output , result ) Update the solver result and announce the final version. Source code in src/solverpy/solver/pluginsolver.py 66 67 68 69 70 71 72 73 74 75 76 77 def update ( self , instance : Any , strategy : Any , output : str , result : \"Result\" , ) -> None : \"\"\"Update the solver result and announce the final version.\"\"\" for plugin in self . decorators : plugin . update ( instance , strategy , output , result ) for plugin in self . decorators : plugin . finished ( instance , strategy , output , result )","title":"\ud83e\udd16 pluginsolver"},{"location":"api/solverpy/solver/pluginsolver/#module-pluginsolver","text":"","title":"module pluginsolver"},{"location":"api/solverpy/solver/pluginsolver/#solverpy.solver.pluginsolver.PluginSolver","text":"Bases: Solver Source code in src/solverpy/solver/pluginsolver.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 class PluginSolver ( Solver ): def __init__ ( self , plugins : list [ \"Plugin\" ] = [], ** kwargs : Any ): Solver . __init__ ( self , ** kwargs ) self . decorators : list [ \"Decorator\" ] = [] self . translators : list [ \"Translator\" ] = [] self . init ( plugins ) def represent ( self ): return dict ( cls = self . name , decorators = [ repr ( x ) for x in self . decorators ], translators = [ repr ( x ) for x in self . translators ], ) def solve ( self , instance : Any , strategy : Any ) -> \"Result\" : \"\"\" Run the solver with the strategy on the instatance. Update the solver result and announce the final version. Return the updated result. \"\"\" result = Solver . solve ( self , instance , strategy ) output = self . _output self . update ( instance , strategy , output , result ) if not self . valid ( result ): lines = output . split ( \" \\n \" ) if len ( lines ) > 3 : msg = f \" { lines [ 2 ] } \\n { lines [ 3 ] } \" # command and first output line else : msg = output logger . debug ( f \"failed solver run: { self } : { strategy } @ { instance } \\n result: { result } \\n { msg } \" ) return result def init ( self , plugins : list [ \"Plugin\" ]) -> None : \"\"\"Plugins initialization.\"\"\" for plugin in plugins : plugin . register ( self ) def decorate ( self , cmd : str , instance : Any , strategy : Any , ) -> str : \"\"\"Decorate the command for the solver.\"\"\" for plugin in self . decorators : cmd = plugin . decorate ( cmd , instance , strategy ) return cmd def update ( self , instance : Any , strategy : Any , output : str , result : \"Result\" , ) -> None : \"\"\"Update the solver result and announce the final version.\"\"\" for plugin in self . decorators : plugin . update ( instance , strategy , output , result ) for plugin in self . decorators : plugin . finished ( instance , strategy , output , result ) def translate ( self , instance : Any , strategy : Any , ) -> tuple [ Any , Any ]: \"\"\"Translate the instance and strategy for the solver.\"\"\" for plugin in self . translators : ( instance , strategy ) = plugin . translate ( instance , strategy ) return ( instance , strategy ) def call ( self , pid : str , method : str , * args , ** kwargs , ): \"\"\"Call `method` of the plugin(s) `pid`.\"\"\" for plugin in self . translators + self . decorators : if ( plugin . id == pid ): if hasattr ( plugin , method ): handler = getattr ( plugin , method ) handler ( * args , ** kwargs ) else : logger . warning ( f \"Unknown method { method } of plugin { pid } \" )","title":"PluginSolver"},{"location":"api/solverpy/solver/pluginsolver/#solverpy.solver.pluginsolver.PluginSolver.call","text":"Call method of the plugin(s) pid . Source code in src/solverpy/solver/pluginsolver.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 def call ( self , pid : str , method : str , * args , ** kwargs , ): \"\"\"Call `method` of the plugin(s) `pid`.\"\"\" for plugin in self . translators + self . decorators : if ( plugin . id == pid ): if hasattr ( plugin , method ): handler = getattr ( plugin , method ) handler ( * args , ** kwargs ) else : logger . warning ( f \"Unknown method { method } of plugin { pid } \" )","title":"call"},{"location":"api/solverpy/solver/pluginsolver/#solverpy.solver.pluginsolver.PluginSolver.decorate","text":"Decorate the command for the solver. Source code in src/solverpy/solver/pluginsolver.py 55 56 57 58 59 60 61 62 63 64 def decorate ( self , cmd : str , instance : Any , strategy : Any , ) -> str : \"\"\"Decorate the command for the solver.\"\"\" for plugin in self . decorators : cmd = plugin . decorate ( cmd , instance , strategy ) return cmd","title":"decorate"},{"location":"api/solverpy/solver/pluginsolver/#solverpy.solver.pluginsolver.PluginSolver.init","text":"Plugins initialization. Source code in src/solverpy/solver/pluginsolver.py 50 51 52 53 def init ( self , plugins : list [ \"Plugin\" ]) -> None : \"\"\"Plugins initialization.\"\"\" for plugin in plugins : plugin . register ( self )","title":"init"},{"location":"api/solverpy/solver/pluginsolver/#solverpy.solver.pluginsolver.PluginSolver.solve","text":"Run the solver with the strategy on the instatance. Update the solver result and announce the final version. Return the updated result. Source code in src/solverpy/solver/pluginsolver.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 def solve ( self , instance : Any , strategy : Any ) -> \"Result\" : \"\"\" Run the solver with the strategy on the instatance. Update the solver result and announce the final version. Return the updated result. \"\"\" result = Solver . solve ( self , instance , strategy ) output = self . _output self . update ( instance , strategy , output , result ) if not self . valid ( result ): lines = output . split ( \" \\n \" ) if len ( lines ) > 3 : msg = f \" { lines [ 2 ] } \\n { lines [ 3 ] } \" # command and first output line else : msg = output logger . debug ( f \"failed solver run: { self } : { strategy } @ { instance } \\n result: { result } \\n { msg } \" ) return result","title":"solve"},{"location":"api/solverpy/solver/pluginsolver/#solverpy.solver.pluginsolver.PluginSolver.translate","text":"Translate the instance and strategy for the solver. Source code in src/solverpy/solver/pluginsolver.py 79 80 81 82 83 84 85 86 87 def translate ( self , instance : Any , strategy : Any , ) -> tuple [ Any , Any ]: \"\"\"Translate the instance and strategy for the solver.\"\"\" for plugin in self . translators : ( instance , strategy ) = plugin . translate ( instance , strategy ) return ( instance , strategy )","title":"translate"},{"location":"api/solverpy/solver/pluginsolver/#solverpy.solver.pluginsolver.PluginSolver.update","text":"Update the solver result and announce the final version. Source code in src/solverpy/solver/pluginsolver.py 66 67 68 69 70 71 72 73 74 75 76 77 def update ( self , instance : Any , strategy : Any , output : str , result : \"Result\" , ) -> None : \"\"\"Update the solver result and announce the final version.\"\"\" for plugin in self . decorators : plugin . update ( instance , strategy , output , result ) for plugin in self . decorators : plugin . finished ( instance , strategy , output , result )","title":"update"},{"location":"api/solverpy/solver/reloader/","text":"module reloader","title":"\ud83e\udd16 reloader"},{"location":"api/solverpy/solver/reloader/#module-reloader","text":"","title":"module reloader"},{"location":"api/solverpy/solver/shellsolver/","text":"module shellsolver","title":"\ud83e\udd16 shellsolver"},{"location":"api/solverpy/solver/shellsolver/#module-shellsolver","text":"","title":"module shellsolver"},{"location":"api/solverpy/solver/solver/","text":"module solver Abstract solver interface Defines a basic interface for all solvers. Implemented methods The main method solve solves the problem and returns a processed result. It calls run and process in sequence which need to implemented by subclasses. Result queries valid , solved to recognize a valid and solved results. Abstract methods running the solver: run processing the output: process status sets: success , timeouts , statuses Solver Bases: SolverPyObj Abstract class for solvers. Source code in src/solverpy/solver/solver.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 class Solver ( SolverPyObj ): \"\"\" Abstract class for solvers. \"\"\" def __init__ ( self , ** kwargs : Any ): SolverPyObj . __init__ ( self , ** kwargs ) def __str__ ( self ) -> str : return self . name def solve ( self , instance : Any , strategy : Any ) -> Any : \"\"\" Run the solver with the strategy on the instatance. Process the output and create the result. Args: instance: solver problem instance (filename, or a bid-problem pair, or custom). strategy: solver strategy (filename, sid, or custom). Returns: the result \"\"\" output = self . run ( instance , strategy ) self . _output = output result = self . process ( output ) return result def valid ( self , result : \"Result\" ) -> bool : \"\"\" A valid status contains at least keys `status` and `runtime`. The status must be a valid status. Args: result: the result \"\"\" return bool ( result ) and \\ ( \"status\" in result ) and \\ ( \"runtime\" in result ) and \\ ( result [ \"status\" ] in self . statuses ) def solved ( self , result : \"Result\" ) -> bool : \"\"\" The result is solved if the status is in the success set. Args: result: the result \"\"\" return bool ( result ) and \\ ( \"status\" in result ) and \\ ( result [ \"status\" ] in self . success ) def run ( self , instance : Any , strategy : Any ) -> str : \"\"\" Run the solver with the strategy on the instatnce. Args: instance: solver problem instance strategy: solver strategy Returns: raw solver output Raises: NotImplementedError: abstract method \"\"\" del instance , strategy # unused arguments raise NotImplementedError () def process ( self , output : str ) -> \"Result\" : \"\"\" Process the solver output and create the result. Args: output: raw solver output Returns: processed result dictionary Raises: NotImplementedError: abstract method \"\"\" del output # unused argument raise NotImplementedError () @property def name ( self ) -> str : \"\"\" Solver name. The default name is the class name. \"\"\" return self . __class__ . __name__ @property def success ( self ) -> frozenset [ str ]: \"\"\" The set of successful statuses. Raises: NotImplementedError: abstract property \"\"\" raise NotImplementedError () @property def timeouts ( self ) -> frozenset [ str ]: \"\"\" The set of timeout statuses. Raises: NotImplementedError: abstract property \"\"\" raise NotImplementedError () @property def statuses ( self ) -> frozenset [ str ]: \"\"\" The set of all valid statuses. Raises: NotImplementedError: abstract property \"\"\" raise NotImplementedError () name : str property Solver name. The default name is the class name. statuses : frozenset [ str ] property The set of all valid statuses. Raises: Type Description NotImplementedError abstract property success : frozenset [ str ] property The set of successful statuses. Raises: Type Description NotImplementedError abstract property timeouts : frozenset [ str ] property The set of timeout statuses. Raises: Type Description NotImplementedError abstract property process ( output ) Process the solver output and create the result. Parameters: Name Type Description Default output str raw solver output required Returns: processed result dictionary Raises: Type Description NotImplementedError abstract method Source code in src/solverpy/solver/solver.py 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 def process ( self , output : str ) -> \"Result\" : \"\"\" Process the solver output and create the result. Args: output: raw solver output Returns: processed result dictionary Raises: NotImplementedError: abstract method \"\"\" del output # unused argument raise NotImplementedError () run ( instance , strategy ) Run the solver with the strategy on the instatnce. Parameters: Name Type Description Default instance Any solver problem instance required strategy Any solver strategy required Returns: raw solver output Raises: Type Description NotImplementedError abstract method Source code in src/solverpy/solver/solver.py 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 def run ( self , instance : Any , strategy : Any ) -> str : \"\"\" Run the solver with the strategy on the instatnce. Args: instance: solver problem instance strategy: solver strategy Returns: raw solver output Raises: NotImplementedError: abstract method \"\"\" del instance , strategy # unused arguments raise NotImplementedError () solve ( instance , strategy ) Run the solver with the strategy on the instatance. Process the output and create the result. Parameters: Name Type Description Default instance Any solver problem instance (filename, or a bid-problem pair, or custom). required strategy Any solver strategy (filename, sid, or custom). required Returns: the result Source code in src/solverpy/solver/solver.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 def solve ( self , instance : Any , strategy : Any ) -> Any : \"\"\" Run the solver with the strategy on the instatance. Process the output and create the result. Args: instance: solver problem instance (filename, or a bid-problem pair, or custom). strategy: solver strategy (filename, sid, or custom). Returns: the result \"\"\" output = self . run ( instance , strategy ) self . _output = output result = self . process ( output ) return result solved ( result ) The result is solved if the status is in the success set. Parameters: Name Type Description Default result Result the result required Source code in src/solverpy/solver/solver.py 75 76 77 78 79 80 81 82 83 84 def solved ( self , result : \"Result\" ) -> bool : \"\"\" The result is solved if the status is in the success set. Args: result: the result \"\"\" return bool ( result ) and \\ ( \"status\" in result ) and \\ ( result [ \"status\" ] in self . success ) valid ( result ) A valid status contains at least keys status and runtime . The status must be a valid status. Parameters: Name Type Description Default result Result the result required Source code in src/solverpy/solver/solver.py 62 63 64 65 66 67 68 69 70 71 72 73 def valid ( self , result : \"Result\" ) -> bool : \"\"\" A valid status contains at least keys `status` and `runtime`. The status must be a valid status. Args: result: the result \"\"\" return bool ( result ) and \\ ( \"status\" in result ) and \\ ( \"runtime\" in result ) and \\ ( result [ \"status\" ] in self . statuses )","title":"\ud83e\udd16 solver"},{"location":"api/solverpy/solver/solver/#module-solver","text":"","title":"module solver"},{"location":"api/solverpy/solver/solver/#solverpy.solver.solver--abstract-solver-interface","text":"Defines a basic interface for all solvers.","title":"Abstract solver interface"},{"location":"api/solverpy/solver/solver/#solverpy.solver.solver--implemented-methods","text":"The main method solve solves the problem and returns a processed result. It calls run and process in sequence which need to implemented by subclasses. Result queries valid , solved to recognize a valid and solved results.","title":"Implemented methods"},{"location":"api/solverpy/solver/solver/#solverpy.solver.solver--abstract-methods","text":"running the solver: run processing the output: process status sets: success , timeouts , statuses","title":"Abstract methods"},{"location":"api/solverpy/solver/solver/#solverpy.solver.solver.Solver","text":"Bases: SolverPyObj Abstract class for solvers. Source code in src/solverpy/solver/solver.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 class Solver ( SolverPyObj ): \"\"\" Abstract class for solvers. \"\"\" def __init__ ( self , ** kwargs : Any ): SolverPyObj . __init__ ( self , ** kwargs ) def __str__ ( self ) -> str : return self . name def solve ( self , instance : Any , strategy : Any ) -> Any : \"\"\" Run the solver with the strategy on the instatance. Process the output and create the result. Args: instance: solver problem instance (filename, or a bid-problem pair, or custom). strategy: solver strategy (filename, sid, or custom). Returns: the result \"\"\" output = self . run ( instance , strategy ) self . _output = output result = self . process ( output ) return result def valid ( self , result : \"Result\" ) -> bool : \"\"\" A valid status contains at least keys `status` and `runtime`. The status must be a valid status. Args: result: the result \"\"\" return bool ( result ) and \\ ( \"status\" in result ) and \\ ( \"runtime\" in result ) and \\ ( result [ \"status\" ] in self . statuses ) def solved ( self , result : \"Result\" ) -> bool : \"\"\" The result is solved if the status is in the success set. Args: result: the result \"\"\" return bool ( result ) and \\ ( \"status\" in result ) and \\ ( result [ \"status\" ] in self . success ) def run ( self , instance : Any , strategy : Any ) -> str : \"\"\" Run the solver with the strategy on the instatnce. Args: instance: solver problem instance strategy: solver strategy Returns: raw solver output Raises: NotImplementedError: abstract method \"\"\" del instance , strategy # unused arguments raise NotImplementedError () def process ( self , output : str ) -> \"Result\" : \"\"\" Process the solver output and create the result. Args: output: raw solver output Returns: processed result dictionary Raises: NotImplementedError: abstract method \"\"\" del output # unused argument raise NotImplementedError () @property def name ( self ) -> str : \"\"\" Solver name. The default name is the class name. \"\"\" return self . __class__ . __name__ @property def success ( self ) -> frozenset [ str ]: \"\"\" The set of successful statuses. Raises: NotImplementedError: abstract property \"\"\" raise NotImplementedError () @property def timeouts ( self ) -> frozenset [ str ]: \"\"\" The set of timeout statuses. Raises: NotImplementedError: abstract property \"\"\" raise NotImplementedError () @property def statuses ( self ) -> frozenset [ str ]: \"\"\" The set of all valid statuses. Raises: NotImplementedError: abstract property \"\"\" raise NotImplementedError ()","title":"Solver"},{"location":"api/solverpy/solver/solver/#solverpy.solver.solver.Solver.name","text":"Solver name. The default name is the class name.","title":"name"},{"location":"api/solverpy/solver/solver/#solverpy.solver.solver.Solver.statuses","text":"The set of all valid statuses. Raises: Type Description NotImplementedError abstract property","title":"statuses"},{"location":"api/solverpy/solver/solver/#solverpy.solver.solver.Solver.success","text":"The set of successful statuses. Raises: Type Description NotImplementedError abstract property","title":"success"},{"location":"api/solverpy/solver/solver/#solverpy.solver.solver.Solver.timeouts","text":"The set of timeout statuses. Raises: Type Description NotImplementedError abstract property","title":"timeouts"},{"location":"api/solverpy/solver/solver/#solverpy.solver.solver.Solver.process","text":"Process the solver output and create the result. Parameters: Name Type Description Default output str raw solver output required Returns: processed result dictionary Raises: Type Description NotImplementedError abstract method Source code in src/solverpy/solver/solver.py 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 def process ( self , output : str ) -> \"Result\" : \"\"\" Process the solver output and create the result. Args: output: raw solver output Returns: processed result dictionary Raises: NotImplementedError: abstract method \"\"\" del output # unused argument raise NotImplementedError ()","title":"process"},{"location":"api/solverpy/solver/solver/#solverpy.solver.solver.Solver.run","text":"Run the solver with the strategy on the instatnce. Parameters: Name Type Description Default instance Any solver problem instance required strategy Any solver strategy required Returns: raw solver output Raises: Type Description NotImplementedError abstract method Source code in src/solverpy/solver/solver.py 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 def run ( self , instance : Any , strategy : Any ) -> str : \"\"\" Run the solver with the strategy on the instatnce. Args: instance: solver problem instance strategy: solver strategy Returns: raw solver output Raises: NotImplementedError: abstract method \"\"\" del instance , strategy # unused arguments raise NotImplementedError ()","title":"run"},{"location":"api/solverpy/solver/solver/#solverpy.solver.solver.Solver.solve","text":"Run the solver with the strategy on the instatance. Process the output and create the result. Parameters: Name Type Description Default instance Any solver problem instance (filename, or a bid-problem pair, or custom). required strategy Any solver strategy (filename, sid, or custom). required Returns: the result Source code in src/solverpy/solver/solver.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 def solve ( self , instance : Any , strategy : Any ) -> Any : \"\"\" Run the solver with the strategy on the instatance. Process the output and create the result. Args: instance: solver problem instance (filename, or a bid-problem pair, or custom). strategy: solver strategy (filename, sid, or custom). Returns: the result \"\"\" output = self . run ( instance , strategy ) self . _output = output result = self . process ( output ) return result","title":"solve"},{"location":"api/solverpy/solver/solver/#solverpy.solver.solver.Solver.solved","text":"The result is solved if the status is in the success set. Parameters: Name Type Description Default result Result the result required Source code in src/solverpy/solver/solver.py 75 76 77 78 79 80 81 82 83 84 def solved ( self , result : \"Result\" ) -> bool : \"\"\" The result is solved if the status is in the success set. Args: result: the result \"\"\" return bool ( result ) and \\ ( \"status\" in result ) and \\ ( result [ \"status\" ] in self . success )","title":"solved"},{"location":"api/solverpy/solver/solver/#solverpy.solver.solver.Solver.valid","text":"A valid status contains at least keys status and runtime . The status must be a valid status. Parameters: Name Type Description Default result Result the result required Source code in src/solverpy/solver/solver.py 62 63 64 65 66 67 68 69 70 71 72 73 def valid ( self , result : \"Result\" ) -> bool : \"\"\" A valid status contains at least keys `status` and `runtime`. The status must be a valid status. Args: result: the result \"\"\" return bool ( result ) and \\ ( \"status\" in result ) and \\ ( \"runtime\" in result ) and \\ ( result [ \"status\" ] in self . statuses )","title":"valid"},{"location":"api/solverpy/solver/solverpy/","text":"module solverpy SolverPy Bases: PluginSolver Source code in src/solverpy/solver/solverpy.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 class SolverPy ( PluginSolver ): def __init__ ( self , limits : Limits , plugins : list [ \"Plugin\" ] = [], ** kwargs : Any , ): assert limits . limit . startswith ( \"T\" ) self . _limits : Limits = limits self . _exitcode : int = - 1 self . _timeouts = frozenset () self . _success = frozenset () self . _statuses = frozenset () plugins = plugins + [ Limiter (), ] PluginSolver . __init__ ( self , plugins = plugins , ** kwargs ) def simulate ( self , result : \"Result\" ) -> \"Result | None\" : \"Simulate run from the past result.\" if result [ \"status\" ] in self . timeouts : #if result[\"status\"] not in self.success: # we might want this? oldlimits = Limits ( result [ \"limit\" ], {}) # the cached result is timeout if oldlimits < self . _limits : #if result[\"runtime\"] < self.timeout: # recompute since we have more time or/and space return None elif result [ \"status\" ] in self . success : # the cached result is solved if result [ \"runtime\" ] > self . _limits . timeout : #if result[\"runtime\"] > self.timeout: # simulated timeout return dict ( result , status = \"TIMEOUT\" , runtime = self . _limits . timeout , ) else : # recompute unknown results (GaveUp, unknown) # TODO: do we want to always recompute? return None # the result is applicable without changes return result @property def timeouts ( self ) -> frozenset [ str ]: return self . _timeouts @property def success ( self ) -> frozenset [ str ]: return self . _success @property def statuses ( self ) -> frozenset [ str ]: return self . _statuses simulate ( result ) Simulate run from the past result. Source code in src/solverpy/solver/solverpy.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 def simulate ( self , result : \"Result\" ) -> \"Result | None\" : \"Simulate run from the past result.\" if result [ \"status\" ] in self . timeouts : #if result[\"status\"] not in self.success: # we might want this? oldlimits = Limits ( result [ \"limit\" ], {}) # the cached result is timeout if oldlimits < self . _limits : #if result[\"runtime\"] < self.timeout: # recompute since we have more time or/and space return None elif result [ \"status\" ] in self . success : # the cached result is solved if result [ \"runtime\" ] > self . _limits . timeout : #if result[\"runtime\"] > self.timeout: # simulated timeout return dict ( result , status = \"TIMEOUT\" , runtime = self . _limits . timeout , ) else : # recompute unknown results (GaveUp, unknown) # TODO: do we want to always recompute? return None # the result is applicable without changes return result","title":"\ud83e\udd16 solverpy"},{"location":"api/solverpy/solver/solverpy/#module-solverpy","text":"","title":"module solverpy"},{"location":"api/solverpy/solver/solverpy/#solverpy.solver.solverpy.SolverPy","text":"Bases: PluginSolver Source code in src/solverpy/solver/solverpy.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 class SolverPy ( PluginSolver ): def __init__ ( self , limits : Limits , plugins : list [ \"Plugin\" ] = [], ** kwargs : Any , ): assert limits . limit . startswith ( \"T\" ) self . _limits : Limits = limits self . _exitcode : int = - 1 self . _timeouts = frozenset () self . _success = frozenset () self . _statuses = frozenset () plugins = plugins + [ Limiter (), ] PluginSolver . __init__ ( self , plugins = plugins , ** kwargs ) def simulate ( self , result : \"Result\" ) -> \"Result | None\" : \"Simulate run from the past result.\" if result [ \"status\" ] in self . timeouts : #if result[\"status\"] not in self.success: # we might want this? oldlimits = Limits ( result [ \"limit\" ], {}) # the cached result is timeout if oldlimits < self . _limits : #if result[\"runtime\"] < self.timeout: # recompute since we have more time or/and space return None elif result [ \"status\" ] in self . success : # the cached result is solved if result [ \"runtime\" ] > self . _limits . timeout : #if result[\"runtime\"] > self.timeout: # simulated timeout return dict ( result , status = \"TIMEOUT\" , runtime = self . _limits . timeout , ) else : # recompute unknown results (GaveUp, unknown) # TODO: do we want to always recompute? return None # the result is applicable without changes return result @property def timeouts ( self ) -> frozenset [ str ]: return self . _timeouts @property def success ( self ) -> frozenset [ str ]: return self . _success @property def statuses ( self ) -> frozenset [ str ]: return self . _statuses","title":"SolverPy"},{"location":"api/solverpy/solver/solverpy/#solverpy.solver.solverpy.SolverPy.simulate","text":"Simulate run from the past result. Source code in src/solverpy/solver/solverpy.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 def simulate ( self , result : \"Result\" ) -> \"Result | None\" : \"Simulate run from the past result.\" if result [ \"status\" ] in self . timeouts : #if result[\"status\"] not in self.success: # we might want this? oldlimits = Limits ( result [ \"limit\" ], {}) # the cached result is timeout if oldlimits < self . _limits : #if result[\"runtime\"] < self.timeout: # recompute since we have more time or/and space return None elif result [ \"status\" ] in self . success : # the cached result is solved if result [ \"runtime\" ] > self . _limits . timeout : #if result[\"runtime\"] > self.timeout: # simulated timeout return dict ( result , status = \"TIMEOUT\" , runtime = self . _limits . timeout , ) else : # recompute unknown results (GaveUp, unknown) # TODO: do we want to always recompute? return None # the result is applicable without changes return result","title":"simulate"},{"location":"api/solverpy/solver/stdinsolver/","text":"module stdinsolver","title":"\ud83e\udd16 stdinsolver"},{"location":"api/solverpy/solver/stdinsolver/#module-stdinsolver","text":"","title":"module stdinsolver"},{"location":"api/solverpy/solver/atp/","text":"Atp Overview","title":"\u2139\ufe0f Overview"},{"location":"api/solverpy/solver/atp/#atp-overview","text":"","title":"Atp Overview"},{"location":"api/solverpy/solver/atp/cvc5/","text":"module cvc5","title":"\ud83e\udd16 cvc5"},{"location":"api/solverpy/solver/atp/cvc5/#module-cvc5","text":"","title":"module cvc5"},{"location":"api/solverpy/solver/atp/eprover/","text":"module eprover","title":"\ud83e\udd16 eprover"},{"location":"api/solverpy/solver/atp/eprover/#module-eprover","text":"","title":"module eprover"},{"location":"api/solverpy/solver/atp/lash/","text":"module lash","title":"\ud83e\udd16 lash"},{"location":"api/solverpy/solver/atp/lash/#module-lash","text":"","title":"module lash"},{"location":"api/solverpy/solver/atp/prover9/","text":"module prover9","title":"\ud83e\udd16 prover9"},{"location":"api/solverpy/solver/atp/prover9/#module-prover9","text":"","title":"module prover9"},{"location":"api/solverpy/solver/atp/vampire/","text":"module vampire","title":"\ud83e\udd16 vampire"},{"location":"api/solverpy/solver/atp/vampire/#module-vampire","text":"","title":"module vampire"},{"location":"api/solverpy/solver/plugins/","text":"Plugins Overview","title":"\u2139\ufe0f Overview"},{"location":"api/solverpy/solver/plugins/#plugins-overview","text":"","title":"Plugins Overview"},{"location":"api/solverpy/solver/plugins/decorator/","text":"module decorator","title":"\ud83e\udd16 decorator"},{"location":"api/solverpy/solver/plugins/decorator/#module-decorator","text":"","title":"module decorator"},{"location":"api/solverpy/solver/plugins/plugin/","text":"module plugin","title":"\ud83e\udd16 plugin"},{"location":"api/solverpy/solver/plugins/plugin/#module-plugin","text":"","title":"module plugin"},{"location":"api/solverpy/solver/plugins/translator/","text":"module translator","title":"\ud83e\udd16 translator"},{"location":"api/solverpy/solver/plugins/translator/#module-translator","text":"","title":"module translator"},{"location":"api/solverpy/solver/plugins/db/","text":"Db Overview Bid Bases: Translator Benchmark ids translator. Source code in src/solverpy/solver/plugins/db/bid.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Bid ( Translator ): \"Benchmark ids translator.\" def __init__ ( self , ** kwargs ): Translator . __init__ ( self , ** kwargs ) def translate ( self , instance : tuple [ str , str ], strategy : Any ) -> tuple [ str , Any ]: ( bid , problem ) = instance instance0 = bids . path ( bid , problem ) return ( instance0 , strategy ) Sid Bases: Translator Strategy ids translator. Source code in src/solverpy/solver/plugins/db/sid.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Sid ( Translator ): \"Strategy ids translator.\" def translate ( self , instance : Any , strategy : str , ) -> tuple [ Any , str ]: sid = strategy strategy0 = sids . load ( sid ) if \"@@@\" in strategy0 : ( sid , args ) = sids . split ( sid ) strategy0 = sids . instatiate ( strategy0 , args ) return ( instance , strategy0 )","title":"\u2139\ufe0f Overview"},{"location":"api/solverpy/solver/plugins/db/#db-overview","text":"","title":"Db Overview"},{"location":"api/solverpy/solver/plugins/db/#solverpy.solver.plugins.db.Bid","text":"Bases: Translator Benchmark ids translator. Source code in src/solverpy/solver/plugins/db/bid.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Bid ( Translator ): \"Benchmark ids translator.\" def __init__ ( self , ** kwargs ): Translator . __init__ ( self , ** kwargs ) def translate ( self , instance : tuple [ str , str ], strategy : Any ) -> tuple [ str , Any ]: ( bid , problem ) = instance instance0 = bids . path ( bid , problem ) return ( instance0 , strategy )","title":"Bid"},{"location":"api/solverpy/solver/plugins/db/#solverpy.solver.plugins.db.Sid","text":"Bases: Translator Strategy ids translator. Source code in src/solverpy/solver/plugins/db/sid.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Sid ( Translator ): \"Strategy ids translator.\" def translate ( self , instance : Any , strategy : str , ) -> tuple [ Any , str ]: sid = strategy strategy0 = sids . load ( sid ) if \"@@@\" in strategy0 : ( sid , args ) = sids . split ( sid ) strategy0 = sids . instatiate ( strategy0 , args ) return ( instance , strategy0 )","title":"Sid"},{"location":"api/solverpy/solver/plugins/db/bid/","text":"module bid Bid Bases: Translator Benchmark ids translator. Source code in src/solverpy/solver/plugins/db/bid.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Bid ( Translator ): \"Benchmark ids translator.\" def __init__ ( self , ** kwargs ): Translator . __init__ ( self , ** kwargs ) def translate ( self , instance : tuple [ str , str ], strategy : Any ) -> tuple [ str , Any ]: ( bid , problem ) = instance instance0 = bids . path ( bid , problem ) return ( instance0 , strategy )","title":"\ud83e\udd16 bid"},{"location":"api/solverpy/solver/plugins/db/bid/#module-bid","text":"","title":"module bid"},{"location":"api/solverpy/solver/plugins/db/bid/#solverpy.solver.plugins.db.bid.Bid","text":"Bases: Translator Benchmark ids translator. Source code in src/solverpy/solver/plugins/db/bid.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Bid ( Translator ): \"Benchmark ids translator.\" def __init__ ( self , ** kwargs ): Translator . __init__ ( self , ** kwargs ) def translate ( self , instance : tuple [ str , str ], strategy : Any ) -> tuple [ str , Any ]: ( bid , problem ) = instance instance0 = bids . path ( bid , problem ) return ( instance0 , strategy )","title":"Bid"},{"location":"api/solverpy/solver/plugins/db/errors/","text":"module errors","title":"\ud83e\udd16 errors"},{"location":"api/solverpy/solver/plugins/db/errors/#module-errors","text":"","title":"module errors"},{"location":"api/solverpy/solver/plugins/db/outputs/","text":"module outputs","title":"\ud83e\udd16 outputs"},{"location":"api/solverpy/solver/plugins/db/outputs/#module-outputs","text":"","title":"module outputs"},{"location":"api/solverpy/solver/plugins/db/sid/","text":"module sid Sid Bases: Translator Strategy ids translator. Source code in src/solverpy/solver/plugins/db/sid.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Sid ( Translator ): \"Strategy ids translator.\" def translate ( self , instance : Any , strategy : str , ) -> tuple [ Any , str ]: sid = strategy strategy0 = sids . load ( sid ) if \"@@@\" in strategy0 : ( sid , args ) = sids . split ( sid ) strategy0 = sids . instatiate ( strategy0 , args ) return ( instance , strategy0 )","title":"\ud83e\udd16 sid"},{"location":"api/solverpy/solver/plugins/db/sid/#module-sid","text":"","title":"module sid"},{"location":"api/solverpy/solver/plugins/db/sid/#solverpy.solver.plugins.db.sid.Sid","text":"Bases: Translator Strategy ids translator. Source code in src/solverpy/solver/plugins/db/sid.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Sid ( Translator ): \"Strategy ids translator.\" def translate ( self , instance : Any , strategy : str , ) -> tuple [ Any , str ]: sid = strategy strategy0 = sids . load ( sid ) if \"@@@\" in strategy0 : ( sid , args ) = sids . split ( sid ) strategy0 = sids . instatiate ( strategy0 , args ) return ( instance , strategy0 )","title":"Sid"},{"location":"api/solverpy/solver/plugins/shell/","text":"Shell Overview Limits Bases: Decorator , Translator This is either a decorator or a translator based on the value of cmdline . Source code in src/solverpy/solver/plugins/shell/limits.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 class Limits ( Decorator , Translator ): \"\"\" This is either a decorator or a translator based on the value of `cmdline`. \"\"\" def __init__ ( self , limit : str , builder : \"LimitBuilder\" , cmdline : bool = True , inputfile : bool = False , ): Plugin . __init__ ( self , limit = limit , cmdline = cmdline , ) lims = { x [ 0 ]: x [ 1 :] for x in limit . split ( \"-\" ) if x } assert \"T\" in lims self . timeout = int ( lims [ \"T\" ]) self . memory = float ( lims [ \"M\" ]) if \"M\" in lims else None try : lims = [ build ( builder [ x ], y ) for ( x , y ) in lims . items () if x in builder ] except Exception as e : print ( e ) raise Exception ( f \"solverpy: Invalid limit string: { limit } \" ) delim = \" \" if cmdline else \"\" self . strat = delim . join ( lims ) self . cmdline = cmdline #self.args = \" \".join(lims) self . limit = limit self . _inputfile = inputfile def register ( self , solver : \"SolverPy\" ) -> None : if self . cmdline : solver . decorators . append ( self ) else : solver . translators . append ( self ) def __str__ ( self ) -> str : return self . limit def __lt__ ( self , other ): if self . limit and not other . limit : return None if self . memory and not other . memory : return None if not self . memory : return ( self . timeout < other . timeout ) else : return ( self . timeout < other . timeout ) or ( self . memory < other . memory ) #def __le__(self, other): # return (self.key == other.key) or (self < other) def decorate ( self , cmd : str , instance : Any , strategy : Any , ) -> str : del instance , strategy # unused arguments if self . cmdline : input = \" /dev/stdin\" if self . _inputfile else \"\" return f \" { cmd } { self . strategy }{ input } \" if self . strategy else cmd else : return cmd def translate ( self , instance : Any , strategy : str , ) -> tuple [ Any , str ]: if not self . cmdline : return ( instance , self . strategy + strategy ) else : return ( instance , strategy ) @property def strategy ( self ) -> str : return self . strat","title":"\u2139\ufe0f Overview"},{"location":"api/solverpy/solver/plugins/shell/#shell-overview","text":"","title":"Shell Overview"},{"location":"api/solverpy/solver/plugins/shell/#solverpy.solver.plugins.shell.Limits","text":"Bases: Decorator , Translator This is either a decorator or a translator based on the value of cmdline . Source code in src/solverpy/solver/plugins/shell/limits.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 class Limits ( Decorator , Translator ): \"\"\" This is either a decorator or a translator based on the value of `cmdline`. \"\"\" def __init__ ( self , limit : str , builder : \"LimitBuilder\" , cmdline : bool = True , inputfile : bool = False , ): Plugin . __init__ ( self , limit = limit , cmdline = cmdline , ) lims = { x [ 0 ]: x [ 1 :] for x in limit . split ( \"-\" ) if x } assert \"T\" in lims self . timeout = int ( lims [ \"T\" ]) self . memory = float ( lims [ \"M\" ]) if \"M\" in lims else None try : lims = [ build ( builder [ x ], y ) for ( x , y ) in lims . items () if x in builder ] except Exception as e : print ( e ) raise Exception ( f \"solverpy: Invalid limit string: { limit } \" ) delim = \" \" if cmdline else \"\" self . strat = delim . join ( lims ) self . cmdline = cmdline #self.args = \" \".join(lims) self . limit = limit self . _inputfile = inputfile def register ( self , solver : \"SolverPy\" ) -> None : if self . cmdline : solver . decorators . append ( self ) else : solver . translators . append ( self ) def __str__ ( self ) -> str : return self . limit def __lt__ ( self , other ): if self . limit and not other . limit : return None if self . memory and not other . memory : return None if not self . memory : return ( self . timeout < other . timeout ) else : return ( self . timeout < other . timeout ) or ( self . memory < other . memory ) #def __le__(self, other): # return (self.key == other.key) or (self < other) def decorate ( self , cmd : str , instance : Any , strategy : Any , ) -> str : del instance , strategy # unused arguments if self . cmdline : input = \" /dev/stdin\" if self . _inputfile else \"\" return f \" { cmd } { self . strategy }{ input } \" if self . strategy else cmd else : return cmd def translate ( self , instance : Any , strategy : str , ) -> tuple [ Any , str ]: if not self . cmdline : return ( instance , self . strategy + strategy ) else : return ( instance , strategy ) @property def strategy ( self ) -> str : return self . strat","title":"Limits"},{"location":"api/solverpy/solver/plugins/shell/limits/","text":"module limits Limits Bases: Decorator , Translator This is either a decorator or a translator based on the value of cmdline . Source code in src/solverpy/solver/plugins/shell/limits.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 class Limits ( Decorator , Translator ): \"\"\" This is either a decorator or a translator based on the value of `cmdline`. \"\"\" def __init__ ( self , limit : str , builder : \"LimitBuilder\" , cmdline : bool = True , inputfile : bool = False , ): Plugin . __init__ ( self , limit = limit , cmdline = cmdline , ) lims = { x [ 0 ]: x [ 1 :] for x in limit . split ( \"-\" ) if x } assert \"T\" in lims self . timeout = int ( lims [ \"T\" ]) self . memory = float ( lims [ \"M\" ]) if \"M\" in lims else None try : lims = [ build ( builder [ x ], y ) for ( x , y ) in lims . items () if x in builder ] except Exception as e : print ( e ) raise Exception ( f \"solverpy: Invalid limit string: { limit } \" ) delim = \" \" if cmdline else \"\" self . strat = delim . join ( lims ) self . cmdline = cmdline #self.args = \" \".join(lims) self . limit = limit self . _inputfile = inputfile def register ( self , solver : \"SolverPy\" ) -> None : if self . cmdline : solver . decorators . append ( self ) else : solver . translators . append ( self ) def __str__ ( self ) -> str : return self . limit def __lt__ ( self , other ): if self . limit and not other . limit : return None if self . memory and not other . memory : return None if not self . memory : return ( self . timeout < other . timeout ) else : return ( self . timeout < other . timeout ) or ( self . memory < other . memory ) #def __le__(self, other): # return (self.key == other.key) or (self < other) def decorate ( self , cmd : str , instance : Any , strategy : Any , ) -> str : del instance , strategy # unused arguments if self . cmdline : input = \" /dev/stdin\" if self . _inputfile else \"\" return f \" { cmd } { self . strategy }{ input } \" if self . strategy else cmd else : return cmd def translate ( self , instance : Any , strategy : str , ) -> tuple [ Any , str ]: if not self . cmdline : return ( instance , self . strategy + strategy ) else : return ( instance , strategy ) @property def strategy ( self ) -> str : return self . strat","title":"\ud83e\udd16 limits"},{"location":"api/solverpy/solver/plugins/shell/limits/#module-limits","text":"","title":"module limits"},{"location":"api/solverpy/solver/plugins/shell/limits/#solverpy.solver.plugins.shell.limits.Limits","text":"Bases: Decorator , Translator This is either a decorator or a translator based on the value of cmdline . Source code in src/solverpy/solver/plugins/shell/limits.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 class Limits ( Decorator , Translator ): \"\"\" This is either a decorator or a translator based on the value of `cmdline`. \"\"\" def __init__ ( self , limit : str , builder : \"LimitBuilder\" , cmdline : bool = True , inputfile : bool = False , ): Plugin . __init__ ( self , limit = limit , cmdline = cmdline , ) lims = { x [ 0 ]: x [ 1 :] for x in limit . split ( \"-\" ) if x } assert \"T\" in lims self . timeout = int ( lims [ \"T\" ]) self . memory = float ( lims [ \"M\" ]) if \"M\" in lims else None try : lims = [ build ( builder [ x ], y ) for ( x , y ) in lims . items () if x in builder ] except Exception as e : print ( e ) raise Exception ( f \"solverpy: Invalid limit string: { limit } \" ) delim = \" \" if cmdline else \"\" self . strat = delim . join ( lims ) self . cmdline = cmdline #self.args = \" \".join(lims) self . limit = limit self . _inputfile = inputfile def register ( self , solver : \"SolverPy\" ) -> None : if self . cmdline : solver . decorators . append ( self ) else : solver . translators . append ( self ) def __str__ ( self ) -> str : return self . limit def __lt__ ( self , other ): if self . limit and not other . limit : return None if self . memory and not other . memory : return None if not self . memory : return ( self . timeout < other . timeout ) else : return ( self . timeout < other . timeout ) or ( self . memory < other . memory ) #def __le__(self, other): # return (self.key == other.key) or (self < other) def decorate ( self , cmd : str , instance : Any , strategy : Any , ) -> str : del instance , strategy # unused arguments if self . cmdline : input = \" /dev/stdin\" if self . _inputfile else \"\" return f \" { cmd } { self . strategy }{ input } \" if self . strategy else cmd else : return cmd def translate ( self , instance : Any , strategy : str , ) -> tuple [ Any , str ]: if not self . cmdline : return ( instance , self . strategy + strategy ) else : return ( instance , strategy ) @property def strategy ( self ) -> str : return self . strat","title":"Limits"},{"location":"api/solverpy/solver/plugins/shell/memory/","text":"module memory","title":"\ud83e\udd16 memory"},{"location":"api/solverpy/solver/plugins/shell/memory/#module-memory","text":"","title":"module memory"},{"location":"api/solverpy/solver/plugins/shell/time/","text":"module time","title":"\ud83e\udd16 time"},{"location":"api/solverpy/solver/plugins/shell/time/#module-time","text":"","title":"module time"},{"location":"api/solverpy/solver/plugins/shell/timeout/","text":"module timeout","title":"\ud83e\udd16 timeout"},{"location":"api/solverpy/solver/plugins/shell/timeout/#module-timeout","text":"","title":"module timeout"},{"location":"api/solverpy/solver/plugins/status/","text":"Status Overview","title":"\u2139\ufe0f Overview"},{"location":"api/solverpy/solver/plugins/status/#status-overview","text":"","title":"Status Overview"},{"location":"api/solverpy/solver/plugins/status/limiter/","text":"module limiter","title":"\ud83e\udd16 limiter"},{"location":"api/solverpy/solver/plugins/status/limiter/#module-limiter","text":"","title":"module limiter"},{"location":"api/solverpy/solver/plugins/status/smt/","text":"module smt","title":"\ud83e\udd16 smt"},{"location":"api/solverpy/solver/plugins/status/smt/#module-smt","text":"","title":"module smt"},{"location":"api/solverpy/solver/plugins/status/tptp/","text":"module tptp","title":"\ud83e\udd16 tptp"},{"location":"api/solverpy/solver/plugins/status/tptp/#module-tptp","text":"","title":"module tptp"},{"location":"api/solverpy/solver/smt/","text":"Smt Overview","title":"\u2139\ufe0f Overview"},{"location":"api/solverpy/solver/smt/#smt-overview","text":"","title":"Smt Overview"},{"location":"api/solverpy/solver/smt/bitwuzla/","text":"module bitwuzla","title":"\ud83e\udd16 bitwuzla"},{"location":"api/solverpy/solver/smt/bitwuzla/#module-bitwuzla","text":"","title":"module bitwuzla"},{"location":"api/solverpy/solver/smt/cvc5/","text":"module cvc5","title":"\ud83e\udd16 cvc5"},{"location":"api/solverpy/solver/smt/cvc5/#module-cvc5","text":"","title":"module cvc5"},{"location":"api/solverpy/solver/smt/z3/","text":"module z3","title":"\ud83e\udd16 z3"},{"location":"api/solverpy/solver/smt/z3/#module-z3","text":"","title":"module z3"},{"location":"api/solverpy/task/","text":"Task Overview","title":"\u2139\ufe0f Overview"},{"location":"api/solverpy/task/#task-overview","text":"","title":"Task Overview"},{"location":"api/solverpy/task/bar/","text":"module bar","title":"\ud83e\udd16 bar"},{"location":"api/solverpy/task/bar/#module-bar","text":"","title":"module bar"},{"location":"api/solverpy/task/launcher/","text":"module launcher launch ( tasks , cores = 4 , chunksize = 1 , taskdone = None , bar = None , desc = 'running' , ** others ) Launch tasks in parallel on multiple cores, communicate status over the queue, and show progress bar. :param tasks: list of task to be executed (instances of Task) :param cores: number of worker threads (Default value = 4) :param chunksize: chunksize for Pool.map_async (Default value = 1) :param taskdone: (Default value = None) :param bar: (Default value = None) :param desc: (Default value = \"running\") :param **others: Source code in src/solverpy/task/launcher.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 def launch ( tasks : list [ \"SolverTask\" ], cores : int = 4 , chunksize : int = 1 , taskdone : Any = None , bar : \"DefaultBar | None\" = None , desc : str = \"running\" , ** others : Any , ) -> Any : \"\"\"Launch `tasks` in parallel on multiple cores, communicate status over the queue, and show progress bar. :param tasks: list of task to be executed (instances of Task) :param cores: number of worker threads (Default value = 4) :param chunksize: chunksize for Pool.map_async (Default value = 1) :param taskdone: (Default value = None) :param bar: (Default value = None) :param desc: (Default value = \"running\") :param **others: \"\"\" del others # unused argument todo = len ( tasks ) pool = Pool ( cores ) m = Manager () queue = m . Queue () setqueue ( queue , tasks ) bar = bar or DefaultBar ( len ( tasks ), desc , miniters = 1 ) logger . debug ( f \"launching pool with { cores } workers for { todo } tasks\" ) try : runner = pool . map_async ( runtask , tasks , chunksize = chunksize ) while todo : status = queue . get ( WAIT ) # type: ignore bar . status ( status ) if taskdone : taskdone ( status ) todo -= 1 bar . close () logger . debug ( f \"all tasks done\" ) pool . close () pool . join () logger . debug ( f \"pool closed\" ) return runner . get ( WAIT ) except KeyboardInterrupt as e : bar . close () logger . debug ( \"pool terminated (keyboard interupt)\" ) pool . terminate () raise e run ( tasks , cores = 4 , chunksize = 1 ) Launch tasks in parallel on multiple cores and return results. :param tasks: list of task to be executed (instances of Task) :param cores: number of worker threads (Default value = 4) :param chunksize: chunksize for Pool.map_async (Default value = 1) Source code in src/solverpy/task/launcher.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 def run ( tasks : list [ \"Task\" ], cores : int = 4 , chunksize : int = 1 , ) -> Any : \"\"\"Launch `tasks` in parallel on multiple cores and return results. :param tasks: list of task to be executed (instances of Task) :param cores: number of worker threads (Default value = 4) :param chunksize: chunksize for Pool.map_async (Default value = 1) \"\"\" pool = Pool ( cores ) try : runner = pool . map_async ( runtask , tasks , chunksize = chunksize ) results = runner . get ( WAIT ) pool . close () pool . join () return results except ( Exception , KeyboardInterrupt ) as e : pool . terminate () raise e","title":"\ud83e\udd16 launcher"},{"location":"api/solverpy/task/launcher/#module-launcher","text":"","title":"module launcher"},{"location":"api/solverpy/task/launcher/#solverpy.task.launcher.launch","text":"Launch tasks in parallel on multiple cores, communicate status over the queue, and show progress bar. :param tasks: list of task to be executed (instances of Task) :param cores: number of worker threads (Default value = 4) :param chunksize: chunksize for Pool.map_async (Default value = 1) :param taskdone: (Default value = None) :param bar: (Default value = None) :param desc: (Default value = \"running\") :param **others: Source code in src/solverpy/task/launcher.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 def launch ( tasks : list [ \"SolverTask\" ], cores : int = 4 , chunksize : int = 1 , taskdone : Any = None , bar : \"DefaultBar | None\" = None , desc : str = \"running\" , ** others : Any , ) -> Any : \"\"\"Launch `tasks` in parallel on multiple cores, communicate status over the queue, and show progress bar. :param tasks: list of task to be executed (instances of Task) :param cores: number of worker threads (Default value = 4) :param chunksize: chunksize for Pool.map_async (Default value = 1) :param taskdone: (Default value = None) :param bar: (Default value = None) :param desc: (Default value = \"running\") :param **others: \"\"\" del others # unused argument todo = len ( tasks ) pool = Pool ( cores ) m = Manager () queue = m . Queue () setqueue ( queue , tasks ) bar = bar or DefaultBar ( len ( tasks ), desc , miniters = 1 ) logger . debug ( f \"launching pool with { cores } workers for { todo } tasks\" ) try : runner = pool . map_async ( runtask , tasks , chunksize = chunksize ) while todo : status = queue . get ( WAIT ) # type: ignore bar . status ( status ) if taskdone : taskdone ( status ) todo -= 1 bar . close () logger . debug ( f \"all tasks done\" ) pool . close () pool . join () logger . debug ( f \"pool closed\" ) return runner . get ( WAIT ) except KeyboardInterrupt as e : bar . close () logger . debug ( \"pool terminated (keyboard interupt)\" ) pool . terminate () raise e","title":"launch"},{"location":"api/solverpy/task/launcher/#solverpy.task.launcher.run","text":"Launch tasks in parallel on multiple cores and return results. :param tasks: list of task to be executed (instances of Task) :param cores: number of worker threads (Default value = 4) :param chunksize: chunksize for Pool.map_async (Default value = 1) Source code in src/solverpy/task/launcher.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 def run ( tasks : list [ \"Task\" ], cores : int = 4 , chunksize : int = 1 , ) -> Any : \"\"\"Launch `tasks` in parallel on multiple cores and return results. :param tasks: list of task to be executed (instances of Task) :param cores: number of worker threads (Default value = 4) :param chunksize: chunksize for Pool.map_async (Default value = 1) \"\"\" pool = Pool ( cores ) try : runner = pool . map_async ( runtask , tasks , chunksize = chunksize ) results = runner . get ( WAIT ) pool . close () pool . join () return results except ( Exception , KeyboardInterrupt ) as e : pool . terminate () raise e","title":"run"},{"location":"api/solverpy/task/shelltask/","text":"module shelltask","title":"\ud83e\udd16 shelltask"},{"location":"api/solverpy/task/shelltask/#module-shelltask","text":"","title":"module shelltask"},{"location":"api/solverpy/task/solvertask/","text":"module solvertask","title":"\ud83e\udd16 solvertask"},{"location":"api/solverpy/task/solvertask/#module-solvertask","text":"","title":"module solvertask"},{"location":"api/solverpy/task/task/","text":"module task Task A generic executable task/job. Represents a task that can be executed. The result can be returned or communicated over a queue. The abstract method run should run the task and return the result. Tasks are typically executed in different threads. Hence modification to the Task instance might not be visible to the main thread. Also the returned result should be as small as possible to limit inter-process communication. Alternatively, the communication queue can be used to send the result to the main thread. If the queue is set, the result is transformed to the status and this status is pushed onto the queue (see Task.runtask ). Status is also propagated to the progress bar using the status bar handler (see RunningBar.status ). DefaultBar ignores the status. RunningBar expects the status for failed tasks to be None, and non-None otherwise. SolvingBar expects True for solved tasks, False for unsolved, and None for failed tasks. Source code in src/solverpy/task/task.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 class Task : \"\"\"A generic executable task/job. Represents a task that can be executed. The result can be returned or communicated over a queue. The abstract method `run` should run the task and return the result. Tasks are typically executed in different threads. Hence modification to the Task instance might not be visible to the main thread. Also the returned result should be as small as possible to limit inter-process communication. Alternatively, the communication queue can be used to send the result to the main thread. If the queue is set, the result is transformed to the `status` and this status is pushed onto the queue (see `Task.runtask`). Status is also propagated to the progress bar using the `status` bar handler (see `RunningBar.status`). `DefaultBar` ignores the status. `RunningBar` expects the status for failed tasks to be None, and non-None otherwise. `SolvingBar` expects `True` for solved tasks, `False` for unsolved, and `None` for failed tasks. \"\"\" def __init__ ( self , queue : \"Queue[Any] | None\" = None , ): \"\"\"Init the task. :param queue: communication queue (optional) \"\"\" self . _queue = queue def run ( self ) -> Any : \"\"\"Run the task and return the result.\"\"\" raise NotImplementedError ( \"Task.run: abstract method not implemented.\" ) @property def queue ( self ): \"\"\"Get the queue.\"\"\" return self . _queue @queue . setter def queue ( self , q : \"Queue[Any]\" ): \"\"\"Set the queue. :param q: the queue \"\"\" self . _queue = q def status ( self , result : Any , ) -> Any : \"\"\"Translate the result to (typically smaller) status to send it over the queue.\" :param result: the result \"\"\" return ( result is not None ) @staticmethod def runtask ( task : \"Task\" ): \"\"\"Run the task andd announce the result over the queue. :param task: the task to be ran \"\"\" try : res = task . run () status = task . status ( res ) except Exception as e : import traceback logger . warning ( f \"Exception:: { e } \" ) logger . warning ( f \"Task:: { task } \" ) logger . warning ( f \"Error:: { traceback . format_exc () } \" ) status = None res = None except KeyboardInterrupt : return None if status is None : logger . debug ( f \"failed task: { task } \" ) if task . queue is not None : task . queue . put ( status ) return res queue property writable Get the queue. __init__ ( queue = None ) Init the task. :param queue: communication queue (optional) Source code in src/solverpy/task/task.py 33 34 35 36 37 38 39 40 41 42 def __init__ ( self , queue : \"Queue[Any] | None\" = None , ): \"\"\"Init the task. :param queue: communication queue (optional) \"\"\" self . _queue = queue run () Run the task and return the result. Source code in src/solverpy/task/task.py 44 45 46 def run ( self ) -> Any : \"\"\"Run the task and return the result.\"\"\" raise NotImplementedError ( \"Task.run: abstract method not implemented.\" ) runtask ( task ) staticmethod Run the task andd announce the result over the queue. :param task: the task to be ran Source code in src/solverpy/task/task.py 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 @staticmethod def runtask ( task : \"Task\" ): \"\"\"Run the task andd announce the result over the queue. :param task: the task to be ran \"\"\" try : res = task . run () status = task . status ( res ) except Exception as e : import traceback logger . warning ( f \"Exception:: { e } \" ) logger . warning ( f \"Task:: { task } \" ) logger . warning ( f \"Error:: { traceback . format_exc () } \" ) status = None res = None except KeyboardInterrupt : return None if status is None : logger . debug ( f \"failed task: { task } \" ) if task . queue is not None : task . queue . put ( status ) return res status ( result ) Translate the result to (typically smaller) status to send it over the queue.\" :param result: the result Source code in src/solverpy/task/task.py 62 63 64 65 66 67 68 69 70 71 72 def status ( self , result : Any , ) -> Any : \"\"\"Translate the result to (typically smaller) status to send it over the queue.\" :param result: the result \"\"\" return ( result is not None ) runtask ( task ) Run task and return the result. :param task: Source code in src/solverpy/task/task.py 100 101 102 103 104 105 106 def runtask ( task : Task ) -> Any : \"\"\"Run task and return the result. :param task: \"\"\" return task . runtask ( task ) setqueue ( queue , tasks ) Set the queue for a list of tasks. :param queue: the queue to set :param tasks: the tasks to update Source code in src/solverpy/task/task.py 109 110 111 112 113 114 115 116 117 def setqueue ( queue : \"Queue[Any]\" , tasks : Sequence [ Task ]) -> None : \"\"\"Set the queue for a list of tasks. :param queue: the queue to set :param tasks: the tasks to update \"\"\" for task in tasks : task . queue = queue","title":"\ud83e\udd16 task"},{"location":"api/solverpy/task/task/#module-task","text":"","title":"module task"},{"location":"api/solverpy/task/task/#solverpy.task.task.Task","text":"A generic executable task/job. Represents a task that can be executed. The result can be returned or communicated over a queue. The abstract method run should run the task and return the result. Tasks are typically executed in different threads. Hence modification to the Task instance might not be visible to the main thread. Also the returned result should be as small as possible to limit inter-process communication. Alternatively, the communication queue can be used to send the result to the main thread. If the queue is set, the result is transformed to the status and this status is pushed onto the queue (see Task.runtask ). Status is also propagated to the progress bar using the status bar handler (see RunningBar.status ). DefaultBar ignores the status. RunningBar expects the status for failed tasks to be None, and non-None otherwise. SolvingBar expects True for solved tasks, False for unsolved, and None for failed tasks. Source code in src/solverpy/task/task.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 class Task : \"\"\"A generic executable task/job. Represents a task that can be executed. The result can be returned or communicated over a queue. The abstract method `run` should run the task and return the result. Tasks are typically executed in different threads. Hence modification to the Task instance might not be visible to the main thread. Also the returned result should be as small as possible to limit inter-process communication. Alternatively, the communication queue can be used to send the result to the main thread. If the queue is set, the result is transformed to the `status` and this status is pushed onto the queue (see `Task.runtask`). Status is also propagated to the progress bar using the `status` bar handler (see `RunningBar.status`). `DefaultBar` ignores the status. `RunningBar` expects the status for failed tasks to be None, and non-None otherwise. `SolvingBar` expects `True` for solved tasks, `False` for unsolved, and `None` for failed tasks. \"\"\" def __init__ ( self , queue : \"Queue[Any] | None\" = None , ): \"\"\"Init the task. :param queue: communication queue (optional) \"\"\" self . _queue = queue def run ( self ) -> Any : \"\"\"Run the task and return the result.\"\"\" raise NotImplementedError ( \"Task.run: abstract method not implemented.\" ) @property def queue ( self ): \"\"\"Get the queue.\"\"\" return self . _queue @queue . setter def queue ( self , q : \"Queue[Any]\" ): \"\"\"Set the queue. :param q: the queue \"\"\" self . _queue = q def status ( self , result : Any , ) -> Any : \"\"\"Translate the result to (typically smaller) status to send it over the queue.\" :param result: the result \"\"\" return ( result is not None ) @staticmethod def runtask ( task : \"Task\" ): \"\"\"Run the task andd announce the result over the queue. :param task: the task to be ran \"\"\" try : res = task . run () status = task . status ( res ) except Exception as e : import traceback logger . warning ( f \"Exception:: { e } \" ) logger . warning ( f \"Task:: { task } \" ) logger . warning ( f \"Error:: { traceback . format_exc () } \" ) status = None res = None except KeyboardInterrupt : return None if status is None : logger . debug ( f \"failed task: { task } \" ) if task . queue is not None : task . queue . put ( status ) return res","title":"Task"},{"location":"api/solverpy/task/task/#solverpy.task.task.Task.queue","text":"Get the queue.","title":"queue"},{"location":"api/solverpy/task/task/#solverpy.task.task.Task.__init__","text":"Init the task. :param queue: communication queue (optional) Source code in src/solverpy/task/task.py 33 34 35 36 37 38 39 40 41 42 def __init__ ( self , queue : \"Queue[Any] | None\" = None , ): \"\"\"Init the task. :param queue: communication queue (optional) \"\"\" self . _queue = queue","title":"__init__"},{"location":"api/solverpy/task/task/#solverpy.task.task.Task.run","text":"Run the task and return the result. Source code in src/solverpy/task/task.py 44 45 46 def run ( self ) -> Any : \"\"\"Run the task and return the result.\"\"\" raise NotImplementedError ( \"Task.run: abstract method not implemented.\" )","title":"run"},{"location":"api/solverpy/task/task/#solverpy.task.task.Task.runtask","text":"Run the task andd announce the result over the queue. :param task: the task to be ran Source code in src/solverpy/task/task.py 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 @staticmethod def runtask ( task : \"Task\" ): \"\"\"Run the task andd announce the result over the queue. :param task: the task to be ran \"\"\" try : res = task . run () status = task . status ( res ) except Exception as e : import traceback logger . warning ( f \"Exception:: { e } \" ) logger . warning ( f \"Task:: { task } \" ) logger . warning ( f \"Error:: { traceback . format_exc () } \" ) status = None res = None except KeyboardInterrupt : return None if status is None : logger . debug ( f \"failed task: { task } \" ) if task . queue is not None : task . queue . put ( status ) return res","title":"runtask"},{"location":"api/solverpy/task/task/#solverpy.task.task.Task.status","text":"Translate the result to (typically smaller) status to send it over the queue.\" :param result: the result Source code in src/solverpy/task/task.py 62 63 64 65 66 67 68 69 70 71 72 def status ( self , result : Any , ) -> Any : \"\"\"Translate the result to (typically smaller) status to send it over the queue.\" :param result: the result \"\"\" return ( result is not None )","title":"status"},{"location":"api/solverpy/task/task/#solverpy.task.task.runtask","text":"Run task and return the result. :param task: Source code in src/solverpy/task/task.py 100 101 102 103 104 105 106 def runtask ( task : Task ) -> Any : \"\"\"Run task and return the result. :param task: \"\"\" return task . runtask ( task )","title":"runtask"},{"location":"api/solverpy/task/task/#solverpy.task.task.setqueue","text":"Set the queue for a list of tasks. :param queue: the queue to set :param tasks: the tasks to update Source code in src/solverpy/task/task.py 109 110 111 112 113 114 115 116 117 def setqueue ( queue : \"Queue[Any]\" , tasks : Sequence [ Task ]) -> None : \"\"\"Set the queue for a list of tasks. :param queue: the queue to set :param tasks: the tasks to update \"\"\" for task in tasks : task . queue = queue","title":"setqueue"},{"location":"api/solverpy/tools/","text":"Tools Overview","title":"\u2139\ufe0f Overview"},{"location":"api/solverpy/tools/#tools-overview","text":"","title":"Tools Overview"},{"location":"api/solverpy/tools/external/","text":"module external external ( func ) Decorator that runs a function in a separate process. Source code in src/solverpy/tools/external.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 def external ( func : Callable ) -> Callable : \"\"\" Decorator that runs a function in a separate process. \"\"\" @wraps ( func ) def wrapper ( * args , ** kwargs ): queue = multiprocessing . Queue () def target (): try : result = func ( * args , ** kwargs ) queue . put (( True , result )) except Exception as e : queue . put (( False , e )) process = multiprocessing . Process ( target = target ) process . start () process . join () if process . exitcode != 0 : raise RuntimeError ( f \"Process failed with exit code { process . exitcode } \" ) ( success , data ) = queue . get () if success : return data else : raise data return wrapper","title":"\ud83e\udd16 external"},{"location":"api/solverpy/tools/external/#module-external","text":"","title":"module external"},{"location":"api/solverpy/tools/external/#solverpy.tools.external.external","text":"Decorator that runs a function in a separate process. Source code in src/solverpy/tools/external.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 def external ( func : Callable ) -> Callable : \"\"\" Decorator that runs a function in a separate process. \"\"\" @wraps ( func ) def wrapper ( * args , ** kwargs ): queue = multiprocessing . Queue () def target (): try : result = func ( * args , ** kwargs ) queue . put (( True , result )) except Exception as e : queue . put (( False , e )) process = multiprocessing . Process ( target = target ) process . start () process . join () if process . exitcode != 0 : raise RuntimeError ( f \"Process failed with exit code { process . exitcode } \" ) ( success , data ) = queue . get () if success : return data else : raise data return wrapper","title":"external"},{"location":"api/solverpy/tools/human/","text":"module human","title":"\ud83e\udd16 human"},{"location":"api/solverpy/tools/human/#module-human","text":"","title":"module human"},{"location":"api/solverpy/tools/log/","text":"module log","title":"\ud83e\udd16 log"},{"location":"api/solverpy/tools/log/#module-log","text":"","title":"module log"},{"location":"api/solverpy/tools/patterns/","text":"module patterns","title":"\ud83e\udd16 patterns"},{"location":"api/solverpy/tools/patterns/#module-patterns","text":"","title":"module patterns"},{"location":"api/solverpy/tools/redirect/","text":"module redirect","title":"\ud83e\udd16 redirect"},{"location":"api/solverpy/tools/redirect/#module-redirect","text":"","title":"module redirect"},{"location":"api/solverpy/tools/timeme/","text":"module timeme","title":"\ud83e\udd16 timeme"},{"location":"api/solverpy/tools/timeme/#module-timeme","text":"","title":"module timeme"},{"location":"api/solverpy/tools/typing/","text":"module typing","title":"\ud83e\udd16 typing"},{"location":"api/solverpy/tools/typing/#module-typing","text":"","title":"module typing"}]}
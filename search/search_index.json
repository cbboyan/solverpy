{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Python Interface for Automated Solvers SolverPy provides a uniform Python interface for several automated ATP and SMT solvers. Currently supported solvers are E , Vampire , Prover9 , Lash , cvc5 , Z3 , and Bitwuzla . The interface can be used for: \ud83d\udca1 Solving a single problem instance with compatible results. \ud83d\udd27 Benchmark parallel evaluation with database storage. \ud83e\udde0 Machine learning of models and strategies for solver guidance. Installation Install the Python package using pip : $ pip install solverpy Or clone our GitHub repository : $ git clone https://github.com/cbboyan/solverpy.git \ud83d\uddd2\ufe0f Note : The solver binaries/libraries are not part of this Python package and must be installed separately. The binaries must be (by default) in PATH or specified using binary parameter in Setup , if you wish to use them from solverpy . Overview \ud83d\udca1 Single problem solving Single problem solving involves creating a solver object and calling its solve method. from solverpy.solver.smt.cvc5 import Cvc5 cvc5 = Cvc5 ( \"T5\" ) # time limit of 5 seconds result = cvc5 . solve ( \"myproblem.smt2\" , \"--enum-inst\" ) # problem and strategy Strategies are solver-specific, typically command line options as a string. \u2615 The result is a dictionary guaranteed to contain at least two keys: status as a string and runtime in seconds, apart from solver-specific keys. \ud83d\ude0e For more details, see the solver module. \ud83d\udd27 Benchmark evaluation SolverPy provides dataclass Setup that describes the evaluation configuration. It auromatically connects to database DB to store results, by default, using the Jsons provider. To evaluate a set of strategies on a set of benchmark problems, you just need to provide your experiment description as a Python dict . \ud83d\udca1 Use typed version Setup to avoid typos and type errors. Functions from the setups module are used to fill in the required keys and values. To run the evaluation you setup a solver for an evaluation, then launch it. \ud83e\udd1e Before launching the evaluation, you need to setup the SolverPy database by creating directories solverpy_db/strats in the current directory. This directory stores the strategy files. For the above example, there should be an empty file solverpy_db/strats/default (default cvc5 strategy). The problem files should be in problems/ directory. from solverpy import setups mysetup = setups . Setup ( cores = 4 , bidlist = [ \"problems\" ], sidlist = [ \"default\" ], limit = 'T10' , ) setups . cvc5 ( mysetup ) setups . evaluation ( mysetup ) setups . launch ( mysetup ) \u2615 After the evaluation, you can inspect the results in the database directory solverpy_db/results . \ud83d\ude0e For more details, see the benchmark module. \ud83e\udde0 Machine learning Similarly, you can use the enigma and cvc5ml from setups module. to setup several loops of interleaved evaluation and model training. \ud83d\ude0e For more details, see the builder module.","title":"Home"},{"location":"#python-interface-for-automated-solvers","text":"SolverPy provides a uniform Python interface for several automated ATP and SMT solvers. Currently supported solvers are E , Vampire , Prover9 , Lash , cvc5 , Z3 , and Bitwuzla . The interface can be used for: \ud83d\udca1 Solving a single problem instance with compatible results. \ud83d\udd27 Benchmark parallel evaluation with database storage. \ud83e\udde0 Machine learning of models and strategies for solver guidance.","title":"Python Interface for Automated Solvers"},{"location":"#installation","text":"Install the Python package using pip : $ pip install solverpy Or clone our GitHub repository : $ git clone https://github.com/cbboyan/solverpy.git \ud83d\uddd2\ufe0f Note : The solver binaries/libraries are not part of this Python package and must be installed separately. The binaries must be (by default) in PATH or specified using binary parameter in Setup , if you wish to use them from solverpy .","title":"Installation"},{"location":"#overview","text":"","title":"Overview"},{"location":"#single-problem-solving","text":"Single problem solving involves creating a solver object and calling its solve method. from solverpy.solver.smt.cvc5 import Cvc5 cvc5 = Cvc5 ( \"T5\" ) # time limit of 5 seconds result = cvc5 . solve ( \"myproblem.smt2\" , \"--enum-inst\" ) # problem and strategy Strategies are solver-specific, typically command line options as a string. \u2615 The result is a dictionary guaranteed to contain at least two keys: status as a string and runtime in seconds, apart from solver-specific keys. \ud83d\ude0e For more details, see the solver module.","title":"\ud83d\udca1 Single problem solving"},{"location":"#benchmark-evaluation","text":"SolverPy provides dataclass Setup that describes the evaluation configuration. It auromatically connects to database DB to store results, by default, using the Jsons provider. To evaluate a set of strategies on a set of benchmark problems, you just need to provide your experiment description as a Python dict . \ud83d\udca1 Use typed version Setup to avoid typos and type errors. Functions from the setups module are used to fill in the required keys and values. To run the evaluation you setup a solver for an evaluation, then launch it. \ud83e\udd1e Before launching the evaluation, you need to setup the SolverPy database by creating directories solverpy_db/strats in the current directory. This directory stores the strategy files. For the above example, there should be an empty file solverpy_db/strats/default (default cvc5 strategy). The problem files should be in problems/ directory. from solverpy import setups mysetup = setups . Setup ( cores = 4 , bidlist = [ \"problems\" ], sidlist = [ \"default\" ], limit = 'T10' , ) setups . cvc5 ( mysetup ) setups . evaluation ( mysetup ) setups . launch ( mysetup ) \u2615 After the evaluation, you can inspect the results in the database directory solverpy_db/results . \ud83d\ude0e For more details, see the benchmark module.","title":"\ud83d\udd27 Benchmark evaluation"},{"location":"#machine-learning","text":"Similarly, you can use the enigma and cvc5ml from setups module. to setup several loops of interleaved evaluation and model training. \ud83d\ude0e For more details, see the builder module.","title":"\ud83e\udde0 Machine learning"},{"location":"markdown/","text":"\ud83d\udee0\ufe0f Unicode Symbols for Markdown Documentation \u2139\ufe0f Info Symbol Unicode Meaning Usage Example \u2139\ufe0f U+2139 Information \u2139\ufe0f Use with caution in debug mode. \ud83d\udec8 U+1F6C8 Alternative info symbol \ud83d\udec8 API is subject to change. \ud83d\udcd8 U+1F4D8 Reference/Blue book \ud83d\udcd8 See section 4.2 of the guide. \ud83e\uddfe U+1F9FE Documentation/Receipt \ud83e\uddfe Generated logs are saved to /var/log. \ud83e\udde0 U+1F9E0 Insight/Brain \ud83e\udde0 This technique boosts performance. \ud83d\udcdd Note Symbol Unicode Meaning Usage Example \ud83d\udcdd U+1F4DD Memo/Note \ud83d\udcdd This method is deprecated. \ud83d\uddd2\ufe0f U+1F5D2 Notepad \ud83d\uddd2\ufe0f Make sure to configure both fields. \ud83d\udccc U+1F4CC Pinned Note \ud83d\udccc This setting is environment-specific. \ud83d\udcce U+1F4CE Paperclip/Attached \ud83d\udcce Attached are the config templates. \ud83e\uddd0 U+1F9D0 Observational Note \ud83e\uddd0 Rare edge case: input may be null. \ud83d\udca1 Hint / Tip Symbol Unicode Meaning Usage Example \ud83d\udca1 U+1F4A1 Lightbulb \ud83d\udca1 Try caching the results for speed. \ud83d\udd0d U+1F50D Insight/Search \ud83d\udd0d You can filter logs by severity. \ud83e\udde0 U+1F9E0 Brain/Insight \ud83e\udde0 Consider using memoization here. \ud83d\udd27 U+1F527 Tool/Fix tip \ud83d\udd27 Use the --fix flag to auto-correct. \u26a0\ufe0f Warning Symbol Unicode Meaning Usage Example \u26a0\ufe0f U+26A0 Warning \u26a0\ufe0f Do not delete system files. \u2757 U+2757 Important/Alert \u2757 Backup your data before proceeding. \u2755 U+2755 Light Warning \u2755 This may cause a minor delay. \ud83d\udea7 U+1F6A7 Construction/Partial \ud83d\udea7 Feature under development. \u274c Error / Danger Symbol Unicode Meaning Usage Example \u274c U+274C Error \u274c Invalid configuration file. \ud83d\udd25 U+1F525 Hot Issue \ud83d\udd25 Major performance hit detected. \ud83d\uded1 U+1F6D1 Stop/Critical \ud83d\uded1 Service will shut down immediately. \u2705 Success / Done Symbol Unicode Meaning Usage Example \u2705 U+2705 Success/Passed \u2705 All unit tests passed. \u2611\ufe0f U+2611 Checkbox \u2611\ufe0f Enabled via config. \ud83c\udf89 U+1F389 Celebration \ud83c\udf89 Initial setup complete!","title":"Markdown"},{"location":"options/","text":"SolverPy Options An option is identified by its string name, and represents a boolean yes/no value. Put the option name into the string list under the key \"options\" in the setup. Use no- option, like no-compress , to set the option to no option description default outputs Keep raw solver output files from all runs no compress Compress output files (outputs, trains, results). yes flatten Put all output files in a single directory (replace / with _._ ). yes compress-trains Compress trains. yes debug-trains Dump training data for each file separately. no","title":"Options"},{"location":"options/#solverpy-options","text":"An option is identified by its string name, and represents a boolean yes/no value. Put the option name into the string list under the key \"options\" in the setup. Use no- option, like no-compress , to set the option to no option description default outputs Keep raw solver output files from all runs no compress Compress output files (outputs, trains, results). yes flatten Put all output files in a single directory (replace / with _._ ). yes compress-trains Compress trains. yes debug-trains Dump training data for each file separately. no","title":"SolverPy Options"},{"location":"test/","text":"PlantUML Test ![file](diagrams/out/overview.svg)","title":"Test"},{"location":"test/#plantuml-test","text":"![file](diagrams/out/overview.svg)","title":"PlantUML Test"},{"location":"tutorial/","text":"Python Interface for Automated Solvers SolverPy provides a uniform Python interface for several automated ATP and SMT solvers. Currently supported solvers are E , Vampire , Prover9 , Lash , cvc5 , Z3 , and Bitwuzla . The interface can be used for: \ud83d\udca1 Solving a single problem instance with compatible results. \ud83d\udd27 Benchmark parallel evaluation with database storage. \ud83e\udde0 Machine learning of models and strategies for solver guidance. Installation Install the Python package using pip : $ pip install solverpy Or clone our GitHub repository : $ git clone https://github.com/cbboyan/solverpy.git \ud83d\uddd2\ufe0f Note : The solver binaries/libraries are not part of this Python package and must be installed separately. The binaries must be (by default) in PATH or specified using binary parameter in Setup , if you wish to use them from solverpy . Overview \ud83d\udca1 Single problem solving Single problem solving involves creating a solver object and calling its solve method. from solverpy.solver.smt.cvc5 import Cvc5 cvc5 = Cvc5 ( \"T5\" ) # time limit of 5 seconds result = cvc5 . solve ( \"myproblem.smt2\" , \"--enum-inst\" ) # problem and strategy Strategies are solver-specific, typically command line options as a string. \u2615 The result is a dictionary guaranteed to contain at least two keys: status as a string and runtime in seconds, apart from solver-specific keys. \ud83d\udd27 Benchmark evaluation SolverPy provides dataclass Setup that describes the evaluation configuration. It auromatically connects to database DB to store results, by default, using the Jsons provider. To evaluate a set of strategies on a set of benchmark problems, you just need to provide your experiment description as a Python dict . \ud83d\udca1 Use typed version Setup to avoid typos and type errors. Functions from the setups module are used to fill in the required keys and values. To run the evaluation you setup a solver for an evaluation, then launch it. from solverpy import setups mysetup = setups . Setup ( cores = 4 , bidlist = [ 'problems' ], sidlist = [ \"default\" ], limit = 'T10' , ) setups . cvc5 ( mysetup ) setups . evaluation ( mysetup ) mysetup . launch () \ud83e\udd1e Before launching the evaluation, you need to setup the SolverPy database by creating directories solverpy_db/strats in the current directory. This directory stores the strategy files. For the above example, there should be an empty file solverpy_db/strats/default (default cvc5 strategy). The problem files should be in problems/ directory. \u2615 After the evaluation, you can inspect the results in the database directory solverpy_db/results . \ud83e\udde0 Machine learning Single problem solving To call the solver on one problem instance, start by creating the solver object. from solverpy.solver.smt.cvc5 import Cvc5 cvc5 = Cvc5 ( \"T5\" ) # time limit of 5 seconds The constructor argument is a resource limit string, in this case, a time limit T in seconds. All solvers support T and additional resource limits might be available depending on the solver. Multiple resource limits can be used (separated by - , like T10-R50000 ). The limit string must, however, always start with T . Then call the solve method: result = cvc5 . solve ( \"myproblem.smt2\" , \"--enum-inst\" ) The first argument is the problem filename, the second is the solver-dependent strategy description (typically command line options as a string). The result is a Python dict with results and statistics. The keys and values are solver-specific. Nevertheless, the result always contains keys status (with the value of type str ) and runtime (type float ). \ud83d\udca1 Call cvc5.run(p,s) instead of cvc5.solve(p,s) to get the raw solver output without any processing. \ud83d\udca1 Call cvc5.command(p,s) to output the shell command that is going to be executed to launch the solver. Parallel benchmark evaluation To evaluate a set of strategies on a set of benchmark problems, you just need to provide your experiment description as a Python dict and launch the experiments. from solverpy.benchmark import setups mysetup = ... setups . launch ( mysetup ) The experiment setup ( mysetup ) must have specific keys. The module solverpy.benchmark.setups contains methods to fill in the required keys and values. You must specify at least the following: key type description cores int number of CPU cores to use for parallel evaluation sidlist [str] list of strategies to evaluate bidlist [str] list of problems to evaluate on limit str the resource limit for a single solver run Strategies and strategy id's Strategies are stored in files in the directory solverpy_db/strats which must exist in the current working directory (the directory is adjustable by the SOLVERPY_DB environment variable). The filename of each strategy is used to reference the strategy in sidlist and it is called the strategy id ( sid ). Hence, for every sid in sidlist in mysetup , there must be the file solverpy_db/strats/sid in the current working directory. This file contains the strategy definition (typically command line options) to pass to the solver.solve method. Problems and benchmark id's Benchmark problem sets are represented by benchark id's ( bid ). The benchmark id is a file path relative to the current working directory (adjustable by the SOLVERPY_BENCHMARKS environment variable) pointing either to a file or to a directory. If the path leads to a: directory : Then every regular file directly in this directory is considered a benchmark problem. Directories and hidden files are ignored and no recursive search is performed. This variant is useful when you have a set of problem files, all in one directory. file : Then the file consists of lines containing paths to corresponding problem files. The paths are relative to the directory of the bid file. For example, if the bid is myproblems/subset1 and this file contains (among others) the line category1/problem23.smt2 then the problem must be placed in myproblems/category1/problem23.smt2 (because the directory of the bid file is myproblems ). This variant is useful when your benchmarks are structured in subdirectories and you don't want to merge them into one directory. Experiments example Suppose you have some SMT problems in the directory myproblems and that you want to evaluate your cvc5 strategies buzzard , sparrow , and chickadee , which you have placed in the directory solverpy_db/strats . You can download the archive with files for this example here . You proceed as follows. First, you create the description of your experiments in mysetup . from solverpy.benchmark import setups mysetup = { \"cores\" : 4 , \"limit\" : \"T10\" , \"bidlist\" : [ \"myproblems\" ], \"sidlist\" : [ \"buzzard\" , \"sparrow\" , \"chickadee\" ], } Hint: Add mysetup[\"options\"] = [\"outputs\"] if you want to keep raw solver output files from all solver runs. Hint: Options are slightly more described here . Then you specify that you want to use cvc5 and that you wish to launch an evaluation. These methods update mysetup and fill in some keys required by setups.launch() . setups . cvc5 ( mysetup ) setups . evaluation ( mysetup ) Finally, you launch the experiments. setups . launch ( mysetup ) You will see the progress of the experiments on the screen. Once finished, you will find the following subdirectories inside solverpy_db : directory content results Results by each strategy ( sid ) for each bid . The result for each sid and bid is a JSON file (gzip-ed) with a Python dictionary {problem: result} . solved List of solved problem names by each strategy for each bid . One per line, easy to grep and cat . status Statuses of all problems by each strategy for each bid . Problem name and status at one line, TAB separated. Easy to cut . log Console log for each solverpy experiment run. outputs Raw solver output files for each solver run (only if selected). Now run the script again and notice that it finished much faster. It is because the cached results were reused and no solvers were actually launched. So be careful and always clean the database if you want to force recompute. Simply delete all the directories in solverpy_db except strats (see the script clean_db.sh in the example archive ).","title":"Tutorial"},{"location":"tutorial/#python-interface-for-automated-solvers","text":"SolverPy provides a uniform Python interface for several automated ATP and SMT solvers. Currently supported solvers are E , Vampire , Prover9 , Lash , cvc5 , Z3 , and Bitwuzla . The interface can be used for: \ud83d\udca1 Solving a single problem instance with compatible results. \ud83d\udd27 Benchmark parallel evaluation with database storage. \ud83e\udde0 Machine learning of models and strategies for solver guidance.","title":"Python Interface for Automated Solvers"},{"location":"tutorial/#installation","text":"Install the Python package using pip : $ pip install solverpy Or clone our GitHub repository : $ git clone https://github.com/cbboyan/solverpy.git \ud83d\uddd2\ufe0f Note : The solver binaries/libraries are not part of this Python package and must be installed separately. The binaries must be (by default) in PATH or specified using binary parameter in Setup , if you wish to use them from solverpy .","title":"Installation"},{"location":"tutorial/#overview","text":"","title":"Overview"},{"location":"tutorial/#single-problem-solving","text":"Single problem solving involves creating a solver object and calling its solve method. from solverpy.solver.smt.cvc5 import Cvc5 cvc5 = Cvc5 ( \"T5\" ) # time limit of 5 seconds result = cvc5 . solve ( \"myproblem.smt2\" , \"--enum-inst\" ) # problem and strategy Strategies are solver-specific, typically command line options as a string. \u2615 The result is a dictionary guaranteed to contain at least two keys: status as a string and runtime in seconds, apart from solver-specific keys.","title":"\ud83d\udca1 Single problem solving"},{"location":"tutorial/#benchmark-evaluation","text":"SolverPy provides dataclass Setup that describes the evaluation configuration. It auromatically connects to database DB to store results, by default, using the Jsons provider. To evaluate a set of strategies on a set of benchmark problems, you just need to provide your experiment description as a Python dict . \ud83d\udca1 Use typed version Setup to avoid typos and type errors. Functions from the setups module are used to fill in the required keys and values. To run the evaluation you setup a solver for an evaluation, then launch it. from solverpy import setups mysetup = setups . Setup ( cores = 4 , bidlist = [ 'problems' ], sidlist = [ \"default\" ], limit = 'T10' , ) setups . cvc5 ( mysetup ) setups . evaluation ( mysetup ) mysetup . launch () \ud83e\udd1e Before launching the evaluation, you need to setup the SolverPy database by creating directories solverpy_db/strats in the current directory. This directory stores the strategy files. For the above example, there should be an empty file solverpy_db/strats/default (default cvc5 strategy). The problem files should be in problems/ directory. \u2615 After the evaluation, you can inspect the results in the database directory solverpy_db/results .","title":"\ud83d\udd27 Benchmark evaluation"},{"location":"tutorial/#machine-learning","text":"","title":"\ud83e\udde0 Machine learning"},{"location":"tutorial/#single-problem-solving_1","text":"To call the solver on one problem instance, start by creating the solver object. from solverpy.solver.smt.cvc5 import Cvc5 cvc5 = Cvc5 ( \"T5\" ) # time limit of 5 seconds The constructor argument is a resource limit string, in this case, a time limit T in seconds. All solvers support T and additional resource limits might be available depending on the solver. Multiple resource limits can be used (separated by - , like T10-R50000 ). The limit string must, however, always start with T . Then call the solve method: result = cvc5 . solve ( \"myproblem.smt2\" , \"--enum-inst\" ) The first argument is the problem filename, the second is the solver-dependent strategy description (typically command line options as a string). The result is a Python dict with results and statistics. The keys and values are solver-specific. Nevertheless, the result always contains keys status (with the value of type str ) and runtime (type float ). \ud83d\udca1 Call cvc5.run(p,s) instead of cvc5.solve(p,s) to get the raw solver output without any processing. \ud83d\udca1 Call cvc5.command(p,s) to output the shell command that is going to be executed to launch the solver.","title":"Single problem solving"},{"location":"tutorial/#parallel-benchmark-evaluation","text":"To evaluate a set of strategies on a set of benchmark problems, you just need to provide your experiment description as a Python dict and launch the experiments. from solverpy.benchmark import setups mysetup = ... setups . launch ( mysetup ) The experiment setup ( mysetup ) must have specific keys. The module solverpy.benchmark.setups contains methods to fill in the required keys and values. You must specify at least the following: key type description cores int number of CPU cores to use for parallel evaluation sidlist [str] list of strategies to evaluate bidlist [str] list of problems to evaluate on limit str the resource limit for a single solver run","title":"Parallel benchmark evaluation"},{"location":"tutorial/#strategies-and-strategy-ids","text":"Strategies are stored in files in the directory solverpy_db/strats which must exist in the current working directory (the directory is adjustable by the SOLVERPY_DB environment variable). The filename of each strategy is used to reference the strategy in sidlist and it is called the strategy id ( sid ). Hence, for every sid in sidlist in mysetup , there must be the file solverpy_db/strats/sid in the current working directory. This file contains the strategy definition (typically command line options) to pass to the solver.solve method.","title":"Strategies and strategy id's"},{"location":"tutorial/#problems-and-benchmark-ids","text":"Benchmark problem sets are represented by benchark id's ( bid ). The benchmark id is a file path relative to the current working directory (adjustable by the SOLVERPY_BENCHMARKS environment variable) pointing either to a file or to a directory. If the path leads to a: directory : Then every regular file directly in this directory is considered a benchmark problem. Directories and hidden files are ignored and no recursive search is performed. This variant is useful when you have a set of problem files, all in one directory. file : Then the file consists of lines containing paths to corresponding problem files. The paths are relative to the directory of the bid file. For example, if the bid is myproblems/subset1 and this file contains (among others) the line category1/problem23.smt2 then the problem must be placed in myproblems/category1/problem23.smt2 (because the directory of the bid file is myproblems ). This variant is useful when your benchmarks are structured in subdirectories and you don't want to merge them into one directory.","title":"Problems and benchmark id's"},{"location":"tutorial/#experiments-example","text":"Suppose you have some SMT problems in the directory myproblems and that you want to evaluate your cvc5 strategies buzzard , sparrow , and chickadee , which you have placed in the directory solverpy_db/strats . You can download the archive with files for this example here . You proceed as follows. First, you create the description of your experiments in mysetup . from solverpy.benchmark import setups mysetup = { \"cores\" : 4 , \"limit\" : \"T10\" , \"bidlist\" : [ \"myproblems\" ], \"sidlist\" : [ \"buzzard\" , \"sparrow\" , \"chickadee\" ], } Hint: Add mysetup[\"options\"] = [\"outputs\"] if you want to keep raw solver output files from all solver runs. Hint: Options are slightly more described here . Then you specify that you want to use cvc5 and that you wish to launch an evaluation. These methods update mysetup and fill in some keys required by setups.launch() . setups . cvc5 ( mysetup ) setups . evaluation ( mysetup ) Finally, you launch the experiments. setups . launch ( mysetup ) You will see the progress of the experiments on the screen. Once finished, you will find the following subdirectories inside solverpy_db : directory content results Results by each strategy ( sid ) for each bid . The result for each sid and bid is a JSON file (gzip-ed) with a Python dictionary {problem: result} . solved List of solved problem names by each strategy for each bid . One per line, easy to grep and cat . status Statuses of all problems by each strategy for each bid . Problem name and status at one line, TAB separated. Easy to cut . log Console log for each solverpy experiment run. outputs Raw solver output files for each solver run (only if selected). Now run the script again and notice that it finished much faster. It is because the cached results were reused and no solvers were actually launched. So be careful and always clean the database if you want to force recompute. Simply delete all the directories in solverpy_db except strats (see the script clean_db.sh in the example archive ).","title":"Experiments example"},{"location":"api/solverpy/","text":"Solverpy Overview solverpy The basic concepts include: solver plugin strategy benchmarks result database provider SolverTask builder","title":"\u2139\ufe0f Overview"},{"location":"api/solverpy/#solverpy-overview","text":"","title":"Solverpy Overview"},{"location":"api/solverpy/#solverpy","text":"The basic concepts include: solver plugin strategy benchmarks result database provider SolverTask builder","title":"solverpy"},{"location":"api/solverpy/benchmark/","text":"Benchmark Overview solverpy.benchmark Parallel benchmark evaluation To evaluate a set of strategies on a set of benchmark problems, you just need to provide your experiment description as a Python dict and launch the experiments. from solverpy import setups mysetup = ... setups . launch ( mysetup ) The experiment setup ( mysetup ) must have specific keys. The module solverpy.benchmark.setups contains methods to fill in the required keys and values. You must specify at least the following: key type description cores int number of CPU cores to use for parallel evaluation sidlist [str] list of strategies to evaluate bidlist [str] list of problems to evaluate on limit str the resource limit for a single solver run Strategies and strategy id's Strategies are stored in files in the directory solverpy_db/strats which must exist in the current working directory (the directory is adjustable by the SOLVERPY_DB environment variable). The filename of each strategy is used to reference the strategy in sidlist and it is called the strategy id ( sid ). Hence, for every sid in sidlist in mysetup , there must be the file solverpy_db/strats/sid in the current working directory. This file contains the strategy definition (typically command line options) to pass to the solver.solve method. Problems and benchmark id's Benchmark problem sets are represented by benchark id's ( bid ). The benchmark id is a file path relative to the current working directory (adjustable by the SOLVERPY_BENCHMARKS environment variable) pointing either to a file or to a directory. If the path leads to a: directory : Then every regular file directly in this directory is considered a benchmark problem. Directories and hidden files are ignored and no recursive search is performed. This variant is useful when you have a set of problem files, all in one directory. file : Then the file consists of lines containing paths to corresponding problem files. The paths are relative to the directory of the bid file. For example, if the bid is my/problems/subset1 and this file contains (among others) the line category1/problem23.smt2 then the problem must be placed in my/problems/category1/problem23.smt2 (because the directory of the bid file is my/problems ). This variant is useful when your benchmarks are structured in subdirectories and you don't want to merge them into one directory. Experiments example Suppose you have some SMT problems in the directory myproblems and that you want to evaluate your cvc5 strategies buzzard , sparrow , and chickadee , which you have placed in the directory solverpy_db/strats . You can download the archive with files for this example here . You proceed as follows. First, you create the description of your experiments in mysetup . from solverpy import setups mysetup = { \"cores\" : 4 , \"limit\" : \"T10\" , \"bidlist\" : [ \"myproblems\" ], \"sidlist\" : [ \"buzzard\" , \"sparrow\" , \"chickadee\" ], } Hint: Add mysetup[\"options\"] = [\"outputs\"] if you want to keep raw solver output files from all solver runs. Hint: Options are slightly more described in Setup Then you specify that you want to use cvc5 and that you wish to launch an evaluation. These methods update mysetup and fill in some keys required by setups.launch() . setups . cvc5 ( mysetup ) setups . evaluation ( mysetup ) Finally, you launch the experiments. setups . launch ( mysetup ) You will see the progress of the experiments on the screen. Once finished, you will find the following subdirectories inside solverpy_db : directory content results Results by each strategy ( sid ) for each bid . The result for each sid and bid is a JSON file (gzip-ed) with a Python dictionary {problem: result} . solved List of solved problem names by each strategy for each bid . One per line, easy to grep and cat . status Statuses of all problems by each strategy for each bid . Problem name and status at one line, TAB separated. Easy to cut . log Console log for each solverpy experiment run. outputs Raw solver output files for each solver run (only if selected). Now run the script again and notice that it finished much faster. It is because the cached results were reused and no solvers were actually launched. So be careful and always clean the database if you want to force recompute. Simply delete all the directories in solverpy_db except strats (see the script clean_db.sh in the example archive ).","title":"\u2139\ufe0f Overview"},{"location":"api/solverpy/benchmark/#benchmark-overview","text":"","title":"Benchmark Overview"},{"location":"api/solverpy/benchmark/#solverpy.benchmark","text":"","title":"benchmark"},{"location":"api/solverpy/benchmark/#solverpy.benchmark--parallel-benchmark-evaluation","text":"To evaluate a set of strategies on a set of benchmark problems, you just need to provide your experiment description as a Python dict and launch the experiments. from solverpy import setups mysetup = ... setups . launch ( mysetup ) The experiment setup ( mysetup ) must have specific keys. The module solverpy.benchmark.setups contains methods to fill in the required keys and values. You must specify at least the following: key type description cores int number of CPU cores to use for parallel evaluation sidlist [str] list of strategies to evaluate bidlist [str] list of problems to evaluate on limit str the resource limit for a single solver run","title":"Parallel benchmark evaluation"},{"location":"api/solverpy/benchmark/#solverpy.benchmark--strategies-and-strategy-ids","text":"Strategies are stored in files in the directory solverpy_db/strats which must exist in the current working directory (the directory is adjustable by the SOLVERPY_DB environment variable). The filename of each strategy is used to reference the strategy in sidlist and it is called the strategy id ( sid ). Hence, for every sid in sidlist in mysetup , there must be the file solverpy_db/strats/sid in the current working directory. This file contains the strategy definition (typically command line options) to pass to the solver.solve method.","title":"Strategies and strategy id's"},{"location":"api/solverpy/benchmark/#solverpy.benchmark--problems-and-benchmark-ids","text":"Benchmark problem sets are represented by benchark id's ( bid ). The benchmark id is a file path relative to the current working directory (adjustable by the SOLVERPY_BENCHMARKS environment variable) pointing either to a file or to a directory. If the path leads to a: directory : Then every regular file directly in this directory is considered a benchmark problem. Directories and hidden files are ignored and no recursive search is performed. This variant is useful when you have a set of problem files, all in one directory. file : Then the file consists of lines containing paths to corresponding problem files. The paths are relative to the directory of the bid file. For example, if the bid is my/problems/subset1 and this file contains (among others) the line category1/problem23.smt2 then the problem must be placed in my/problems/category1/problem23.smt2 (because the directory of the bid file is my/problems ). This variant is useful when your benchmarks are structured in subdirectories and you don't want to merge them into one directory.","title":"Problems and benchmark id's"},{"location":"api/solverpy/benchmark/#solverpy.benchmark--experiments-example","text":"Suppose you have some SMT problems in the directory myproblems and that you want to evaluate your cvc5 strategies buzzard , sparrow , and chickadee , which you have placed in the directory solverpy_db/strats . You can download the archive with files for this example here . You proceed as follows. First, you create the description of your experiments in mysetup . from solverpy import setups mysetup = { \"cores\" : 4 , \"limit\" : \"T10\" , \"bidlist\" : [ \"myproblems\" ], \"sidlist\" : [ \"buzzard\" , \"sparrow\" , \"chickadee\" ], } Hint: Add mysetup[\"options\"] = [\"outputs\"] if you want to keep raw solver output files from all solver runs. Hint: Options are slightly more described in Setup Then you specify that you want to use cvc5 and that you wish to launch an evaluation. These methods update mysetup and fill in some keys required by setups.launch() . setups . cvc5 ( mysetup ) setups . evaluation ( mysetup ) Finally, you launch the experiments. setups . launch ( mysetup ) You will see the progress of the experiments on the screen. Once finished, you will find the following subdirectories inside solverpy_db : directory content results Results by each strategy ( sid ) for each bid . The result for each sid and bid is a JSON file (gzip-ed) with a Python dictionary {problem: result} . solved List of solved problem names by each strategy for each bid . One per line, easy to grep and cat . status Statuses of all problems by each strategy for each bid . Problem name and status at one line, TAB separated. Easy to cut . log Console log for each solverpy experiment run. outputs Raw solver output files for each solver run (only if selected). Now run the script again and notice that it finished much faster. It is because the cached results were reused and no solvers were actually launched. So be careful and always clean the database if you want to force recompute. Simply delete all the directories in solverpy_db except strats (see the script clean_db.sh in the example archive ).","title":"Experiments example"},{"location":"api/solverpy/benchmark/evaluation/","text":"module evaluation solverpy.benchmark.evaluation","title":"\ud83e\udd16 evaluation"},{"location":"api/solverpy/benchmark/evaluation/#module-evaluation","text":"","title":"module evaluation"},{"location":"api/solverpy/benchmark/evaluation/#solverpy.benchmark.evaluation","text":"","title":"evaluation"},{"location":"api/solverpy/benchmark/summary/","text":"module summary solverpy.benchmark.summary","title":"\ud83e\udd16 summary"},{"location":"api/solverpy/benchmark/summary/#module-summary","text":"","title":"module summary"},{"location":"api/solverpy/benchmark/summary/#solverpy.benchmark.summary","text":"","title":"summary"},{"location":"api/solverpy/benchmark/db/","text":"Db Overview solverpy.benchmark.db This module defines the database for benchmarking. default ( delfix : int | str | None = None ) -> DB Create a database with default providers: Jsons , Solved , and Status . Parameters: Name Type Description Default delfix Prefix to remove from problem names for Solved and Status . See the delfix in Setup for the value format. None Returns: Type Description DB The database. Source code in src/solverpy/benchmark/db/__init__.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 def default ( delfix : ( int | str | None ) = None ) -> DB : \"\"\" Create a database with default providers: [`Jsons`][solverpy.benchmark.db.providers.jsons], [`Solved`][solverpy.benchmark.db.providers.solved], and [`Status`][solverpy.benchmark.db.providers.status]. Args: delfix (): Prefix to remove from problem names for [`Solved`][solverpy.benchmark.db.providers.solved] and [`Status`][solverpy.benchmark.db.providers.status]. See the `delfix` in [`Setup`][solverpy.setups.setup.Setup] for the value format. Returns: The database. \"\"\" return DB ([ Jsons . Maker (), Solved . Maker ( delfix = delfix ), Status . Maker ( delfix = delfix ) ])","title":"\u2139\ufe0f Overview"},{"location":"api/solverpy/benchmark/db/#db-overview","text":"","title":"Db Overview"},{"location":"api/solverpy/benchmark/db/#solverpy.benchmark.db","text":"This module defines the database for benchmarking.","title":"db"},{"location":"api/solverpy/benchmark/db/#solverpy.benchmark.db.default","text":"Create a database with default providers: Jsons , Solved , and Status . Parameters: Name Type Description Default delfix Prefix to remove from problem names for Solved and Status . See the delfix in Setup for the value format. None Returns: Type Description DB The database. Source code in src/solverpy/benchmark/db/__init__.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 def default ( delfix : ( int | str | None ) = None ) -> DB : \"\"\" Create a database with default providers: [`Jsons`][solverpy.benchmark.db.providers.jsons], [`Solved`][solverpy.benchmark.db.providers.solved], and [`Status`][solverpy.benchmark.db.providers.status]. Args: delfix (): Prefix to remove from problem names for [`Solved`][solverpy.benchmark.db.providers.solved] and [`Status`][solverpy.benchmark.db.providers.status]. See the `delfix` in [`Setup`][solverpy.setups.setup.Setup] for the value format. Returns: The database. \"\"\" return DB ([ Jsons . Maker (), Solved . Maker ( delfix = delfix ), Status . Maker ( delfix = delfix ) ])","title":"default"},{"location":"api/solverpy/benchmark/db/cachedprovider/","text":"module cachedprovider solverpy.benchmark.db.cachedprovider","title":"\ud83e\udd16 cachedprovider"},{"location":"api/solverpy/benchmark/db/cachedprovider/#module-cachedprovider","text":"","title":"module cachedprovider"},{"location":"api/solverpy/benchmark/db/cachedprovider/#solverpy.benchmark.db.cachedprovider","text":"","title":"cachedprovider"},{"location":"api/solverpy/benchmark/db/db/","text":"module db solverpy.benchmark.db.db","title":"\ud83e\udd16 db"},{"location":"api/solverpy/benchmark/db/db/#module-db","text":"","title":"module db"},{"location":"api/solverpy/benchmark/db/db/#solverpy.benchmark.db.db","text":"","title":"db"},{"location":"api/solverpy/benchmark/db/provider/","text":"module provider solverpy.benchmark.db.provider Provider Bases: SolverPyObj A data provider that stores and/or queries results of tasks. Source code in src/solverpy/benchmark/db/provider.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 class Provider ( SolverPyObj ): \"\"\"A data provider that stores and/or queries results of tasks.\"\"\" def __init__ ( self , bid : str , sid : str , limit : ( str | None ) = None , caching : bool = False , ): self . bid = bid self . sid = sid self . limit = limit self . caching = caching self . _uptodate = False \"call store for cached results.\" @classmethod def Maker ( cls , ** kwargs ) -> \"ProviderMaker\" : class MakerMaker ( SolverPyObj ): def __init__ ( self ): SolverPyObj . __init__ ( self , cls_name = cls . __name__ , ** kwargs , ) def __call__ ( self , bid : str , sid : str , limit : ( str | None ) = None , ): return cls ( bid , sid , limit , ** kwargs ) return MakerMaker () def query ( self , task : \"SolverTask\" , ) -> ( dict [ str , Any ] | None ): \"\"\"Return the cached result for `task` or None if not available.\"\"\" del task # unused argument return None def store ( self , task : \"SolverTask\" , result : dict [ str , Any ], ): \"\"\"New result for `task` was found. Update the cache.\"\"\" del task , result # unused arguments pass def cached ( self , task : \"SolverTask\" , result : dict [ str , Any ], ): \"\"\"Announcement that the cached `result` for `task` was found.\"\"\" if self . caching : self . store ( task , result ) def commit ( self ) -> None : \"\"\"Save/flush the data.\"\"\" pass def check ( self , task : \"SolverTask\" ) -> None : if ( self . bid != task . bid ) or ( self . sid != task . sid ): raise Exception ( \"Error: Operation on invalid bid/sid in a provider.\" ) cached ( task : SolverTask , result : dict [ str , Any ]) Announcement that the cached result for task was found. Source code in src/solverpy/benchmark/db/provider.py 64 65 66 67 68 69 70 71 def cached ( self , task : \"SolverTask\" , result : dict [ str , Any ], ): \"\"\"Announcement that the cached `result` for `task` was found.\"\"\" if self . caching : self . store ( task , result ) commit () -> None Save/flush the data. Source code in src/solverpy/benchmark/db/provider.py 73 74 75 def commit ( self ) -> None : \"\"\"Save/flush the data.\"\"\" pass query ( task : SolverTask ) -> dict [ str , Any ] | None Return the cached result for task or None if not available. Source code in src/solverpy/benchmark/db/provider.py 47 48 49 50 51 52 53 def query ( self , task : \"SolverTask\" , ) -> ( dict [ str , Any ] | None ): \"\"\"Return the cached result for `task` or None if not available.\"\"\" del task # unused argument return None store ( task : SolverTask , result : dict [ str , Any ]) New result for task was found. Update the cache. Source code in src/solverpy/benchmark/db/provider.py 55 56 57 58 59 60 61 62 def store ( self , task : \"SolverTask\" , result : dict [ str , Any ], ): \"\"\"New result for `task` was found. Update the cache.\"\"\" del task , result # unused arguments pass","title":"\ud83e\udd16 provider"},{"location":"api/solverpy/benchmark/db/provider/#module-provider","text":"","title":"module provider"},{"location":"api/solverpy/benchmark/db/provider/#solverpy.benchmark.db.provider","text":"","title":"provider"},{"location":"api/solverpy/benchmark/db/provider/#solverpy.benchmark.db.provider.Provider","text":"Bases: SolverPyObj A data provider that stores and/or queries results of tasks. Source code in src/solverpy/benchmark/db/provider.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 class Provider ( SolverPyObj ): \"\"\"A data provider that stores and/or queries results of tasks.\"\"\" def __init__ ( self , bid : str , sid : str , limit : ( str | None ) = None , caching : bool = False , ): self . bid = bid self . sid = sid self . limit = limit self . caching = caching self . _uptodate = False \"call store for cached results.\" @classmethod def Maker ( cls , ** kwargs ) -> \"ProviderMaker\" : class MakerMaker ( SolverPyObj ): def __init__ ( self ): SolverPyObj . __init__ ( self , cls_name = cls . __name__ , ** kwargs , ) def __call__ ( self , bid : str , sid : str , limit : ( str | None ) = None , ): return cls ( bid , sid , limit , ** kwargs ) return MakerMaker () def query ( self , task : \"SolverTask\" , ) -> ( dict [ str , Any ] | None ): \"\"\"Return the cached result for `task` or None if not available.\"\"\" del task # unused argument return None def store ( self , task : \"SolverTask\" , result : dict [ str , Any ], ): \"\"\"New result for `task` was found. Update the cache.\"\"\" del task , result # unused arguments pass def cached ( self , task : \"SolverTask\" , result : dict [ str , Any ], ): \"\"\"Announcement that the cached `result` for `task` was found.\"\"\" if self . caching : self . store ( task , result ) def commit ( self ) -> None : \"\"\"Save/flush the data.\"\"\" pass def check ( self , task : \"SolverTask\" ) -> None : if ( self . bid != task . bid ) or ( self . sid != task . sid ): raise Exception ( \"Error: Operation on invalid bid/sid in a provider.\" )","title":"Provider"},{"location":"api/solverpy/benchmark/db/provider/#solverpy.benchmark.db.provider.Provider.cached","text":"Announcement that the cached result for task was found. Source code in src/solverpy/benchmark/db/provider.py 64 65 66 67 68 69 70 71 def cached ( self , task : \"SolverTask\" , result : dict [ str , Any ], ): \"\"\"Announcement that the cached `result` for `task` was found.\"\"\" if self . caching : self . store ( task , result )","title":"cached"},{"location":"api/solverpy/benchmark/db/provider/#solverpy.benchmark.db.provider.Provider.commit","text":"Save/flush the data. Source code in src/solverpy/benchmark/db/provider.py 73 74 75 def commit ( self ) -> None : \"\"\"Save/flush the data.\"\"\" pass","title":"commit"},{"location":"api/solverpy/benchmark/db/provider/#solverpy.benchmark.db.provider.Provider.query","text":"Return the cached result for task or None if not available. Source code in src/solverpy/benchmark/db/provider.py 47 48 49 50 51 52 53 def query ( self , task : \"SolverTask\" , ) -> ( dict [ str , Any ] | None ): \"\"\"Return the cached result for `task` or None if not available.\"\"\" del task # unused argument return None","title":"query"},{"location":"api/solverpy/benchmark/db/provider/#solverpy.benchmark.db.provider.Provider.store","text":"New result for task was found. Update the cache. Source code in src/solverpy/benchmark/db/provider.py 55 56 57 58 59 60 61 62 def store ( self , task : \"SolverTask\" , result : dict [ str , Any ], ): \"\"\"New result for `task` was found. Update the cache.\"\"\" del task , result # unused arguments pass","title":"store"},{"location":"api/solverpy/benchmark/db/providers/jsons/","text":"module jsons solverpy.benchmark.db.providers.jsons","title":"\ud83e\udd16 jsons"},{"location":"api/solverpy/benchmark/db/providers/jsons/#module-jsons","text":"","title":"module jsons"},{"location":"api/solverpy/benchmark/db/providers/jsons/#solverpy.benchmark.db.providers.jsons","text":"","title":"jsons"},{"location":"api/solverpy/benchmark/db/providers/loader/","text":"module loader solverpy.benchmark.db.providers.loader","title":"\ud83e\udd16 loader"},{"location":"api/solverpy/benchmark/db/providers/loader/#module-loader","text":"","title":"module loader"},{"location":"api/solverpy/benchmark/db/providers/loader/#solverpy.benchmark.db.providers.loader","text":"","title":"loader"},{"location":"api/solverpy/benchmark/db/providers/solved/","text":"module solved solverpy.benchmark.db.providers.solved delfix ( problem : str , fix : str | int | None ) -> str Delete a prefix of a problem name. Source code in src/solverpy/benchmark/db/providers/solved.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 def delfix ( problem : str , fix : ( str | int | None ), ) -> str : \"\"\"Delete a prefix of a problem name.\"\"\" if not fix : # covers None, 0, \"\" (also False) return problem if ( type ( fix ) is str ) and problem . startswith ( fix ): return problem [ len ( fix ):] if ( type ( fix ) is int ) and problem . count ( \"/\" ) >= fix : parts = problem . split ( \"/\" ) return \"/\" . join ( parts [ fix :]) logger . warning ( f \"Uknown delfix value type { type ( fix ) } of ' { fix } '\" ) return problem","title":"\ud83e\udd16 solved"},{"location":"api/solverpy/benchmark/db/providers/solved/#module-solved","text":"","title":"module solved"},{"location":"api/solverpy/benchmark/db/providers/solved/#solverpy.benchmark.db.providers.solved","text":"","title":"solved"},{"location":"api/solverpy/benchmark/db/providers/solved/#solverpy.benchmark.db.providers.solved.delfix","text":"Delete a prefix of a problem name. Source code in src/solverpy/benchmark/db/providers/solved.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 def delfix ( problem : str , fix : ( str | int | None ), ) -> str : \"\"\"Delete a prefix of a problem name.\"\"\" if not fix : # covers None, 0, \"\" (also False) return problem if ( type ( fix ) is str ) and problem . startswith ( fix ): return problem [ len ( fix ):] if ( type ( fix ) is int ) and problem . count ( \"/\" ) >= fix : parts = problem . split ( \"/\" ) return \"/\" . join ( parts [ fix :]) logger . warning ( f \"Uknown delfix value type { type ( fix ) } of ' { fix } '\" ) return problem","title":"delfix"},{"location":"api/solverpy/benchmark/db/providers/status/","text":"module status solverpy.benchmark.db.providers.status","title":"\ud83e\udd16 status"},{"location":"api/solverpy/benchmark/db/providers/status/#module-status","text":"","title":"module status"},{"location":"api/solverpy/benchmark/db/providers/status/#solverpy.benchmark.db.providers.status","text":"","title":"status"},{"location":"api/solverpy/benchmark/path/bids/","text":"module bids solverpy.benchmark.path.bids Benchmark identifiers (bid) Benchmark problem sets are represented by benchark ids ( bid ). The benchmark id is a file path relative to the directory in the SOLVERPY_BENCHMARKS environment variable, defaulting to the current working directory. The file path must point either to a file or to a directory. If the path leads to a: directory : then every regular file directly in this directory is considered a benchmark problem. Directories and hidden files are ignored and no recursive search is performed. This variant is useful when you have a set of problem files, all in one directory. file : then the file consists of lines containing paths to corresponding problem files. The paths are relative to the directory of the bid file. This variant is useful when your benchmarks are structured in subdirectories and you don't want to merge them into one directory. Example If the bid is my/problems/subset1 and this points to a file that contains (among others) the line category1/problem23.smt2 then the corresponding problem must be placed in my/problems/category1/problem23.smt2 (because the directory of the bid file is my/problems ). Module content bidpath ( bid : str ) -> str Return the path to the benchmark id file or directory. Source code in src/solverpy/benchmark/path/bids.py 39 40 41 def bidpath ( bid : str ) -> str : \"\"\"Return the path to the benchmark id file or directory.\"\"\" return os . path . join ( DEFAULT_DIR , bid ) dbpath ( subdir : str | None = None ) -> str Return the full path to the database directory. Source code in src/solverpy/benchmark/path/bids.py 44 45 46 47 def dbpath ( subdir : str | None = None ) -> str : \"\"\"Return the full path to the database directory.\"\"\" # TODO: move this elsewhere return os . path . join ( DB_DIR , subdir ) if subdir else DB_DIR name ( bid : str , limit : str | None = None ) -> str Translate the benchmark id to a shell-safe name. Source code in src/solverpy/benchmark/path/bids.py 79 80 81 82 83 84 def name ( bid : str , limit : str | None = None ) -> str : \"\"\"Translate the benchmark id to a shell-safe name.\"\"\" bid = bid . replace ( \"/\" , \"--\" ) if limit : bid = f \" { bid } -- { limit } \" return bid path ( bid : str , problem : str , flatten : bool | str = False ) -> str Return the path to the benchmark problem file. Parameters: Name Type Description Default bid str The benchmark id. required problem str The problem name. required flatten bool | str Flatten the problem name so that all problems can be placed in the same directory. If False , then no flattening is performed. If True , then / is replaced with _._ . If a string, then / is replaced with the given string. False Returns: Type Description str Full path to the problem file. Source code in src/solverpy/benchmark/path/bids.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 def path ( bid : str , problem : str , flatten : bool | str = False , ) -> str : \"\"\" Return the path to the benchmark problem file. Args: bid: The benchmark id. problem: The problem name. flatten: Flatten the problem name so that all problems can be placed in the same directory. If `False`, then no flattening is performed. If `True`, then `/` is replaced with `_._`. If a string, then `/` is replaced with the given string. Returns: Full path to the problem file. \"\"\" \"\"\"Return the path to the problem file.\"\"\" p_bid = bidpath ( bid ) if os . path . isfile ( p_bid ): p_bid = os . path . dirname ( p_bid ) if flatten and problem : problem = problem . replace ( \"/\" , \"_._\" if flatten is True else flatten ) return os . path . join ( p_bid , problem ) . rstrip ( \"/\" ) problems ( bid : str , cache : dict [ str , list [ str ]] = {}) -> list [ str ] Return the list of all benchmark problems. Parameters: Name Type Description Default bid str The benchmark id. required cache dict [ str , list [ str ]] The problem cache for every loaded bid . Each bid is loaded just once. {} Returns: Type Description list [ str ] The list of all benchmark problems. The pair ( bid , problem ) is a unique problem identifier. Source code in src/solverpy/benchmark/path/bids.py 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 def problems ( bid : str , cache : dict [ str , list [ str ]] = {}, ) -> list [ str ]: \"\"\" Return the list of all benchmark problems. Args: bid: The benchmark id. cache: The problem cache for every loaded `bid`. Each `bid` is loaded just once. Returns: The list of all benchmark problems. The pair (`bid`, `problem`) is a unique problem identifier. \"\"\" if bid in cache : return cache [ bid ] p_bid = bidpath ( bid ) if os . path . isfile ( p_bid ): probs = open ( p_bid ) . read () . strip () . split ( \" \\n \" ) else : # now os.path.isdir(p_bid) holds probs = [ x for x in os . listdir ( p_bid ) \\ if os . path . isfile ( os . path . join ( p_bid , x ))] cache [ bid ] = probs return probs","title":"\ud83e\udd16 bids"},{"location":"api/solverpy/benchmark/path/bids/#module-bids","text":"","title":"module bids"},{"location":"api/solverpy/benchmark/path/bids/#solverpy.benchmark.path.bids","text":"","title":"bids"},{"location":"api/solverpy/benchmark/path/bids/#solverpy.benchmark.path.bids--benchmark-identifiers-bid","text":"Benchmark problem sets are represented by benchark ids ( bid ). The benchmark id is a file path relative to the directory in the SOLVERPY_BENCHMARKS environment variable, defaulting to the current working directory. The file path must point either to a file or to a directory. If the path leads to a: directory : then every regular file directly in this directory is considered a benchmark problem. Directories and hidden files are ignored and no recursive search is performed. This variant is useful when you have a set of problem files, all in one directory. file : then the file consists of lines containing paths to corresponding problem files. The paths are relative to the directory of the bid file. This variant is useful when your benchmarks are structured in subdirectories and you don't want to merge them into one directory. Example If the bid is my/problems/subset1 and this points to a file that contains (among others) the line category1/problem23.smt2 then the corresponding problem must be placed in my/problems/category1/problem23.smt2 (because the directory of the bid file is my/problems ).","title":"Benchmark identifiers (bid)"},{"location":"api/solverpy/benchmark/path/bids/#solverpy.benchmark.path.bids--module-content","text":"","title":"Module content"},{"location":"api/solverpy/benchmark/path/bids/#solverpy.benchmark.path.bids.bidpath","text":"Return the path to the benchmark id file or directory. Source code in src/solverpy/benchmark/path/bids.py 39 40 41 def bidpath ( bid : str ) -> str : \"\"\"Return the path to the benchmark id file or directory.\"\"\" return os . path . join ( DEFAULT_DIR , bid )","title":"bidpath"},{"location":"api/solverpy/benchmark/path/bids/#solverpy.benchmark.path.bids.dbpath","text":"Return the full path to the database directory. Source code in src/solverpy/benchmark/path/bids.py 44 45 46 47 def dbpath ( subdir : str | None = None ) -> str : \"\"\"Return the full path to the database directory.\"\"\" # TODO: move this elsewhere return os . path . join ( DB_DIR , subdir ) if subdir else DB_DIR","title":"dbpath"},{"location":"api/solverpy/benchmark/path/bids/#solverpy.benchmark.path.bids.name","text":"Translate the benchmark id to a shell-safe name. Source code in src/solverpy/benchmark/path/bids.py 79 80 81 82 83 84 def name ( bid : str , limit : str | None = None ) -> str : \"\"\"Translate the benchmark id to a shell-safe name.\"\"\" bid = bid . replace ( \"/\" , \"--\" ) if limit : bid = f \" { bid } -- { limit } \" return bid","title":"name"},{"location":"api/solverpy/benchmark/path/bids/#solverpy.benchmark.path.bids.path","text":"Return the path to the benchmark problem file. Parameters: Name Type Description Default bid str The benchmark id. required problem str The problem name. required flatten bool | str Flatten the problem name so that all problems can be placed in the same directory. If False , then no flattening is performed. If True , then / is replaced with _._ . If a string, then / is replaced with the given string. False Returns: Type Description str Full path to the problem file. Source code in src/solverpy/benchmark/path/bids.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 def path ( bid : str , problem : str , flatten : bool | str = False , ) -> str : \"\"\" Return the path to the benchmark problem file. Args: bid: The benchmark id. problem: The problem name. flatten: Flatten the problem name so that all problems can be placed in the same directory. If `False`, then no flattening is performed. If `True`, then `/` is replaced with `_._`. If a string, then `/` is replaced with the given string. Returns: Full path to the problem file. \"\"\" \"\"\"Return the path to the problem file.\"\"\" p_bid = bidpath ( bid ) if os . path . isfile ( p_bid ): p_bid = os . path . dirname ( p_bid ) if flatten and problem : problem = problem . replace ( \"/\" , \"_._\" if flatten is True else flatten ) return os . path . join ( p_bid , problem ) . rstrip ( \"/\" )","title":"path"},{"location":"api/solverpy/benchmark/path/bids/#solverpy.benchmark.path.bids.problems","text":"Return the list of all benchmark problems. Parameters: Name Type Description Default bid str The benchmark id. required cache dict [ str , list [ str ]] The problem cache for every loaded bid . Each bid is loaded just once. {} Returns: Type Description list [ str ] The list of all benchmark problems. The pair ( bid , problem ) is a unique problem identifier. Source code in src/solverpy/benchmark/path/bids.py 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 def problems ( bid : str , cache : dict [ str , list [ str ]] = {}, ) -> list [ str ]: \"\"\" Return the list of all benchmark problems. Args: bid: The benchmark id. cache: The problem cache for every loaded `bid`. Each `bid` is loaded just once. Returns: The list of all benchmark problems. The pair (`bid`, `problem`) is a unique problem identifier. \"\"\" if bid in cache : return cache [ bid ] p_bid = bidpath ( bid ) if os . path . isfile ( p_bid ): probs = open ( p_bid ) . read () . strip () . split ( \" \\n \" ) else : # now os.path.isdir(p_bid) holds probs = [ x for x in os . listdir ( p_bid ) \\ if os . path . isfile ( os . path . join ( p_bid , x ))] cache [ bid ] = probs return probs","title":"problems"},{"location":"api/solverpy/benchmark/path/sids/","text":"module sids solverpy.benchmark.path.sids Strategy identifiers (sid) Strategy is a collection of solver options, parameters, settings, etc., that influence the space search behavior of the solver. In SolverPy, this collection must be stored in a file and placed inside the strats database directory, by default solverpy_db/strats (see the db module). The file name inside the strats directory is called the strategy id ( sid ). The content of the file is a solver-specific strategy definition that is passed to the Solver.solve method. Example For E Prover, you can have the file solverpy_db/strats/auto with the following content: --auto-schedule Then --auto-schedule is the strategy definition while auto is its strategy id. You can now use auto in sidlist to reference the strategy in experiment setup Setup with E Prover. Note As opposed to a benchmark identifier bid , a strategy identifier sid can not contain / characters. Parametric Strategies Some solvers support parametric strategies with variable slots in the strategy definition. The syntax for variable slots is as follows: @@@ var : value @@@ where var is the variable name and value is its default value. Note Names var and value can not contain characters @ , : , or space. The value of a variable can be overridden in the strategy identifier using the following format: sid@var1=value1:var2=value2 Here sid still refers to the base strategy id, while var1=value1 and var2=value2 are different variable assignments. Any number of : -separated variable assignments can be provided in the strategy id. Example For E Prover, you can have a parametric strategy gen with the following definition: --enigmatic-gen-threshold=@@@ thrgen : 0.1 @@@ Then the strategy id (sid) gen@thrgen=0.5 results in the following strategy definition: --enigmatic-gen-threshold=0.5 See Also See the Sid solver plugin that automatically translates strategy ids to strategy definitions. For more details about solver-specific strategy formats, see concrete solvers implemented in the solver module. Module content Note In the code base, arguments/variables sid refer to the strategy identifiers, while strategy refers to the strategy definition. defaults ( strategy : str ) -> dict [ str , str ] Extract variables and default values from the strategy definition. Source code in src/solverpy/benchmark/path/sids.py 138 139 140 141 142 def defaults ( strategy : str ) -> dict [ str , str ]: \"\"\"Extract variables and default values from the strategy definition.\"\"\" ret = ARGUMENT . findall ( strategy ) ret = { x . strip (): y . strip () for ( x , y ) in ret } return ret fmt ( base : str , args : dict [ str , str ]) -> str Format strategy file with arguments. Source code in src/solverpy/benchmark/path/sids.py 144 145 146 147 def fmt ( base : str , args : dict [ str , str ]) -> str : \"\"\"Format strategy file with arguments.\"\"\" args0 = \":\" . join ( f \" { x } = { args [ x ] } \" for x in sorted ( args )) return f \" { base } @ { args0 } \" instatiate ( strategy : str , args : dict [ str , str ]) -> str Instantiate the strategy with arguments. Source code in src/solverpy/benchmark/path/sids.py 131 132 133 134 135 136 def instatiate ( strategy : str , args : dict [ str , str ]) -> str : \"\"\"Instantiate the strategy with arguments.\"\"\" args0 = defaults ( strategy ) args0 . update ( args ) ret = ARGUMENT . sub ( lambda mo : args0 [ mo . group ( 1 )], strategy ) return ret load ( sid : str ) -> str Load the strategy definition. Source code in src/solverpy/benchmark/path/sids.py 104 105 106 def load ( sid : str ) -> str : \"\"\"Load the strategy definition.\"\"\" return open ( path ( sid )) . read () . strip () normalize ( sid : str ) -> str Remove arguments from sid which set default values and sort arguments. Source code in src/solverpy/benchmark/path/sids.py 149 150 151 152 153 154 155 def normalize ( sid : str ) -> str : \"\"\"Remove arguments from sid which set default values and sort arguments.\"\"\" strategy = load ( sid ) defs = defaults ( strategy ) ( sid , args ) = split ( sid ) args = { x : y for ( x , y ) in args . items () if y != defs [ x ]} return fmt ( sid , args ) path ( sid : str ) -> str Return the path to the strategy file. Source code in src/solverpy/benchmark/path/sids.py 99 100 101 102 def path ( sid : str ) -> str : \"\"\"Return the path to the strategy file.\"\"\" f_sid = sid . split ( \"@\" )[ 0 ] if ( \"@\" in sid ) else sid return os . path . join ( bids . dbpath ( NAME ), f_sid ) save ( sid : str , strategy : str ) -> None Save the strategy definition. Source code in src/solverpy/benchmark/path/sids.py 108 109 110 111 112 def save ( sid : str , strategy : str ) -> None : \"\"\"Save the strategy definition.\"\"\" f_sid = path ( sid ) os . makedirs ( os . path . dirname ( f_sid ), exist_ok = True ) open ( f_sid , \"w\" ) . write ( strategy . strip ()) split ( sid : str ) -> tuple [ str , dict [ str , str ]] Split sid into the strategy file and arguments. Source code in src/solverpy/benchmark/path/sids.py 121 122 123 124 125 126 127 128 129 def split ( sid : str ) -> tuple [ str , dict [ str , str ]]: \"\"\"Split sid into the strategy file and arguments.\"\"\" args = {} if \"@\" in sid : ( sid , args ) = sid . split ( \"@\" ) args = args . split ( \":\" ) args = [ x . split ( \"=\" ) for x in args ] args = { x . strip (): y . strip () for ( x , y ) in args } return ( sid , args ) unspace ( strategy : str ) -> str Merge multiple white spaces into a single space. Source code in src/solverpy/benchmark/path/sids.py 117 118 119 def unspace ( strategy : str ) -> str : \"\"\"Merge multiple white spaces into a single space.\"\"\" return \" \" . join ( x for x in strategy . split () if x )","title":"\ud83e\udd16 sids"},{"location":"api/solverpy/benchmark/path/sids/#module-sids","text":"","title":"module sids"},{"location":"api/solverpy/benchmark/path/sids/#solverpy.benchmark.path.sids","text":"","title":"sids"},{"location":"api/solverpy/benchmark/path/sids/#solverpy.benchmark.path.sids--strategy-identifiers-sid","text":"Strategy is a collection of solver options, parameters, settings, etc., that influence the space search behavior of the solver. In SolverPy, this collection must be stored in a file and placed inside the strats database directory, by default solverpy_db/strats (see the db module). The file name inside the strats directory is called the strategy id ( sid ). The content of the file is a solver-specific strategy definition that is passed to the Solver.solve method. Example For E Prover, you can have the file solverpy_db/strats/auto with the following content: --auto-schedule Then --auto-schedule is the strategy definition while auto is its strategy id. You can now use auto in sidlist to reference the strategy in experiment setup Setup with E Prover. Note As opposed to a benchmark identifier bid , a strategy identifier sid can not contain / characters.","title":"Strategy identifiers (sid)"},{"location":"api/solverpy/benchmark/path/sids/#solverpy.benchmark.path.sids--parametric-strategies","text":"Some solvers support parametric strategies with variable slots in the strategy definition. The syntax for variable slots is as follows: @@@ var : value @@@ where var is the variable name and value is its default value. Note Names var and value can not contain characters @ , : , or space. The value of a variable can be overridden in the strategy identifier using the following format: sid@var1=value1:var2=value2 Here sid still refers to the base strategy id, while var1=value1 and var2=value2 are different variable assignments. Any number of : -separated variable assignments can be provided in the strategy id. Example For E Prover, you can have a parametric strategy gen with the following definition: --enigmatic-gen-threshold=@@@ thrgen : 0.1 @@@ Then the strategy id (sid) gen@thrgen=0.5 results in the following strategy definition: --enigmatic-gen-threshold=0.5 See Also See the Sid solver plugin that automatically translates strategy ids to strategy definitions. For more details about solver-specific strategy formats, see concrete solvers implemented in the solver module.","title":"Parametric Strategies"},{"location":"api/solverpy/benchmark/path/sids/#solverpy.benchmark.path.sids--module-content","text":"Note In the code base, arguments/variables sid refer to the strategy identifiers, while strategy refers to the strategy definition.","title":"Module content"},{"location":"api/solverpy/benchmark/path/sids/#solverpy.benchmark.path.sids.defaults","text":"Extract variables and default values from the strategy definition. Source code in src/solverpy/benchmark/path/sids.py 138 139 140 141 142 def defaults ( strategy : str ) -> dict [ str , str ]: \"\"\"Extract variables and default values from the strategy definition.\"\"\" ret = ARGUMENT . findall ( strategy ) ret = { x . strip (): y . strip () for ( x , y ) in ret } return ret","title":"defaults"},{"location":"api/solverpy/benchmark/path/sids/#solverpy.benchmark.path.sids.fmt","text":"Format strategy file with arguments. Source code in src/solverpy/benchmark/path/sids.py 144 145 146 147 def fmt ( base : str , args : dict [ str , str ]) -> str : \"\"\"Format strategy file with arguments.\"\"\" args0 = \":\" . join ( f \" { x } = { args [ x ] } \" for x in sorted ( args )) return f \" { base } @ { args0 } \"","title":"fmt"},{"location":"api/solverpy/benchmark/path/sids/#solverpy.benchmark.path.sids.instatiate","text":"Instantiate the strategy with arguments. Source code in src/solverpy/benchmark/path/sids.py 131 132 133 134 135 136 def instatiate ( strategy : str , args : dict [ str , str ]) -> str : \"\"\"Instantiate the strategy with arguments.\"\"\" args0 = defaults ( strategy ) args0 . update ( args ) ret = ARGUMENT . sub ( lambda mo : args0 [ mo . group ( 1 )], strategy ) return ret","title":"instatiate"},{"location":"api/solverpy/benchmark/path/sids/#solverpy.benchmark.path.sids.load","text":"Load the strategy definition. Source code in src/solverpy/benchmark/path/sids.py 104 105 106 def load ( sid : str ) -> str : \"\"\"Load the strategy definition.\"\"\" return open ( path ( sid )) . read () . strip ()","title":"load"},{"location":"api/solverpy/benchmark/path/sids/#solverpy.benchmark.path.sids.normalize","text":"Remove arguments from sid which set default values and sort arguments. Source code in src/solverpy/benchmark/path/sids.py 149 150 151 152 153 154 155 def normalize ( sid : str ) -> str : \"\"\"Remove arguments from sid which set default values and sort arguments.\"\"\" strategy = load ( sid ) defs = defaults ( strategy ) ( sid , args ) = split ( sid ) args = { x : y for ( x , y ) in args . items () if y != defs [ x ]} return fmt ( sid , args )","title":"normalize"},{"location":"api/solverpy/benchmark/path/sids/#solverpy.benchmark.path.sids.path","text":"Return the path to the strategy file. Source code in src/solverpy/benchmark/path/sids.py 99 100 101 102 def path ( sid : str ) -> str : \"\"\"Return the path to the strategy file.\"\"\" f_sid = sid . split ( \"@\" )[ 0 ] if ( \"@\" in sid ) else sid return os . path . join ( bids . dbpath ( NAME ), f_sid )","title":"path"},{"location":"api/solverpy/benchmark/path/sids/#solverpy.benchmark.path.sids.save","text":"Save the strategy definition. Source code in src/solverpy/benchmark/path/sids.py 108 109 110 111 112 def save ( sid : str , strategy : str ) -> None : \"\"\"Save the strategy definition.\"\"\" f_sid = path ( sid ) os . makedirs ( os . path . dirname ( f_sid ), exist_ok = True ) open ( f_sid , \"w\" ) . write ( strategy . strip ())","title":"save"},{"location":"api/solverpy/benchmark/path/sids/#solverpy.benchmark.path.sids.split","text":"Split sid into the strategy file and arguments. Source code in src/solverpy/benchmark/path/sids.py 121 122 123 124 125 126 127 128 129 def split ( sid : str ) -> tuple [ str , dict [ str , str ]]: \"\"\"Split sid into the strategy file and arguments.\"\"\" args = {} if \"@\" in sid : ( sid , args ) = sid . split ( \"@\" ) args = args . split ( \":\" ) args = [ x . split ( \"=\" ) for x in args ] args = { x . strip (): y . strip () for ( x , y ) in args } return ( sid , args )","title":"split"},{"location":"api/solverpy/benchmark/path/sids/#solverpy.benchmark.path.sids.unspace","text":"Merge multiple white spaces into a single space. Source code in src/solverpy/benchmark/path/sids.py 117 118 119 def unspace ( strategy : str ) -> str : \"\"\"Merge multiple white spaces into a single space.\"\"\" return \" \" . join ( x for x in strategy . split () if x )","title":"unspace"},{"location":"api/solverpy/benchmark/reports/data/","text":"module data solverpy.benchmark.reports.data","title":"\ud83e\udd16 data"},{"location":"api/solverpy/benchmark/reports/data/#module-data","text":"","title":"module data"},{"location":"api/solverpy/benchmark/reports/data/#solverpy.benchmark.reports.data","text":"","title":"data"},{"location":"api/solverpy/benchmark/reports/markdown/","text":"module markdown solverpy.benchmark.reports.markdown","title":"\ud83e\udd16 markdown"},{"location":"api/solverpy/benchmark/reports/markdown/#module-markdown","text":"","title":"module markdown"},{"location":"api/solverpy/benchmark/reports/markdown/#solverpy.benchmark.reports.markdown","text":"","title":"markdown"},{"location":"api/solverpy/benchmark/reports/progress/","text":"module progress solverpy.benchmark.reports.progress","title":"\ud83e\udd16 progress"},{"location":"api/solverpy/benchmark/reports/progress/#module-progress","text":"","title":"module progress"},{"location":"api/solverpy/benchmark/reports/progress/#solverpy.benchmark.reports.progress","text":"","title":"progress"},{"location":"api/solverpy/builder/","text":"Builder Overview solverpy.builder This module encapsulates the model builder for ML experiments.","title":"\u2139\ufe0f Overview"},{"location":"api/solverpy/builder/#builder-overview","text":"","title":"Builder Overview"},{"location":"api/solverpy/builder/#solverpy.builder","text":"This module encapsulates the model builder for ML experiments.","title":"builder"},{"location":"api/solverpy/builder/autotuner/","text":"module autotuner solverpy.builder.autotuner","title":"\ud83e\udd16 autotuner"},{"location":"api/solverpy/builder/autotuner/#module-autotuner","text":"","title":"module autotuner"},{"location":"api/solverpy/builder/autotuner/#solverpy.builder.autotuner","text":"","title":"autotuner"},{"location":"api/solverpy/builder/builder/","text":"module builder solverpy.builder.builder Builder Bases: SolverPyObj Build the model from the training samples. Source code in src/solverpy/builder/builder.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 class Builder ( SolverPyObj ): \"\"\"Build the model from the training samples.\"\"\" def __init__ ( self , dataname : str ): \"\"\"Construct the builder and store the dataname.\"\"\" SolverPyObj . __init__ ( self , dataname = dataname ) self . _strats = [] self . _dataname = dataname def path ( self ) -> str : \"\"\"Return the model filename.\"\"\" return os . path . join ( bids . dbpath ( NAME ), self . _dataname ) def reset ( self , dataname : str ) -> None : \"\"\"Reset the dataname, for example, when a new loop is initiated.\"\"\" self . _dataname = dataname def build ( self ) -> None : \"\"\"Build the model(s). Save the list of new strategies `self._strats`.\"\"\" raise NotImplementedError () def apply ( self , sid : str , model : str ) -> list [ str ]: \"\"\"Combine the `model` with strategy `sid`.\"\"\" del sid , model raise NotImplementedError () @property def strategies ( self ): \"\"\"Return all created strategies.\"\"\" return self . _strats def applies ( self , sidlist : list [ str ], model : str ) -> list [ str ]: \"\"\"Combine the `model` with several strategies `sidlist`.\"\"\" new = [] for ref in sidlist : new . extend ( self . apply ( ref , model )) return new strategies property Return all created strategies. __init__ ( dataname : str ) Construct the builder and store the dataname. Source code in src/solverpy/builder/builder.py 15 16 17 18 19 def __init__ ( self , dataname : str ): \"\"\"Construct the builder and store the dataname.\"\"\" SolverPyObj . __init__ ( self , dataname = dataname ) self . _strats = [] self . _dataname = dataname applies ( sidlist : list [ str ], model : str ) -> list [ str ] Combine the model with several strategies sidlist . Source code in src/solverpy/builder/builder.py 43 44 45 46 47 48 def applies ( self , sidlist : list [ str ], model : str ) -> list [ str ]: \"\"\"Combine the `model` with several strategies `sidlist`.\"\"\" new = [] for ref in sidlist : new . extend ( self . apply ( ref , model )) return new apply ( sid : str , model : str ) -> list [ str ] Combine the model with strategy sid . Source code in src/solverpy/builder/builder.py 33 34 35 36 def apply ( self , sid : str , model : str ) -> list [ str ]: \"\"\"Combine the `model` with strategy `sid`.\"\"\" del sid , model raise NotImplementedError () build () -> None Build the model(s). Save the list of new strategies self._strats . Source code in src/solverpy/builder/builder.py 29 30 31 def build ( self ) -> None : \"\"\"Build the model(s). Save the list of new strategies `self._strats`.\"\"\" raise NotImplementedError () path () -> str Return the model filename. Source code in src/solverpy/builder/builder.py 21 22 23 def path ( self ) -> str : \"\"\"Return the model filename.\"\"\" return os . path . join ( bids . dbpath ( NAME ), self . _dataname ) reset ( dataname : str ) -> None Reset the dataname, for example, when a new loop is initiated. Source code in src/solverpy/builder/builder.py 25 26 27 def reset ( self , dataname : str ) -> None : \"\"\"Reset the dataname, for example, when a new loop is initiated.\"\"\" self . _dataname = dataname","title":"\ud83e\udd16 builder"},{"location":"api/solverpy/builder/builder/#module-builder","text":"","title":"module builder"},{"location":"api/solverpy/builder/builder/#solverpy.builder.builder","text":"","title":"builder"},{"location":"api/solverpy/builder/builder/#solverpy.builder.builder.Builder","text":"Bases: SolverPyObj Build the model from the training samples. Source code in src/solverpy/builder/builder.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 class Builder ( SolverPyObj ): \"\"\"Build the model from the training samples.\"\"\" def __init__ ( self , dataname : str ): \"\"\"Construct the builder and store the dataname.\"\"\" SolverPyObj . __init__ ( self , dataname = dataname ) self . _strats = [] self . _dataname = dataname def path ( self ) -> str : \"\"\"Return the model filename.\"\"\" return os . path . join ( bids . dbpath ( NAME ), self . _dataname ) def reset ( self , dataname : str ) -> None : \"\"\"Reset the dataname, for example, when a new loop is initiated.\"\"\" self . _dataname = dataname def build ( self ) -> None : \"\"\"Build the model(s). Save the list of new strategies `self._strats`.\"\"\" raise NotImplementedError () def apply ( self , sid : str , model : str ) -> list [ str ]: \"\"\"Combine the `model` with strategy `sid`.\"\"\" del sid , model raise NotImplementedError () @property def strategies ( self ): \"\"\"Return all created strategies.\"\"\" return self . _strats def applies ( self , sidlist : list [ str ], model : str ) -> list [ str ]: \"\"\"Combine the `model` with several strategies `sidlist`.\"\"\" new = [] for ref in sidlist : new . extend ( self . apply ( ref , model )) return new","title":"Builder"},{"location":"api/solverpy/builder/builder/#solverpy.builder.builder.Builder.strategies","text":"Return all created strategies.","title":"strategies"},{"location":"api/solverpy/builder/builder/#solverpy.builder.builder.Builder.__init__","text":"Construct the builder and store the dataname. Source code in src/solverpy/builder/builder.py 15 16 17 18 19 def __init__ ( self , dataname : str ): \"\"\"Construct the builder and store the dataname.\"\"\" SolverPyObj . __init__ ( self , dataname = dataname ) self . _strats = [] self . _dataname = dataname","title":"__init__"},{"location":"api/solverpy/builder/builder/#solverpy.builder.builder.Builder.applies","text":"Combine the model with several strategies sidlist . Source code in src/solverpy/builder/builder.py 43 44 45 46 47 48 def applies ( self , sidlist : list [ str ], model : str ) -> list [ str ]: \"\"\"Combine the `model` with several strategies `sidlist`.\"\"\" new = [] for ref in sidlist : new . extend ( self . apply ( ref , model )) return new","title":"applies"},{"location":"api/solverpy/builder/builder/#solverpy.builder.builder.Builder.apply","text":"Combine the model with strategy sid . Source code in src/solverpy/builder/builder.py 33 34 35 36 def apply ( self , sid : str , model : str ) -> list [ str ]: \"\"\"Combine the `model` with strategy `sid`.\"\"\" del sid , model raise NotImplementedError ()","title":"apply"},{"location":"api/solverpy/builder/builder/#solverpy.builder.builder.Builder.build","text":"Build the model(s). Save the list of new strategies self._strats . Source code in src/solverpy/builder/builder.py 29 30 31 def build ( self ) -> None : \"\"\"Build the model(s). Save the list of new strategies `self._strats`.\"\"\" raise NotImplementedError ()","title":"build"},{"location":"api/solverpy/builder/builder/#solverpy.builder.builder.Builder.path","text":"Return the model filename. Source code in src/solverpy/builder/builder.py 21 22 23 def path ( self ) -> str : \"\"\"Return the model filename.\"\"\" return os . path . join ( bids . dbpath ( NAME ), self . _dataname )","title":"path"},{"location":"api/solverpy/builder/builder/#solverpy.builder.builder.Builder.reset","text":"Reset the dataname, for example, when a new loop is initiated. Source code in src/solverpy/builder/builder.py 25 26 27 def reset ( self , dataname : str ) -> None : \"\"\"Reset the dataname, for example, when a new loop is initiated.\"\"\" self . _dataname = dataname","title":"reset"},{"location":"api/solverpy/builder/cvc5ml/","text":"module cvc5ml solverpy.builder.cvc5ml Cvc5ML Bases: AutoTuner Source code in src/solverpy/builder/cvc5ml.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 class Cvc5ML ( AutoTuner ): def __init__ ( self , trains : Setup , devels : ( Setup | None ) = None , tuneargs : ( dict [ str , Any ] | None ) = None , ): AutoTuner . __init__ ( self , trains , devels , tuneargs , ) def template ( self , sid : str ) -> str : \"`sid` must be base strategy without parameters\" if sid . endswith ( \"-ml\" ): logger . debug ( f \"strategy { sid } already ml-enhanced\" ) return sid sidml = f \" { sid } -ml\" if os . path . exists ( sids . path ( sidml )): logger . debug ( f \"ml strategy { sidml } already exists\" ) return sidml dbpath = bids . dbpath ( NAME ) mod = f \" { dbpath } /@@@model:default@@@/model.lgb\" strat = sids . load ( sid ) . rstrip () strat = self . mlstrat ( strat , mod ) sids . save ( sidml , strat ) logger . debug ( f \"created parametric ml strategy { sidml } inherited from { sid } : \\n { strat } \" ) return sidml def mlstrat ( self , strat : str , model : str ) -> str : adds = \" \\n \" . join ([ f \"--ml-engine\" , f \"--ml-model= { model } \" , f \"--ml-usage=@@@usage:1.0@@@\" , f \"--ml-fallback=@@@fallback:0@@@\" , f \"--ml-selector=@@@sel:orig@@@\" , f \"--ml-selector-value=@@@val:0.5@@@\" , ]) return f \" { strat } \\n { adds } \" def apply ( self , sid : str , model : str ) -> list [ str ]: ( base , args ) = sids . split ( sid ) tpl = self . template ( base ) sidml = sids . fmt ( tpl , dict ( args , model = model )) logger . debug ( f \"new strategy: { sidml } \" ) return [ sidml ] template ( sid : str ) -> str sid must be base strategy without parameters Source code in src/solverpy/builder/cvc5ml.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 def template ( self , sid : str ) -> str : \"`sid` must be base strategy without parameters\" if sid . endswith ( \"-ml\" ): logger . debug ( f \"strategy { sid } already ml-enhanced\" ) return sid sidml = f \" { sid } -ml\" if os . path . exists ( sids . path ( sidml )): logger . debug ( f \"ml strategy { sidml } already exists\" ) return sidml dbpath = bids . dbpath ( NAME ) mod = f \" { dbpath } /@@@model:default@@@/model.lgb\" strat = sids . load ( sid ) . rstrip () strat = self . mlstrat ( strat , mod ) sids . save ( sidml , strat ) logger . debug ( f \"created parametric ml strategy { sidml } inherited from { sid } : \\n { strat } \" ) return sidml","title":"\ud83e\udd16 cvc5ml"},{"location":"api/solverpy/builder/cvc5ml/#module-cvc5ml","text":"","title":"module cvc5ml"},{"location":"api/solverpy/builder/cvc5ml/#solverpy.builder.cvc5ml","text":"","title":"cvc5ml"},{"location":"api/solverpy/builder/cvc5ml/#solverpy.builder.cvc5ml.Cvc5ML","text":"Bases: AutoTuner Source code in src/solverpy/builder/cvc5ml.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 class Cvc5ML ( AutoTuner ): def __init__ ( self , trains : Setup , devels : ( Setup | None ) = None , tuneargs : ( dict [ str , Any ] | None ) = None , ): AutoTuner . __init__ ( self , trains , devels , tuneargs , ) def template ( self , sid : str ) -> str : \"`sid` must be base strategy without parameters\" if sid . endswith ( \"-ml\" ): logger . debug ( f \"strategy { sid } already ml-enhanced\" ) return sid sidml = f \" { sid } -ml\" if os . path . exists ( sids . path ( sidml )): logger . debug ( f \"ml strategy { sidml } already exists\" ) return sidml dbpath = bids . dbpath ( NAME ) mod = f \" { dbpath } /@@@model:default@@@/model.lgb\" strat = sids . load ( sid ) . rstrip () strat = self . mlstrat ( strat , mod ) sids . save ( sidml , strat ) logger . debug ( f \"created parametric ml strategy { sidml } inherited from { sid } : \\n { strat } \" ) return sidml def mlstrat ( self , strat : str , model : str ) -> str : adds = \" \\n \" . join ([ f \"--ml-engine\" , f \"--ml-model= { model } \" , f \"--ml-usage=@@@usage:1.0@@@\" , f \"--ml-fallback=@@@fallback:0@@@\" , f \"--ml-selector=@@@sel:orig@@@\" , f \"--ml-selector-value=@@@val:0.5@@@\" , ]) return f \" { strat } \\n { adds } \" def apply ( self , sid : str , model : str ) -> list [ str ]: ( base , args ) = sids . split ( sid ) tpl = self . template ( base ) sidml = sids . fmt ( tpl , dict ( args , model = model )) logger . debug ( f \"new strategy: { sidml } \" ) return [ sidml ]","title":"Cvc5ML"},{"location":"api/solverpy/builder/cvc5ml/#solverpy.builder.cvc5ml.Cvc5ML.template","text":"sid must be base strategy without parameters Source code in src/solverpy/builder/cvc5ml.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 def template ( self , sid : str ) -> str : \"`sid` must be base strategy without parameters\" if sid . endswith ( \"-ml\" ): logger . debug ( f \"strategy { sid } already ml-enhanced\" ) return sid sidml = f \" { sid } -ml\" if os . path . exists ( sids . path ( sidml )): logger . debug ( f \"ml strategy { sidml } already exists\" ) return sidml dbpath = bids . dbpath ( NAME ) mod = f \" { dbpath } /@@@model:default@@@/model.lgb\" strat = sids . load ( sid ) . rstrip () strat = self . mlstrat ( strat , mod ) sids . save ( sidml , strat ) logger . debug ( f \"created parametric ml strategy { sidml } inherited from { sid } : \\n { strat } \" ) return sidml","title":"template"},{"location":"api/solverpy/builder/enigma/","text":"module enigma solverpy.builder.enigma","title":"\ud83e\udd16 enigma"},{"location":"api/solverpy/builder/enigma/#module-enigma","text":"","title":"module enigma"},{"location":"api/solverpy/builder/enigma/#solverpy.builder.enigma","text":"","title":"enigma"},{"location":"api/solverpy/builder/svm/","text":"module svm solverpy.builder.svm deconflict ( xs : spmatrix , ys : ndarray ) -> tuple [ spmatrix , ndarray ] Find conflicting positive and negative samples and remove the negative ones. Source code in src/solverpy/builder/svm.py 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 def deconflict ( xs : \"spmatrix\" , ys : \"ndarray\" ) -> tuple [ \"spmatrix\" , \"ndarray\" ]: \"Find conflicting positive and negative samples and remove the negative ones.\" assert xs . shape [ 0 ] == ys . shape [ 0 ] logger . info ( \"Looking up conflicting samples.\" ) logger . debug ( \"building samples map\" ) dups = defaultdict ( list ) for i in range ( xs . shape [ 0 ]): row = xs . getrow ( i ) key = ( tuple ( row . indices ), tuple ( row . data )) dups [ key ] . append ( i ) logger . debug ( \"marking conflicting negative samples\" ) todel = set () for ids in dups . values (): if len ( ids ) < 2 : continue td = [] onepos = False for i in ids : if ys [ i ] == 0 : td . append ( i ) # mark negative indicies to be removed else : onepos = True # there is at least one positive if onepos : todel . update ( td ) logger . debug ( \"deleting marked rows\" ) keep = [ i for i in range ( xs . shape [ 0 ]) if i not in todel ] xs0 = xs [ keep ] # type: ignore ys0 = ys [ keep ] logger . info ( \" \\n \" . join ([ \"Data shape difference:\" , f \" \\t { xs . shape } --> { xs0 . shape } \" , f \" \\t { ys . shape } --> { ys0 . shape } \" , ])) return ( xs0 , ys0 )","title":"\ud83e\udd16 svm"},{"location":"api/solverpy/builder/svm/#module-svm","text":"","title":"module svm"},{"location":"api/solverpy/builder/svm/#solverpy.builder.svm","text":"","title":"svm"},{"location":"api/solverpy/builder/svm/#solverpy.builder.svm.deconflict","text":"Find conflicting positive and negative samples and remove the negative ones. Source code in src/solverpy/builder/svm.py 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 def deconflict ( xs : \"spmatrix\" , ys : \"ndarray\" ) -> tuple [ \"spmatrix\" , \"ndarray\" ]: \"Find conflicting positive and negative samples and remove the negative ones.\" assert xs . shape [ 0 ] == ys . shape [ 0 ] logger . info ( \"Looking up conflicting samples.\" ) logger . debug ( \"building samples map\" ) dups = defaultdict ( list ) for i in range ( xs . shape [ 0 ]): row = xs . getrow ( i ) key = ( tuple ( row . indices ), tuple ( row . data )) dups [ key ] . append ( i ) logger . debug ( \"marking conflicting negative samples\" ) todel = set () for ids in dups . values (): if len ( ids ) < 2 : continue td = [] onepos = False for i in ids : if ys [ i ] == 0 : td . append ( i ) # mark negative indicies to be removed else : onepos = True # there is at least one positive if onepos : todel . update ( td ) logger . debug ( \"deleting marked rows\" ) keep = [ i for i in range ( xs . shape [ 0 ]) if i not in todel ] xs0 = xs [ keep ] # type: ignore ys0 = ys [ keep ] logger . info ( \" \\n \" . join ([ \"Data shape difference:\" , f \" \\t { xs . shape } --> { xs0 . shape } \" , f \" \\t { ys . shape } --> { ys0 . shape } \" , ])) return ( xs0 , ys0 )","title":"deconflict"},{"location":"api/solverpy/builder/autotune/","text":"Autotune Overview solverpy.builder.autotune Meta-parameters tunner.","title":"\u2139\ufe0f Overview"},{"location":"api/solverpy/builder/autotune/#autotune-overview","text":"","title":"Autotune Overview"},{"location":"api/solverpy/builder/autotune/#solverpy.builder.autotune","text":"Meta-parameters tunner.","title":"autotune"},{"location":"api/solverpy/builder/autotune/autotune/","text":"module autotune solverpy.builder.autotune.autotune","title":"\ud83e\udd16 autotune"},{"location":"api/solverpy/builder/autotune/autotune/#module-autotune","text":"","title":"module autotune"},{"location":"api/solverpy/builder/autotune/autotune/#solverpy.builder.autotune.autotune","text":"","title":"autotune"},{"location":"api/solverpy/builder/autotune/build/","text":"module build solverpy.builder.autotune.build","title":"\ud83e\udd16 build"},{"location":"api/solverpy/builder/autotune/build/#module-build","text":"","title":"module build"},{"location":"api/solverpy/builder/autotune/build/#solverpy.builder.autotune.build","text":"","title":"build"},{"location":"api/solverpy/builder/autotune/check/","text":"module check solverpy.builder.autotune.check","title":"\ud83e\udd16 check"},{"location":"api/solverpy/builder/autotune/check/#module-check","text":"","title":"module check"},{"location":"api/solverpy/builder/autotune/check/#solverpy.builder.autotune.check","text":"","title":"check"},{"location":"api/solverpy/builder/autotune/listener/","text":"module listener solverpy.builder.autotune.listener","title":"\ud83e\udd16 listener"},{"location":"api/solverpy/builder/autotune/listener/#module-listener","text":"","title":"module listener"},{"location":"api/solverpy/builder/autotune/listener/#solverpy.builder.autotune.listener","text":"","title":"listener"},{"location":"api/solverpy/builder/autotune/tune/","text":"module tune solverpy.builder.autotune.tune","title":"\ud83e\udd16 tune"},{"location":"api/solverpy/builder/autotune/tune/#module-tune","text":"","title":"module tune"},{"location":"api/solverpy/builder/autotune/tune/#solverpy.builder.autotune.tune","text":"","title":"tune"},{"location":"api/solverpy/builder/plugins/","text":"Plugins Overview solverpy.builder.plugins","title":"\u2139\ufe0f Overview"},{"location":"api/solverpy/builder/plugins/#plugins-overview","text":"","title":"Plugins Overview"},{"location":"api/solverpy/builder/plugins/#solverpy.builder.plugins","text":"","title":"plugins"},{"location":"api/solverpy/builder/plugins/cvc5/","text":"module cvc5 solverpy.builder.plugins.cvc5","title":"\ud83e\udd16 cvc5"},{"location":"api/solverpy/builder/plugins/cvc5/#module-cvc5","text":"","title":"module cvc5"},{"location":"api/solverpy/builder/plugins/cvc5/#solverpy.builder.plugins.cvc5","text":"","title":"cvc5"},{"location":"api/solverpy/builder/plugins/enigma/","text":"module enigma solverpy.builder.plugins.enigma","title":"\ud83e\udd16 enigma"},{"location":"api/solverpy/builder/plugins/enigma/#module-enigma","text":"","title":"module enigma"},{"location":"api/solverpy/builder/plugins/enigma/#solverpy.builder.plugins.enigma","text":"","title":"enigma"},{"location":"api/solverpy/builder/plugins/multi/","text":"module multi solverpy.builder.plugins.multi","title":"\ud83e\udd16 multi"},{"location":"api/solverpy/builder/plugins/multi/#module-multi","text":"","title":"module multi"},{"location":"api/solverpy/builder/plugins/multi/#solverpy.builder.plugins.multi","text":"","title":"multi"},{"location":"api/solverpy/builder/plugins/svm/","text":"module svm solverpy.builder.plugins.svm","title":"\ud83e\udd16 svm"},{"location":"api/solverpy/builder/plugins/svm/#module-svm","text":"","title":"module svm"},{"location":"api/solverpy/builder/plugins/svm/#solverpy.builder.plugins.svm","text":"","title":"svm"},{"location":"api/solverpy/builder/plugins/trains/","text":"module trains solverpy.builder.plugins.trains Trains Bases: Decorator Source code in src/solverpy/builder/plugins/trains.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 class Trains ( Decorator ): def __init__ ( self , dataname : str , filename : str = \"train.in\" ): Decorator . __init__ ( self , pid = \"trains\" , dataname = dataname , filename = filename , ) self . _lock = multiprocessing . get_context ( \"spawn\" ) . Manager () . Lock () self . _enabled = True self . reset ( dataname , filename ) def enable ( self ): self . _enabled = True def disable ( self ): self . _enabled = False def reset ( self , dataname : ( str | None ) = None , filename : str = \"train.in\" , ) -> None : if dataname : self . _dataname = dataname self . _filename = filename def path ( self , dataname : ( str | None ) = None , filename : ( str | None ) = None , ) -> Any : dataname = dataname or self . _dataname filename = filename or self . _filename return os . path . join ( bids . dbpath ( NAME ), dataname , filename ) def exists ( self ) -> bool : return os . path . isfile ( self . path ()) def link ( self , src : str ): if not os . path . isfile ( src ): logger . warning ( f \"Link source not found: { src } .\" ) return rellink ( src , self . path ()) def register ( self , solver : \"SolverPy\" ) -> None : super () . register ( solver ) self . _solver = solver def finished ( self , instance : tuple [ str , str ], strategy : str , output : str , result : dict [ str , Any ], ): if not ( output and self . _solver . solved ( result )): return samples = self . extract ( instance , strategy , output , result ) self . save ( instance , strategy , samples ) def extract ( self , instance : tuple [ str , str ], strategy : str , output : str , result : dict [ str , Any ], ) -> Any : del instance , strategy , output , result # unused arguments \"Extract training samples from `output`.\" raise NotImplementedError () def save ( self , instance : tuple [ str , str ], strategy : str , samples : str , ) -> None : if ( not samples ) or ( not self . _enabled ): return self . _lock . acquire () try : os . makedirs ( os . path . dirname ( self . path ()), exist_ok = True ) with open ( self . path (), \"a\" ) as fa : fa . write ( samples ) self . stats ( instance , strategy , samples ) finally : self . _lock . release () def stats ( self , instance : tuple [ str , str ], strategy : str , samples : str , ): \"Save optional statistics.\" del instance , strategy , samples # unused arguments pass stats ( instance : tuple [ str , str ], strategy : str , samples : str ) Save optional statistics. Source code in src/solverpy/builder/plugins/trains.py 115 116 117 118 119 120 121 122 123 def stats ( self , instance : tuple [ str , str ], strategy : str , samples : str , ): \"Save optional statistics.\" del instance , strategy , samples # unused arguments pass","title":"\ud83e\udd16 trains"},{"location":"api/solverpy/builder/plugins/trains/#module-trains","text":"","title":"module trains"},{"location":"api/solverpy/builder/plugins/trains/#solverpy.builder.plugins.trains","text":"","title":"trains"},{"location":"api/solverpy/builder/plugins/trains/#solverpy.builder.plugins.trains.Trains","text":"Bases: Decorator Source code in src/solverpy/builder/plugins/trains.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 class Trains ( Decorator ): def __init__ ( self , dataname : str , filename : str = \"train.in\" ): Decorator . __init__ ( self , pid = \"trains\" , dataname = dataname , filename = filename , ) self . _lock = multiprocessing . get_context ( \"spawn\" ) . Manager () . Lock () self . _enabled = True self . reset ( dataname , filename ) def enable ( self ): self . _enabled = True def disable ( self ): self . _enabled = False def reset ( self , dataname : ( str | None ) = None , filename : str = \"train.in\" , ) -> None : if dataname : self . _dataname = dataname self . _filename = filename def path ( self , dataname : ( str | None ) = None , filename : ( str | None ) = None , ) -> Any : dataname = dataname or self . _dataname filename = filename or self . _filename return os . path . join ( bids . dbpath ( NAME ), dataname , filename ) def exists ( self ) -> bool : return os . path . isfile ( self . path ()) def link ( self , src : str ): if not os . path . isfile ( src ): logger . warning ( f \"Link source not found: { src } .\" ) return rellink ( src , self . path ()) def register ( self , solver : \"SolverPy\" ) -> None : super () . register ( solver ) self . _solver = solver def finished ( self , instance : tuple [ str , str ], strategy : str , output : str , result : dict [ str , Any ], ): if not ( output and self . _solver . solved ( result )): return samples = self . extract ( instance , strategy , output , result ) self . save ( instance , strategy , samples ) def extract ( self , instance : tuple [ str , str ], strategy : str , output : str , result : dict [ str , Any ], ) -> Any : del instance , strategy , output , result # unused arguments \"Extract training samples from `output`.\" raise NotImplementedError () def save ( self , instance : tuple [ str , str ], strategy : str , samples : str , ) -> None : if ( not samples ) or ( not self . _enabled ): return self . _lock . acquire () try : os . makedirs ( os . path . dirname ( self . path ()), exist_ok = True ) with open ( self . path (), \"a\" ) as fa : fa . write ( samples ) self . stats ( instance , strategy , samples ) finally : self . _lock . release () def stats ( self , instance : tuple [ str , str ], strategy : str , samples : str , ): \"Save optional statistics.\" del instance , strategy , samples # unused arguments pass","title":"Trains"},{"location":"api/solverpy/builder/plugins/trains/#solverpy.builder.plugins.trains.Trains.stats","text":"Save optional statistics. Source code in src/solverpy/builder/plugins/trains.py 115 116 117 118 119 120 121 122 123 def stats ( self , instance : tuple [ str , str ], strategy : str , samples : str , ): \"Save optional statistics.\" del instance , strategy , samples # unused arguments pass","title":"stats"},{"location":"api/solverpy/setups/","text":"Setups Overview solverpy.setups Setup Bases: TypedDict A (typed) dictionary summarizing the configuration of the experiment. An ordinary dictionary can be used in its place but type annotations provide additional safety. Some parameters should be set by the user, others are automatically filled in by functions in the setups module. Evaluation parameters The following are the most important parameters to be set by the user for an evaluation run: Attributes: Name Type Description limit str Resource limit for solvers. cores int Number of CPU cores for parallel evaluation. bidlist list [ str ] List of benchmark ids. sidlist list [ str ] List of strategy ids. complete bool Complete use of the solver (sat/Satisfiable are successes). The following parameters additional parameters for an evaluation run: Attributes: Name Type Description bidfile str Load benchmark ids from a file. sidfile str Load strategy ids from a file. ref bool | int | str | None Reference strategy id. binary str Custom solver binary. Must be in PATH . static list [ str ] Fixed solver options. ntfy str Address for user push notifications via ntfy . options list [ str ] Experiment boolean options. An option is identified by its string name, and represents a boolean yes/no value. Use no- option, like no-compress , to set the option to no . Currently supported options are: option description default outputs Keep raw solver output files from all runs. no compress Compress output files (outputs, trains, results). yes flatten Put all output files in a single directory (replace / with _._ ). yes compress-trains Compress trains. yes debug-trains Dump training data for each file separately. no plugins list [ Plugin ] List of additional solver plugins. delfix int | str | None Prefix to remove from problem names. If the value is of type str , then this prefix is removed from the beginning of every problem name. If the value is of type int , then the problem name is expected to be a / -separated path, and the first delfix components are removed. If the value None , nothing is removed. The typical use is to remove the prefix problems/ from problem names when the problems are stored inside problems/ subdirectory. In that case, set delfix=1 . This applies to DB providers that support delfix (e.g. Solved and Status ). The default value is None . ML parameters The following are user options for ML experiments. Attributes: Name Type Description loops int Number of iterations of the eval/ML loop. refs list [ str ] Reference strategies. force bool Recompute everything. shuffle bool Shuffle problem order. dataname str Data id for ML experiments. start_dataname str Start the looping with training instead of evaluation. max_proofs int Maximum number of proofs per problem for ML experiments. e_training_examples str Output format of training samples for eprover . gen_features str ENIGMA features for generation filtering. sel_features str ENIGMA features for clause selection. posneg_ratio float Maximum ratio of negative to positive examples. templates list [ str ] Templates for strategy generation. Internal parameters The following parameters are used internally and should not be set directly by the user. Attributes: Name Type Description it int Current iteration number. news list [ str ] New ML strategies. basedataname str Original data id. db DB Database object. builder Builder Builder object. solver SolverPy Solver object. trains SvmTrains Trains object. previous_trains str | tuple [ str ] Training data from the previous iteration. proofs dict [ str , int ] | None Count of proofs per problem. Source code in src/solverpy/setups/setup.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 class Setup ( TypedDict , total = False ): \"\"\" A (typed) dictionary summarizing the configuration of the experiment. An ordinary dictionary can be used in its place but type annotations provide additional safety. Some parameters should be set by the user, others are automatically filled in by functions in the [`setups`][solverpy.setups] module. # Evaluation parameters The following are the most important parameters to be set by the user for an evaluation run: Attributes: limit: Resource limit for solvers. cores: Number of CPU cores for parallel evaluation. bidlist: List of benchmark ids. sidlist: List of strategy ids. complete: Complete use of the solver (sat/Satisfiable are successes). The following parameters additional parameters for an evaluation run: Attributes: bidfile: Load benchmark ids from a file. sidfile: Load strategy ids from a file. ref: Reference strategy id. binary: Custom solver binary. Must be in `PATH`. static: Fixed solver options. ntfy: Address for user push notifications via [ntfy](https://ntfy.sh). options: Experiment boolean options. An *option* is identified by its string name, and represents a boolean yes/no value. Use `no-`option, like `no-compress`, to set the option to `no`. Currently supported options are: |option|description|default| |------|-----------|-------| |`outputs`|Keep raw solver output files from all runs.|no| |`compress`|Compress output files (outputs, trains, results).|yes| |`flatten`|Put all output files in a single directory (replace `/` with `_._`).|yes| |`compress-trains`|Compress trains.|yes| |`debug-trains`|Dump training data for each file separately.|no| plugins: List of additional solver plugins. delfix: Prefix to remove from problem names. + If the value is of type `str`, then this prefix is removed from the beginning of every problem name. + If the value is of type `int`, then the problem name is expected to be a `/`-separated path, and the first `delfix` components are removed. + If the value `None`, nothing is removed. The typical use is to remove the prefix `problems/` from problem names when the problems are stored inside `problems/` subdirectory. In that case, set `delfix=1`. This applies to DB providers that support `delfix` (e.g. [`Solved`][solverpy.benchmark.db.providers.solved] and [`Status`][solverpy.benchmark.db.providers.status]). The default value is `None`. # ML parameters The following are user options for ML experiments. Attributes: loops: Number of iterations of the eval/ML loop. refs: Reference strategies. force: Recompute everything. shuffle: Shuffle problem order. dataname: Data id for ML experiments. start_dataname: Start the looping with training instead of evaluation. max_proofs: Maximum number of proofs per problem for ML experiments. e_training_examples: Output format of training samples for `eprover`. gen_features: ENIGMA features for generation filtering. sel_features: ENIGMA features for clause selection. posneg_ratio: Maximum ratio of negative to positive examples. templates: Templates for strategy generation. # Internal parameters The following parameters are used internally and should not be set directly by the user. Attributes: it: Current iteration number. news: New ML strategies. basedataname: Original data id. db: Database object. builder: Builder object. solver: Solver object. trains: Trains object. previous_trains: Training data from the previous iteration. proofs: Count of proofs per problem. \"\"\" limit : str cores : int ref : ( bool | int | str | None ) bidfile : str sidfile : str bidlist : list [ str ] sidlist : list [ str ] binary : str static : list [ str ] ntfy : str it : int loops : int news : list [ str ] refs : list [ str ] options : list [ str ] delfix : ( int | str | None ) complete : bool force : bool shuffle : bool dataname : str start_dataname : str basedataname : str db : \"DB\" builder : \"Builder\" solver : \"SolverPy\" trains : \"SvmTrains\" previous_trains : str | tuple [ str ] plugins : list [ \"Plugin\" ] max_proofs : int proofs : ( dict [ str , int ] | None ) e_training_examples : str gen_features : str sel_features : str posneg_ratio : float templates : list [ str ]","title":"\u2139\ufe0f Overview"},{"location":"api/solverpy/setups/#setups-overview","text":"","title":"Setups Overview"},{"location":"api/solverpy/setups/#solverpy.setups","text":"","title":"setups"},{"location":"api/solverpy/setups/#solverpy.setups.Setup","text":"Bases: TypedDict A (typed) dictionary summarizing the configuration of the experiment. An ordinary dictionary can be used in its place but type annotations provide additional safety. Some parameters should be set by the user, others are automatically filled in by functions in the setups module.","title":"Setup"},{"location":"api/solverpy/setups/#solverpy.setups.Setup--evaluation-parameters","text":"The following are the most important parameters to be set by the user for an evaluation run: Attributes: Name Type Description limit str Resource limit for solvers. cores int Number of CPU cores for parallel evaluation. bidlist list [ str ] List of benchmark ids. sidlist list [ str ] List of strategy ids. complete bool Complete use of the solver (sat/Satisfiable are successes). The following parameters additional parameters for an evaluation run: Attributes: Name Type Description bidfile str Load benchmark ids from a file. sidfile str Load strategy ids from a file. ref bool | int | str | None Reference strategy id. binary str Custom solver binary. Must be in PATH . static list [ str ] Fixed solver options. ntfy str Address for user push notifications via ntfy . options list [ str ] Experiment boolean options. An option is identified by its string name, and represents a boolean yes/no value. Use no- option, like no-compress , to set the option to no . Currently supported options are: option description default outputs Keep raw solver output files from all runs. no compress Compress output files (outputs, trains, results). yes flatten Put all output files in a single directory (replace / with _._ ). yes compress-trains Compress trains. yes debug-trains Dump training data for each file separately. no plugins list [ Plugin ] List of additional solver plugins. delfix int | str | None Prefix to remove from problem names. If the value is of type str , then this prefix is removed from the beginning of every problem name. If the value is of type int , then the problem name is expected to be a / -separated path, and the first delfix components are removed. If the value None , nothing is removed. The typical use is to remove the prefix problems/ from problem names when the problems are stored inside problems/ subdirectory. In that case, set delfix=1 . This applies to DB providers that support delfix (e.g. Solved and Status ). The default value is None .","title":"Evaluation parameters"},{"location":"api/solverpy/setups/#solverpy.setups.Setup--ml-parameters","text":"The following are user options for ML experiments. Attributes: Name Type Description loops int Number of iterations of the eval/ML loop. refs list [ str ] Reference strategies. force bool Recompute everything. shuffle bool Shuffle problem order. dataname str Data id for ML experiments. start_dataname str Start the looping with training instead of evaluation. max_proofs int Maximum number of proofs per problem for ML experiments. e_training_examples str Output format of training samples for eprover . gen_features str ENIGMA features for generation filtering. sel_features str ENIGMA features for clause selection. posneg_ratio float Maximum ratio of negative to positive examples. templates list [ str ] Templates for strategy generation.","title":"ML parameters"},{"location":"api/solverpy/setups/#solverpy.setups.Setup--internal-parameters","text":"The following parameters are used internally and should not be set directly by the user. Attributes: Name Type Description it int Current iteration number. news list [ str ] New ML strategies. basedataname str Original data id. db DB Database object. builder Builder Builder object. solver SolverPy Solver object. trains SvmTrains Trains object. previous_trains str | tuple [ str ] Training data from the previous iteration. proofs dict [ str , int ] | None Count of proofs per problem. Source code in src/solverpy/setups/setup.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 class Setup ( TypedDict , total = False ): \"\"\" A (typed) dictionary summarizing the configuration of the experiment. An ordinary dictionary can be used in its place but type annotations provide additional safety. Some parameters should be set by the user, others are automatically filled in by functions in the [`setups`][solverpy.setups] module. # Evaluation parameters The following are the most important parameters to be set by the user for an evaluation run: Attributes: limit: Resource limit for solvers. cores: Number of CPU cores for parallel evaluation. bidlist: List of benchmark ids. sidlist: List of strategy ids. complete: Complete use of the solver (sat/Satisfiable are successes). The following parameters additional parameters for an evaluation run: Attributes: bidfile: Load benchmark ids from a file. sidfile: Load strategy ids from a file. ref: Reference strategy id. binary: Custom solver binary. Must be in `PATH`. static: Fixed solver options. ntfy: Address for user push notifications via [ntfy](https://ntfy.sh). options: Experiment boolean options. An *option* is identified by its string name, and represents a boolean yes/no value. Use `no-`option, like `no-compress`, to set the option to `no`. Currently supported options are: |option|description|default| |------|-----------|-------| |`outputs`|Keep raw solver output files from all runs.|no| |`compress`|Compress output files (outputs, trains, results).|yes| |`flatten`|Put all output files in a single directory (replace `/` with `_._`).|yes| |`compress-trains`|Compress trains.|yes| |`debug-trains`|Dump training data for each file separately.|no| plugins: List of additional solver plugins. delfix: Prefix to remove from problem names. + If the value is of type `str`, then this prefix is removed from the beginning of every problem name. + If the value is of type `int`, then the problem name is expected to be a `/`-separated path, and the first `delfix` components are removed. + If the value `None`, nothing is removed. The typical use is to remove the prefix `problems/` from problem names when the problems are stored inside `problems/` subdirectory. In that case, set `delfix=1`. This applies to DB providers that support `delfix` (e.g. [`Solved`][solverpy.benchmark.db.providers.solved] and [`Status`][solverpy.benchmark.db.providers.status]). The default value is `None`. # ML parameters The following are user options for ML experiments. Attributes: loops: Number of iterations of the eval/ML loop. refs: Reference strategies. force: Recompute everything. shuffle: Shuffle problem order. dataname: Data id for ML experiments. start_dataname: Start the looping with training instead of evaluation. max_proofs: Maximum number of proofs per problem for ML experiments. e_training_examples: Output format of training samples for `eprover`. gen_features: ENIGMA features for generation filtering. sel_features: ENIGMA features for clause selection. posneg_ratio: Maximum ratio of negative to positive examples. templates: Templates for strategy generation. # Internal parameters The following parameters are used internally and should not be set directly by the user. Attributes: it: Current iteration number. news: New ML strategies. basedataname: Original data id. db: Database object. builder: Builder object. solver: Solver object. trains: Trains object. previous_trains: Training data from the previous iteration. proofs: Count of proofs per problem. \"\"\" limit : str cores : int ref : ( bool | int | str | None ) bidfile : str sidfile : str bidlist : list [ str ] sidlist : list [ str ] binary : str static : list [ str ] ntfy : str it : int loops : int news : list [ str ] refs : list [ str ] options : list [ str ] delfix : ( int | str | None ) complete : bool force : bool shuffle : bool dataname : str start_dataname : str basedataname : str db : \"DB\" builder : \"Builder\" solver : \"SolverPy\" trains : \"SvmTrains\" previous_trains : str | tuple [ str ] plugins : list [ \"Plugin\" ] max_proofs : int proofs : ( dict [ str , int ] | None ) e_training_examples : str gen_features : str sel_features : str posneg_ratio : float templates : list [ str ]","title":"Internal parameters"},{"location":"api/solverpy/setups/common/","text":"module common solverpy.setups.common","title":"\ud83e\udd16 common"},{"location":"api/solverpy/setups/common/#module-common","text":"","title":"module common"},{"location":"api/solverpy/setups/common/#solverpy.setups.common","text":"","title":"common"},{"location":"api/solverpy/setups/loop/","text":"module loop solverpy.setups.loop","title":"\ud83e\udd16 loop"},{"location":"api/solverpy/setups/loop/#module-loop","text":"","title":"module loop"},{"location":"api/solverpy/setups/loop/#solverpy.setups.loop","text":"","title":"loop"},{"location":"api/solverpy/setups/setup/","text":"module setup solverpy.setups.setup This module defines a (typed) dictionary Setup to store experiment parameters. Setup Bases: TypedDict A (typed) dictionary summarizing the configuration of the experiment. An ordinary dictionary can be used in its place but type annotations provide additional safety. Some parameters should be set by the user, others are automatically filled in by functions in the setups module. Evaluation parameters The following are the most important parameters to be set by the user for an evaluation run: Attributes: Name Type Description limit str Resource limit for solvers. cores int Number of CPU cores for parallel evaluation. bidlist list [ str ] List of benchmark ids. sidlist list [ str ] List of strategy ids. complete bool Complete use of the solver (sat/Satisfiable are successes). The following parameters additional parameters for an evaluation run: Attributes: Name Type Description bidfile str Load benchmark ids from a file. sidfile str Load strategy ids from a file. ref bool | int | str | None Reference strategy id. binary str Custom solver binary. Must be in PATH . static list [ str ] Fixed solver options. ntfy str Address for user push notifications via ntfy . options list [ str ] Experiment boolean options. An option is identified by its string name, and represents a boolean yes/no value. Use no- option, like no-compress , to set the option to no . Currently supported options are: option description default outputs Keep raw solver output files from all runs. no compress Compress output files (outputs, trains, results). yes flatten Put all output files in a single directory (replace / with _._ ). yes compress-trains Compress trains. yes debug-trains Dump training data for each file separately. no plugins list [ Plugin ] List of additional solver plugins. delfix int | str | None Prefix to remove from problem names. If the value is of type str , then this prefix is removed from the beginning of every problem name. If the value is of type int , then the problem name is expected to be a / -separated path, and the first delfix components are removed. If the value None , nothing is removed. The typical use is to remove the prefix problems/ from problem names when the problems are stored inside problems/ subdirectory. In that case, set delfix=1 . This applies to DB providers that support delfix (e.g. Solved and Status ). The default value is None . ML parameters The following are user options for ML experiments. Attributes: Name Type Description loops int Number of iterations of the eval/ML loop. refs list [ str ] Reference strategies. force bool Recompute everything. shuffle bool Shuffle problem order. dataname str Data id for ML experiments. start_dataname str Start the looping with training instead of evaluation. max_proofs int Maximum number of proofs per problem for ML experiments. e_training_examples str Output format of training samples for eprover . gen_features str ENIGMA features for generation filtering. sel_features str ENIGMA features for clause selection. posneg_ratio float Maximum ratio of negative to positive examples. templates list [ str ] Templates for strategy generation. Internal parameters The following parameters are used internally and should not be set directly by the user. Attributes: Name Type Description it int Current iteration number. news list [ str ] New ML strategies. basedataname str Original data id. db DB Database object. builder Builder Builder object. solver SolverPy Solver object. trains SvmTrains Trains object. previous_trains str | tuple [ str ] Training data from the previous iteration. proofs dict [ str , int ] | None Count of proofs per problem. Source code in src/solverpy/setups/setup.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 class Setup ( TypedDict , total = False ): \"\"\" A (typed) dictionary summarizing the configuration of the experiment. An ordinary dictionary can be used in its place but type annotations provide additional safety. Some parameters should be set by the user, others are automatically filled in by functions in the [`setups`][solverpy.setups] module. # Evaluation parameters The following are the most important parameters to be set by the user for an evaluation run: Attributes: limit: Resource limit for solvers. cores: Number of CPU cores for parallel evaluation. bidlist: List of benchmark ids. sidlist: List of strategy ids. complete: Complete use of the solver (sat/Satisfiable are successes). The following parameters additional parameters for an evaluation run: Attributes: bidfile: Load benchmark ids from a file. sidfile: Load strategy ids from a file. ref: Reference strategy id. binary: Custom solver binary. Must be in `PATH`. static: Fixed solver options. ntfy: Address for user push notifications via [ntfy](https://ntfy.sh). options: Experiment boolean options. An *option* is identified by its string name, and represents a boolean yes/no value. Use `no-`option, like `no-compress`, to set the option to `no`. Currently supported options are: |option|description|default| |------|-----------|-------| |`outputs`|Keep raw solver output files from all runs.|no| |`compress`|Compress output files (outputs, trains, results).|yes| |`flatten`|Put all output files in a single directory (replace `/` with `_._`).|yes| |`compress-trains`|Compress trains.|yes| |`debug-trains`|Dump training data for each file separately.|no| plugins: List of additional solver plugins. delfix: Prefix to remove from problem names. + If the value is of type `str`, then this prefix is removed from the beginning of every problem name. + If the value is of type `int`, then the problem name is expected to be a `/`-separated path, and the first `delfix` components are removed. + If the value `None`, nothing is removed. The typical use is to remove the prefix `problems/` from problem names when the problems are stored inside `problems/` subdirectory. In that case, set `delfix=1`. This applies to DB providers that support `delfix` (e.g. [`Solved`][solverpy.benchmark.db.providers.solved] and [`Status`][solverpy.benchmark.db.providers.status]). The default value is `None`. # ML parameters The following are user options for ML experiments. Attributes: loops: Number of iterations of the eval/ML loop. refs: Reference strategies. force: Recompute everything. shuffle: Shuffle problem order. dataname: Data id for ML experiments. start_dataname: Start the looping with training instead of evaluation. max_proofs: Maximum number of proofs per problem for ML experiments. e_training_examples: Output format of training samples for `eprover`. gen_features: ENIGMA features for generation filtering. sel_features: ENIGMA features for clause selection. posneg_ratio: Maximum ratio of negative to positive examples. templates: Templates for strategy generation. # Internal parameters The following parameters are used internally and should not be set directly by the user. Attributes: it: Current iteration number. news: New ML strategies. basedataname: Original data id. db: Database object. builder: Builder object. solver: Solver object. trains: Trains object. previous_trains: Training data from the previous iteration. proofs: Count of proofs per problem. \"\"\" limit : str cores : int ref : ( bool | int | str | None ) bidfile : str sidfile : str bidlist : list [ str ] sidlist : list [ str ] binary : str static : list [ str ] ntfy : str it : int loops : int news : list [ str ] refs : list [ str ] options : list [ str ] delfix : ( int | str | None ) complete : bool force : bool shuffle : bool dataname : str start_dataname : str basedataname : str db : \"DB\" builder : \"Builder\" solver : \"SolverPy\" trains : \"SvmTrains\" previous_trains : str | tuple [ str ] plugins : list [ \"Plugin\" ] max_proofs : int proofs : ( dict [ str , int ] | None ) e_training_examples : str gen_features : str sel_features : str posneg_ratio : float templates : list [ str ]","title":"\ud83e\udd16 setup"},{"location":"api/solverpy/setups/setup/#module-setup","text":"","title":"module setup"},{"location":"api/solverpy/setups/setup/#solverpy.setups.setup","text":"This module defines a (typed) dictionary Setup to store experiment parameters.","title":"setup"},{"location":"api/solverpy/setups/setup/#solverpy.setups.setup.Setup","text":"Bases: TypedDict A (typed) dictionary summarizing the configuration of the experiment. An ordinary dictionary can be used in its place but type annotations provide additional safety. Some parameters should be set by the user, others are automatically filled in by functions in the setups module.","title":"Setup"},{"location":"api/solverpy/setups/setup/#solverpy.setups.setup.Setup--evaluation-parameters","text":"The following are the most important parameters to be set by the user for an evaluation run: Attributes: Name Type Description limit str Resource limit for solvers. cores int Number of CPU cores for parallel evaluation. bidlist list [ str ] List of benchmark ids. sidlist list [ str ] List of strategy ids. complete bool Complete use of the solver (sat/Satisfiable are successes). The following parameters additional parameters for an evaluation run: Attributes: Name Type Description bidfile str Load benchmark ids from a file. sidfile str Load strategy ids from a file. ref bool | int | str | None Reference strategy id. binary str Custom solver binary. Must be in PATH . static list [ str ] Fixed solver options. ntfy str Address for user push notifications via ntfy . options list [ str ] Experiment boolean options. An option is identified by its string name, and represents a boolean yes/no value. Use no- option, like no-compress , to set the option to no . Currently supported options are: option description default outputs Keep raw solver output files from all runs. no compress Compress output files (outputs, trains, results). yes flatten Put all output files in a single directory (replace / with _._ ). yes compress-trains Compress trains. yes debug-trains Dump training data for each file separately. no plugins list [ Plugin ] List of additional solver plugins. delfix int | str | None Prefix to remove from problem names. If the value is of type str , then this prefix is removed from the beginning of every problem name. If the value is of type int , then the problem name is expected to be a / -separated path, and the first delfix components are removed. If the value None , nothing is removed. The typical use is to remove the prefix problems/ from problem names when the problems are stored inside problems/ subdirectory. In that case, set delfix=1 . This applies to DB providers that support delfix (e.g. Solved and Status ). The default value is None .","title":"Evaluation parameters"},{"location":"api/solverpy/setups/setup/#solverpy.setups.setup.Setup--ml-parameters","text":"The following are user options for ML experiments. Attributes: Name Type Description loops int Number of iterations of the eval/ML loop. refs list [ str ] Reference strategies. force bool Recompute everything. shuffle bool Shuffle problem order. dataname str Data id for ML experiments. start_dataname str Start the looping with training instead of evaluation. max_proofs int Maximum number of proofs per problem for ML experiments. e_training_examples str Output format of training samples for eprover . gen_features str ENIGMA features for generation filtering. sel_features str ENIGMA features for clause selection. posneg_ratio float Maximum ratio of negative to positive examples. templates list [ str ] Templates for strategy generation.","title":"ML parameters"},{"location":"api/solverpy/setups/setup/#solverpy.setups.setup.Setup--internal-parameters","text":"The following parameters are used internally and should not be set directly by the user. Attributes: Name Type Description it int Current iteration number. news list [ str ] New ML strategies. basedataname str Original data id. db DB Database object. builder Builder Builder object. solver SolverPy Solver object. trains SvmTrains Trains object. previous_trains str | tuple [ str ] Training data from the previous iteration. proofs dict [ str , int ] | None Count of proofs per problem. Source code in src/solverpy/setups/setup.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 class Setup ( TypedDict , total = False ): \"\"\" A (typed) dictionary summarizing the configuration of the experiment. An ordinary dictionary can be used in its place but type annotations provide additional safety. Some parameters should be set by the user, others are automatically filled in by functions in the [`setups`][solverpy.setups] module. # Evaluation parameters The following are the most important parameters to be set by the user for an evaluation run: Attributes: limit: Resource limit for solvers. cores: Number of CPU cores for parallel evaluation. bidlist: List of benchmark ids. sidlist: List of strategy ids. complete: Complete use of the solver (sat/Satisfiable are successes). The following parameters additional parameters for an evaluation run: Attributes: bidfile: Load benchmark ids from a file. sidfile: Load strategy ids from a file. ref: Reference strategy id. binary: Custom solver binary. Must be in `PATH`. static: Fixed solver options. ntfy: Address for user push notifications via [ntfy](https://ntfy.sh). options: Experiment boolean options. An *option* is identified by its string name, and represents a boolean yes/no value. Use `no-`option, like `no-compress`, to set the option to `no`. Currently supported options are: |option|description|default| |------|-----------|-------| |`outputs`|Keep raw solver output files from all runs.|no| |`compress`|Compress output files (outputs, trains, results).|yes| |`flatten`|Put all output files in a single directory (replace `/` with `_._`).|yes| |`compress-trains`|Compress trains.|yes| |`debug-trains`|Dump training data for each file separately.|no| plugins: List of additional solver plugins. delfix: Prefix to remove from problem names. + If the value is of type `str`, then this prefix is removed from the beginning of every problem name. + If the value is of type `int`, then the problem name is expected to be a `/`-separated path, and the first `delfix` components are removed. + If the value `None`, nothing is removed. The typical use is to remove the prefix `problems/` from problem names when the problems are stored inside `problems/` subdirectory. In that case, set `delfix=1`. This applies to DB providers that support `delfix` (e.g. [`Solved`][solverpy.benchmark.db.providers.solved] and [`Status`][solverpy.benchmark.db.providers.status]). The default value is `None`. # ML parameters The following are user options for ML experiments. Attributes: loops: Number of iterations of the eval/ML loop. refs: Reference strategies. force: Recompute everything. shuffle: Shuffle problem order. dataname: Data id for ML experiments. start_dataname: Start the looping with training instead of evaluation. max_proofs: Maximum number of proofs per problem for ML experiments. e_training_examples: Output format of training samples for `eprover`. gen_features: ENIGMA features for generation filtering. sel_features: ENIGMA features for clause selection. posneg_ratio: Maximum ratio of negative to positive examples. templates: Templates for strategy generation. # Internal parameters The following parameters are used internally and should not be set directly by the user. Attributes: it: Current iteration number. news: New ML strategies. basedataname: Original data id. db: Database object. builder: Builder object. solver: Solver object. trains: Trains object. previous_trains: Training data from the previous iteration. proofs: Count of proofs per problem. \"\"\" limit : str cores : int ref : ( bool | int | str | None ) bidfile : str sidfile : str bidlist : list [ str ] sidlist : list [ str ] binary : str static : list [ str ] ntfy : str it : int loops : int news : list [ str ] refs : list [ str ] options : list [ str ] delfix : ( int | str | None ) complete : bool force : bool shuffle : bool dataname : str start_dataname : str basedataname : str db : \"DB\" builder : \"Builder\" solver : \"SolverPy\" trains : \"SvmTrains\" previous_trains : str | tuple [ str ] plugins : list [ \"Plugin\" ] max_proofs : int proofs : ( dict [ str , int ] | None ) e_training_examples : str gen_features : str sel_features : str posneg_ratio : float templates : list [ str ]","title":"Internal parameters"},{"location":"api/solverpy/setups/solver/","text":"module solver solverpy.setups.solver","title":"\ud83e\udd16 solver"},{"location":"api/solverpy/setups/solver/#module-solver","text":"","title":"module solver"},{"location":"api/solverpy/setups/solver/#solverpy.setups.solver","text":"","title":"solver"},{"location":"api/solverpy/setups/tuner/","text":"module tuner solverpy.setups.tuner","title":"\ud83e\udd16 tuner"},{"location":"api/solverpy/setups/tuner/#module-tuner","text":"","title":"module tuner"},{"location":"api/solverpy/setups/tuner/#solverpy.setups.tuner","text":"","title":"tuner"},{"location":"api/solverpy/solver/","text":"Solver Overview solverpy.solver Single problem solving To call the solver on one problem instance, start by creating the solver object. from solverpy.solver.smt.cvc5 import Cvc5 cvc5 = Cvc5 ( \"T5\" ) # time limit of 5 seconds The constructor argument is a resource limit string, in this case, a time limit T in seconds. All solvers support T and additional resource limits might be available depending on the solver. Multiple resource limits can be used (separated by - , like T10-R50000 ). The limit string must, however, always start with T . Then call the solve method: result = cvc5 . solve ( \"myproblem.smt2\" , \"--enum-inst\" ) The first argument is the problem filename, the second is the solver-dependent strategy description (typically command line options as a string). The result is a Python dict with results and statistics. The keys and values are solver-specific. Nevertheless, the result always contains keys status (with the value of type str ) and runtime (type float ). Hint: Call cvc5.run(p,s) instead of cvc5.solve(p,s) to get the raw solver output without any processing. Call cvc5.command(p,s) to output the shell command that is going to be executed to launch the solver.","title":"\u2139\ufe0f Overview"},{"location":"api/solverpy/solver/#solver-overview","text":"","title":"Solver Overview"},{"location":"api/solverpy/solver/#solverpy.solver","text":"","title":"solver"},{"location":"api/solverpy/solver/#solverpy.solver--single-problem-solving","text":"To call the solver on one problem instance, start by creating the solver object. from solverpy.solver.smt.cvc5 import Cvc5 cvc5 = Cvc5 ( \"T5\" ) # time limit of 5 seconds The constructor argument is a resource limit string, in this case, a time limit T in seconds. All solvers support T and additional resource limits might be available depending on the solver. Multiple resource limits can be used (separated by - , like T10-R50000 ). The limit string must, however, always start with T . Then call the solve method: result = cvc5 . solve ( \"myproblem.smt2\" , \"--enum-inst\" ) The first argument is the problem filename, the second is the solver-dependent strategy description (typically command line options as a string). The result is a Python dict with results and statistics. The keys and values are solver-specific. Nevertheless, the result always contains keys status (with the value of type str ) and runtime (type float ). Hint: Call cvc5.run(p,s) instead of cvc5.solve(p,s) to get the raw solver output without any processing. Call cvc5.command(p,s) to output the shell command that is going to be executed to launch the solver.","title":"Single problem solving"},{"location":"api/solverpy/solver/object/","text":"module object solverpy.solver.object SolverPyObj Source code in src/solverpy/solver/object.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class SolverPyObj : def __init__ ( self , cls_name : ( str | None ) = None , ** kwargs : Any , ): self . _repr_args : dict [ str , Any ] = dict ( kwargs ) self . _cls_name = cls_name or self . __class__ . __name__ def __repr__ ( self ) -> str : if hasattr ( self , \"_repr_args\" ) and self . _repr_args is not None : ias = [ f \" { x } = { y } \" for ( x , y ) in self . _repr_args . items ()] ias = \",\" . join ( sorted ( ias )) return f \" { self . _cls_name } ( { ias } )\" return object . __repr__ ( self ) def represent ( self ) -> ( str | list [ Any ] | dict [ str , Any ]): \"\"\"Default yaml represeneter\"\"\" return repr ( self ) represent () -> str | list [ Any ] | dict [ str , Any ] Default yaml represeneter Source code in src/solverpy/solver/object.py 24 25 26 def represent ( self ) -> ( str | list [ Any ] | dict [ str , Any ]): \"\"\"Default yaml represeneter\"\"\" return repr ( self )","title":"\ud83e\udd16 object"},{"location":"api/solverpy/solver/object/#module-object","text":"","title":"module object"},{"location":"api/solverpy/solver/object/#solverpy.solver.object","text":"","title":"object"},{"location":"api/solverpy/solver/object/#solverpy.solver.object.SolverPyObj","text":"Source code in src/solverpy/solver/object.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class SolverPyObj : def __init__ ( self , cls_name : ( str | None ) = None , ** kwargs : Any , ): self . _repr_args : dict [ str , Any ] = dict ( kwargs ) self . _cls_name = cls_name or self . __class__ . __name__ def __repr__ ( self ) -> str : if hasattr ( self , \"_repr_args\" ) and self . _repr_args is not None : ias = [ f \" { x } = { y } \" for ( x , y ) in self . _repr_args . items ()] ias = \",\" . join ( sorted ( ias )) return f \" { self . _cls_name } ( { ias } )\" return object . __repr__ ( self ) def represent ( self ) -> ( str | list [ Any ] | dict [ str , Any ]): \"\"\"Default yaml represeneter\"\"\" return repr ( self )","title":"SolverPyObj"},{"location":"api/solverpy/solver/object/#solverpy.solver.object.SolverPyObj.represent","text":"Default yaml represeneter Source code in src/solverpy/solver/object.py 24 25 26 def represent ( self ) -> ( str | list [ Any ] | dict [ str , Any ]): \"\"\"Default yaml represeneter\"\"\" return repr ( self )","title":"represent"},{"location":"api/solverpy/solver/pluginsolver/","text":"module pluginsolver solverpy.solver.pluginsolver Solver extension plugins The class PluginSolver extends Solver to add support for plugins. Plugin 's can extend or modify the behavior of the solver. There are two types of plugins: decorators and translators . Decorator 's are used to modify the command and the output result of the solver. Typically decorators are used to add timing information to the solver output, and parse standardized solver output, like TPTP or SMT2. Translator 's are used to translate the instance and strategy for the Solver.solve method, for example, translating a benchmark-problem pair to a filename. A single solver can register multiple plugins. The order of registration might matter. The basic abstract class for plugins is Plugin . For more on plugins, check the plugins module. The direct superclass of PluginSolver is SolverPy which adds database support. PluginSolver Bases: Solver Source code in src/solverpy/solver/pluginsolver.py 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 class PluginSolver ( Solver ): \"\"\" ```plantuml name=\"solver-pluginsolver\" abstract class solverpy.solver.solver.Solver abstract class solverpy.solver.pluginsolver.PluginSolver extends solverpy.solver.solver.Solver { # decorators : list[Decorator] # translators : list[Translator] + init(plugins) + decorate(cmd, instance, strategy) : str + translate(instance, strategy) : tuple + update(instance, strategy, output, result) + call(pid, method, arguments) } abstract class solverpy.solver.solverpy.SolverPy extends solverpy.solver.pluginsolver.PluginSolver ``` \"\"\" def __init__ ( self , plugins : list [ \"Plugin\" ] = [], ** kwargs : Any ): Solver . __init__ ( self , ** kwargs ) self . decorators : list [ \"Decorator\" ] = [] self . translators : list [ \"Translator\" ] = [] self . init ( plugins ) def represent ( self ): return dict ( cls = self . name , decorators = [ repr ( x ) for x in self . decorators ], translators = [ repr ( x ) for x in self . translators ], ) def solve ( self , instance : Any , strategy : Any ) -> \"Result\" : \"\"\" Run the solver with the strategy on the instatance. Update the solver result and announce the final version. Return the updated result. \"\"\" result = Solver . solve ( self , instance , strategy ) output = self . _output self . update ( instance , strategy , output , result ) if not self . valid ( result ): lines = output . split ( \" \\n \" ) if len ( lines ) > 3 : msg = f \" { lines [ 2 ] } \\n { lines [ 3 ] } \" # command and first output line else : msg = output logger . debug ( f \"failed solver run: { self } : { strategy } @ { instance } \\n result: { result } \\n { msg } \" ) return result def init ( self , plugins : list [ \"Plugin\" ]) -> None : \"\"\"Plugins initialization.\"\"\" for plugin in plugins : plugin . register ( self ) def decorate ( self , cmd : str , instance : Any , strategy : Any , ) -> str : \"\"\"Decorate the command for the solver.\"\"\" for plugin in self . decorators : cmd = plugin . decorate ( cmd , instance , strategy ) return cmd def update ( self , instance : Any , strategy : Any , output : str , result : \"Result\" , ) -> None : \"\"\"Update the solver result and announce the final version.\"\"\" for plugin in self . decorators : plugin . update ( instance , strategy , output , result ) for plugin in self . decorators : plugin . finished ( instance , strategy , output , result ) def translate ( self , instance : Any , strategy : Any , ) -> tuple [ Any , Any ]: \"\"\"Translate the instance and strategy for the solver.\"\"\" for plugin in self . translators : ( instance , strategy ) = plugin . translate ( instance , strategy ) return ( instance , strategy ) def call ( self , pid : str , method : str , * args , ** kwargs , ): \"\"\"Call `method` of the plugin(s) `pid`.\"\"\" for plugin in self . translators + self . decorators : if ( plugin . id == pid ): if hasattr ( plugin , method ): handler = getattr ( plugin , method ) handler ( * args , ** kwargs ) else : logger . warning ( f \"Unknown method { method } of plugin { pid } \" ) call ( pid : str , method : str , * args , ** kwargs ) Call method of the plugin(s) pid . Source code in src/solverpy/solver/pluginsolver.py 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 def call ( self , pid : str , method : str , * args , ** kwargs , ): \"\"\"Call `method` of the plugin(s) `pid`.\"\"\" for plugin in self . translators + self . decorators : if ( plugin . id == pid ): if hasattr ( plugin , method ): handler = getattr ( plugin , method ) handler ( * args , ** kwargs ) else : logger . warning ( f \"Unknown method { method } of plugin { pid } \" ) decorate ( cmd : str , instance : Any , strategy : Any ) -> str Decorate the command for the solver. Source code in src/solverpy/solver/pluginsolver.py 119 120 121 122 123 124 125 126 127 128 def decorate ( self , cmd : str , instance : Any , strategy : Any , ) -> str : \"\"\"Decorate the command for the solver.\"\"\" for plugin in self . decorators : cmd = plugin . decorate ( cmd , instance , strategy ) return cmd init ( plugins : list [ Plugin ]) -> None Plugins initialization. Source code in src/solverpy/solver/pluginsolver.py 114 115 116 117 def init ( self , plugins : list [ \"Plugin\" ]) -> None : \"\"\"Plugins initialization.\"\"\" for plugin in plugins : plugin . register ( self ) solve ( instance : Any , strategy : Any ) -> Result Run the solver with the strategy on the instatance. Update the solver result and announce the final version. Return the updated result. Source code in src/solverpy/solver/pluginsolver.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 def solve ( self , instance : Any , strategy : Any ) -> \"Result\" : \"\"\" Run the solver with the strategy on the instatance. Update the solver result and announce the final version. Return the updated result. \"\"\" result = Solver . solve ( self , instance , strategy ) output = self . _output self . update ( instance , strategy , output , result ) if not self . valid ( result ): lines = output . split ( \" \\n \" ) if len ( lines ) > 3 : msg = f \" { lines [ 2 ] } \\n { lines [ 3 ] } \" # command and first output line else : msg = output logger . debug ( f \"failed solver run: { self } : { strategy } @ { instance } \\n result: { result } \\n { msg } \" ) return result translate ( instance : Any , strategy : Any ) -> tuple [ Any , Any ] Translate the instance and strategy for the solver. Source code in src/solverpy/solver/pluginsolver.py 143 144 145 146 147 148 149 150 151 def translate ( self , instance : Any , strategy : Any , ) -> tuple [ Any , Any ]: \"\"\"Translate the instance and strategy for the solver.\"\"\" for plugin in self . translators : ( instance , strategy ) = plugin . translate ( instance , strategy ) return ( instance , strategy ) update ( instance : Any , strategy : Any , output : str , result : Result ) -> None Update the solver result and announce the final version. Source code in src/solverpy/solver/pluginsolver.py 130 131 132 133 134 135 136 137 138 139 140 141 def update ( self , instance : Any , strategy : Any , output : str , result : \"Result\" , ) -> None : \"\"\"Update the solver result and announce the final version.\"\"\" for plugin in self . decorators : plugin . update ( instance , strategy , output , result ) for plugin in self . decorators : plugin . finished ( instance , strategy , output , result )","title":"\ud83e\udd16 pluginsolver"},{"location":"api/solverpy/solver/pluginsolver/#module-pluginsolver","text":"","title":"module pluginsolver"},{"location":"api/solverpy/solver/pluginsolver/#solverpy.solver.pluginsolver","text":"","title":"pluginsolver"},{"location":"api/solverpy/solver/pluginsolver/#solverpy.solver.pluginsolver--solver-extension-plugins","text":"The class PluginSolver extends Solver to add support for plugins. Plugin 's can extend or modify the behavior of the solver. There are two types of plugins: decorators and translators . Decorator 's are used to modify the command and the output result of the solver. Typically decorators are used to add timing information to the solver output, and parse standardized solver output, like TPTP or SMT2. Translator 's are used to translate the instance and strategy for the Solver.solve method, for example, translating a benchmark-problem pair to a filename. A single solver can register multiple plugins. The order of registration might matter. The basic abstract class for plugins is Plugin . For more on plugins, check the plugins module. The direct superclass of PluginSolver is SolverPy which adds database support.","title":"Solver extension plugins"},{"location":"api/solverpy/solver/pluginsolver/#solverpy.solver.pluginsolver.PluginSolver","text":"Bases: Solver Source code in src/solverpy/solver/pluginsolver.py 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 class PluginSolver ( Solver ): \"\"\" ```plantuml name=\"solver-pluginsolver\" abstract class solverpy.solver.solver.Solver abstract class solverpy.solver.pluginsolver.PluginSolver extends solverpy.solver.solver.Solver { # decorators : list[Decorator] # translators : list[Translator] + init(plugins) + decorate(cmd, instance, strategy) : str + translate(instance, strategy) : tuple + update(instance, strategy, output, result) + call(pid, method, arguments) } abstract class solverpy.solver.solverpy.SolverPy extends solverpy.solver.pluginsolver.PluginSolver ``` \"\"\" def __init__ ( self , plugins : list [ \"Plugin\" ] = [], ** kwargs : Any ): Solver . __init__ ( self , ** kwargs ) self . decorators : list [ \"Decorator\" ] = [] self . translators : list [ \"Translator\" ] = [] self . init ( plugins ) def represent ( self ): return dict ( cls = self . name , decorators = [ repr ( x ) for x in self . decorators ], translators = [ repr ( x ) for x in self . translators ], ) def solve ( self , instance : Any , strategy : Any ) -> \"Result\" : \"\"\" Run the solver with the strategy on the instatance. Update the solver result and announce the final version. Return the updated result. \"\"\" result = Solver . solve ( self , instance , strategy ) output = self . _output self . update ( instance , strategy , output , result ) if not self . valid ( result ): lines = output . split ( \" \\n \" ) if len ( lines ) > 3 : msg = f \" { lines [ 2 ] } \\n { lines [ 3 ] } \" # command and first output line else : msg = output logger . debug ( f \"failed solver run: { self } : { strategy } @ { instance } \\n result: { result } \\n { msg } \" ) return result def init ( self , plugins : list [ \"Plugin\" ]) -> None : \"\"\"Plugins initialization.\"\"\" for plugin in plugins : plugin . register ( self ) def decorate ( self , cmd : str , instance : Any , strategy : Any , ) -> str : \"\"\"Decorate the command for the solver.\"\"\" for plugin in self . decorators : cmd = plugin . decorate ( cmd , instance , strategy ) return cmd def update ( self , instance : Any , strategy : Any , output : str , result : \"Result\" , ) -> None : \"\"\"Update the solver result and announce the final version.\"\"\" for plugin in self . decorators : plugin . update ( instance , strategy , output , result ) for plugin in self . decorators : plugin . finished ( instance , strategy , output , result ) def translate ( self , instance : Any , strategy : Any , ) -> tuple [ Any , Any ]: \"\"\"Translate the instance and strategy for the solver.\"\"\" for plugin in self . translators : ( instance , strategy ) = plugin . translate ( instance , strategy ) return ( instance , strategy ) def call ( self , pid : str , method : str , * args , ** kwargs , ): \"\"\"Call `method` of the plugin(s) `pid`.\"\"\" for plugin in self . translators + self . decorators : if ( plugin . id == pid ): if hasattr ( plugin , method ): handler = getattr ( plugin , method ) handler ( * args , ** kwargs ) else : logger . warning ( f \"Unknown method { method } of plugin { pid } \" )","title":"PluginSolver"},{"location":"api/solverpy/solver/pluginsolver/#solverpy.solver.pluginsolver.PluginSolver.call","text":"Call method of the plugin(s) pid . Source code in src/solverpy/solver/pluginsolver.py 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 def call ( self , pid : str , method : str , * args , ** kwargs , ): \"\"\"Call `method` of the plugin(s) `pid`.\"\"\" for plugin in self . translators + self . decorators : if ( plugin . id == pid ): if hasattr ( plugin , method ): handler = getattr ( plugin , method ) handler ( * args , ** kwargs ) else : logger . warning ( f \"Unknown method { method } of plugin { pid } \" )","title":"call"},{"location":"api/solverpy/solver/pluginsolver/#solverpy.solver.pluginsolver.PluginSolver.decorate","text":"Decorate the command for the solver. Source code in src/solverpy/solver/pluginsolver.py 119 120 121 122 123 124 125 126 127 128 def decorate ( self , cmd : str , instance : Any , strategy : Any , ) -> str : \"\"\"Decorate the command for the solver.\"\"\" for plugin in self . decorators : cmd = plugin . decorate ( cmd , instance , strategy ) return cmd","title":"decorate"},{"location":"api/solverpy/solver/pluginsolver/#solverpy.solver.pluginsolver.PluginSolver.init","text":"Plugins initialization. Source code in src/solverpy/solver/pluginsolver.py 114 115 116 117 def init ( self , plugins : list [ \"Plugin\" ]) -> None : \"\"\"Plugins initialization.\"\"\" for plugin in plugins : plugin . register ( self )","title":"init"},{"location":"api/solverpy/solver/pluginsolver/#solverpy.solver.pluginsolver.PluginSolver.solve","text":"Run the solver with the strategy on the instatance. Update the solver result and announce the final version. Return the updated result. Source code in src/solverpy/solver/pluginsolver.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 def solve ( self , instance : Any , strategy : Any ) -> \"Result\" : \"\"\" Run the solver with the strategy on the instatance. Update the solver result and announce the final version. Return the updated result. \"\"\" result = Solver . solve ( self , instance , strategy ) output = self . _output self . update ( instance , strategy , output , result ) if not self . valid ( result ): lines = output . split ( \" \\n \" ) if len ( lines ) > 3 : msg = f \" { lines [ 2 ] } \\n { lines [ 3 ] } \" # command and first output line else : msg = output logger . debug ( f \"failed solver run: { self } : { strategy } @ { instance } \\n result: { result } \\n { msg } \" ) return result","title":"solve"},{"location":"api/solverpy/solver/pluginsolver/#solverpy.solver.pluginsolver.PluginSolver.translate","text":"Translate the instance and strategy for the solver. Source code in src/solverpy/solver/pluginsolver.py 143 144 145 146 147 148 149 150 151 def translate ( self , instance : Any , strategy : Any , ) -> tuple [ Any , Any ]: \"\"\"Translate the instance and strategy for the solver.\"\"\" for plugin in self . translators : ( instance , strategy ) = plugin . translate ( instance , strategy ) return ( instance , strategy )","title":"translate"},{"location":"api/solverpy/solver/pluginsolver/#solverpy.solver.pluginsolver.PluginSolver.update","text":"Update the solver result and announce the final version. Source code in src/solverpy/solver/pluginsolver.py 130 131 132 133 134 135 136 137 138 139 140 141 def update ( self , instance : Any , strategy : Any , output : str , result : \"Result\" , ) -> None : \"\"\"Update the solver result and announce the final version.\"\"\" for plugin in self . decorators : plugin . update ( instance , strategy , output , result ) for plugin in self . decorators : plugin . finished ( instance , strategy , output , result )","title":"update"},{"location":"api/solverpy/solver/reloader/","text":"module reloader solverpy.solver.reloader","title":"\ud83e\udd16 reloader"},{"location":"api/solverpy/solver/reloader/#module-reloader","text":"","title":"module reloader"},{"location":"api/solverpy/solver/reloader/#solverpy.solver.reloader","text":"","title":"reloader"},{"location":"api/solverpy/solver/shellsolver/","text":"module shellsolver solverpy.solver.shellsolver","title":"\ud83e\udd16 shellsolver"},{"location":"api/solverpy/solver/shellsolver/#module-shellsolver","text":"","title":"module shellsolver"},{"location":"api/solverpy/solver/shellsolver/#solverpy.solver.shellsolver","text":"","title":"shellsolver"},{"location":"api/solverpy/solver/solver/","text":"module solver solverpy.solver.solver Abstract solver interface The class Solver encapsulates the very basic solver functionality --- solving a single problem instance and processing the output. The class defines solver-specific set of statuses, which are typically strings representing TPTP statuses (like Theorem , Unsatisfiable , etc), or SMT statuses (like sat , unsat , etc). The main method solve runs the solver and returns a processed result. The result is the SolverPy Result dictionary containing at least keys status and runtime . Although the result can contain solver-specific keys, the basic result structure is shared between all solvers. This makes the result comparable between solvers. The plugin functionality is added in the superclass class PluginSolver . Solver Bases: SolverPyObj Base abstract class for all solvers encapsulating the very basic solver functionality. The implementing class must provide the set of statuses, and implement methods run and process which run the solver on a single problem instance and process the solver output. The main method is solve which calls the solver on a problem instance and returns a processed result --- by default it calls run and process in sequence. Result query methods valid and solved are implemented to recognize a valid and successfully solved results. The values of instance and strategy in solve are completely solver-specific at this level. The Result is, however, always a dictionary guaranteed to contain at least the keys status and runtime . The value of status is one of statuses and the value of runtime is the solver runtime in seconds. The statuses are also solver-specific. The set success contains all successful statuses, and similarly timeouts contains timeouting statuses. Both sets timeouts and success are expected to be subsets of statuses which contain all valid statuses. Source code in src/solverpy/solver/solver.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 class Solver ( SolverPyObj ): \"\"\" Base abstract class for all solvers encapsulating the very basic solver functionality. The implementing class must provide the set of statuses, and implement methods [`run`][solverpy.solver.solver.Solver.run] and [`process`][solverpy.solver.solver.Solver.process] which run the solver on a single problem instance and process the solver output. ```plantuml name=\"solver-solver\" abstract class solverpy.solver.solver.Solver extends solverpy.solver.object.SolverPyObj { {abstract} # success : frozenset[Status] {abstract} # timeouts : frozenset[Status] {abstract} # statuses : frozenset[Status] {abstract} # run(instance, strategy) : str {abstract} # process(output) : Result + solve(instance, strategy) : Result + valid(result) : bool + solved(result) : bool } abstract class solverpy.solver.pluginsolver.PluginSolver extends solverpy.solver.solver.Solver ``` The main method is [`solve`][solverpy.solver.solver.Solver.solve] which calls the solver on a problem instance and returns a processed result --- by default it calls `run` and `process` in sequence. Result query methods [valid][solverpy.solver.solver.Solver.valid] and [solved][solverpy.solver.solver.Solver.solved] are implemented to recognize a valid and successfully solved results. The values of `instance` and `strategy` in `solve` are completely solver-specific at this level. The [`Result`][solverpy.tools.typing.Result] is, however, always a dictionary guaranteed to contain at least the keys `status` and `runtime`. The value of `status` is one of [`statuses`][solverpy.solver.solver.Solver.statuses] and the value of `runtime` is the solver runtime in seconds. The statuses are also solver-specific. The set [`success`][solverpy.solver.solver.Solver.success] contains all successful statuses, and similarly [`timeouts`][solverpy.solver.solver.Solver.timeouts] contains timeouting statuses. Both sets [`timeouts`][solverpy.solver.solver.Solver.timeouts] and [`success`][solverpy.solver.solver.Solver.success] are expected to be subsets of [`statuses`][solverpy.solver.solver.Solver.statuses] which contain all valid statuses. \"\"\" def __init__ ( self , ** kwargs : Any ): SolverPyObj . __init__ ( self , ** kwargs ) def __str__ ( self ) -> str : return self . name def solve ( self , instance : Any , strategy : Any ) -> \"Result\" : \"\"\" Run the solver with the strategy on the instatance. Process the output and create the result. Args: instance: solver problem instance (filename, or a bid-problem pair, or custom). strategy: solver strategy (filename, sid, or custom). Returns: The SolverPy result dictionary. \"\"\" output = self . run ( instance , strategy ) self . _output = output result = self . process ( output ) return result def valid ( self , result : \"Result\" ) -> bool : \"\"\" A valid status contains at least keys `status` and `runtime`. The status must be a valid status. Args: result: the result \"\"\" return bool ( result ) and \\ ( \"status\" in result ) and \\ ( \"runtime\" in result ) and \\ ( result [ \"status\" ] in self . statuses ) def solved ( self , result : \"Result\" ) -> bool : \"\"\" The result is solved if the status is in the success set. Args: result: the result \"\"\" return bool ( result ) and \\ ( \"status\" in result ) and \\ ( result [ \"status\" ] in self . success ) def run ( self , instance : Any , strategy : Any ) -> str : \"\"\" Run the solver with the strategy on the instatnce. Args: instance: solver problem instance strategy: solver strategy Returns: raw solver output \"\"\" del instance , strategy # unused arguments raise NotImplementedError () def process ( self , output : Any ) -> \"Result\" : \"\"\" Process the solver output and create the result. Args: output: raw solver output Returns: processed result dictionary \"\"\" del output # unused argument raise NotImplementedError () @property def name ( self ) -> str : \"\"\" Solver name. The default name is the class name. \"\"\" return self . __class__ . __name__ @property def success ( self ) -> frozenset [ str ]: \"\"\" The set of successful statuses. \"\"\" raise NotImplementedError () @property def timeouts ( self ) -> frozenset [ str ]: \"\"\" The set of timeout statuses. \"\"\" raise NotImplementedError () @property def statuses ( self ) -> frozenset [ str ]: \"\"\" The set of all valid statuses. \"\"\" raise NotImplementedError () name : str property Solver name. The default name is the class name. statuses : frozenset [ str ] property The set of all valid statuses. success : frozenset [ str ] property The set of successful statuses. timeouts : frozenset [ str ] property The set of timeout statuses. process ( output : Any ) -> Result Process the solver output and create the result. Parameters: Name Type Description Default output Any raw solver output required Returns: Type Description Result processed result dictionary Source code in src/solverpy/solver/solver.py 134 135 136 137 138 139 140 141 142 143 144 145 def process ( self , output : Any ) -> \"Result\" : \"\"\" Process the solver output and create the result. Args: output: raw solver output Returns: processed result dictionary \"\"\" del output # unused argument raise NotImplementedError () run ( instance : Any , strategy : Any ) -> str Run the solver with the strategy on the instatnce. Parameters: Name Type Description Default instance Any solver problem instance required strategy Any solver strategy required Returns: Type Description str raw solver output Source code in src/solverpy/solver/solver.py 120 121 122 123 124 125 126 127 128 129 130 131 132 def run ( self , instance : Any , strategy : Any ) -> str : \"\"\" Run the solver with the strategy on the instatnce. Args: instance: solver problem instance strategy: solver strategy Returns: raw solver output \"\"\" del instance , strategy # unused arguments raise NotImplementedError () solve ( instance : Any , strategy : Any ) -> Result Run the solver with the strategy on the instatance. Process the output and create the result. Parameters: Name Type Description Default instance Any solver problem instance (filename, or a bid-problem pair, or custom). required strategy Any solver strategy (filename, sid, or custom). required Returns: Type Description Result The SolverPy result dictionary. Source code in src/solverpy/solver/solver.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 def solve ( self , instance : Any , strategy : Any ) -> \"Result\" : \"\"\" Run the solver with the strategy on the instatance. Process the output and create the result. Args: instance: solver problem instance (filename, or a bid-problem pair, or custom). strategy: solver strategy (filename, sid, or custom). Returns: The SolverPy result dictionary. \"\"\" output = self . run ( instance , strategy ) self . _output = output result = self . process ( output ) return result solved ( result : Result ) -> bool The result is solved if the status is in the success set. Parameters: Name Type Description Default result Result the result required Source code in src/solverpy/solver/solver.py 109 110 111 112 113 114 115 116 117 118 def solved ( self , result : \"Result\" ) -> bool : \"\"\" The result is solved if the status is in the success set. Args: result: the result \"\"\" return bool ( result ) and \\ ( \"status\" in result ) and \\ ( result [ \"status\" ] in self . success ) valid ( result : Result ) -> bool A valid status contains at least keys status and runtime . The status must be a valid status. Parameters: Name Type Description Default result Result the result required Source code in src/solverpy/solver/solver.py 96 97 98 99 100 101 102 103 104 105 106 107 def valid ( self , result : \"Result\" ) -> bool : \"\"\" A valid status contains at least keys `status` and `runtime`. The status must be a valid status. Args: result: the result \"\"\" return bool ( result ) and \\ ( \"status\" in result ) and \\ ( \"runtime\" in result ) and \\ ( result [ \"status\" ] in self . statuses )","title":"\ud83e\udd16 solver"},{"location":"api/solverpy/solver/solver/#module-solver","text":"","title":"module solver"},{"location":"api/solverpy/solver/solver/#solverpy.solver.solver","text":"","title":"solver"},{"location":"api/solverpy/solver/solver/#solverpy.solver.solver--abstract-solver-interface","text":"The class Solver encapsulates the very basic solver functionality --- solving a single problem instance and processing the output. The class defines solver-specific set of statuses, which are typically strings representing TPTP statuses (like Theorem , Unsatisfiable , etc), or SMT statuses (like sat , unsat , etc). The main method solve runs the solver and returns a processed result. The result is the SolverPy Result dictionary containing at least keys status and runtime . Although the result can contain solver-specific keys, the basic result structure is shared between all solvers. This makes the result comparable between solvers. The plugin functionality is added in the superclass class PluginSolver .","title":"Abstract solver interface"},{"location":"api/solverpy/solver/solver/#solverpy.solver.solver.Solver","text":"Bases: SolverPyObj Base abstract class for all solvers encapsulating the very basic solver functionality. The implementing class must provide the set of statuses, and implement methods run and process which run the solver on a single problem instance and process the solver output. The main method is solve which calls the solver on a problem instance and returns a processed result --- by default it calls run and process in sequence. Result query methods valid and solved are implemented to recognize a valid and successfully solved results. The values of instance and strategy in solve are completely solver-specific at this level. The Result is, however, always a dictionary guaranteed to contain at least the keys status and runtime . The value of status is one of statuses and the value of runtime is the solver runtime in seconds. The statuses are also solver-specific. The set success contains all successful statuses, and similarly timeouts contains timeouting statuses. Both sets timeouts and success are expected to be subsets of statuses which contain all valid statuses. Source code in src/solverpy/solver/solver.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 class Solver ( SolverPyObj ): \"\"\" Base abstract class for all solvers encapsulating the very basic solver functionality. The implementing class must provide the set of statuses, and implement methods [`run`][solverpy.solver.solver.Solver.run] and [`process`][solverpy.solver.solver.Solver.process] which run the solver on a single problem instance and process the solver output. ```plantuml name=\"solver-solver\" abstract class solverpy.solver.solver.Solver extends solverpy.solver.object.SolverPyObj { {abstract} # success : frozenset[Status] {abstract} # timeouts : frozenset[Status] {abstract} # statuses : frozenset[Status] {abstract} # run(instance, strategy) : str {abstract} # process(output) : Result + solve(instance, strategy) : Result + valid(result) : bool + solved(result) : bool } abstract class solverpy.solver.pluginsolver.PluginSolver extends solverpy.solver.solver.Solver ``` The main method is [`solve`][solverpy.solver.solver.Solver.solve] which calls the solver on a problem instance and returns a processed result --- by default it calls `run` and `process` in sequence. Result query methods [valid][solverpy.solver.solver.Solver.valid] and [solved][solverpy.solver.solver.Solver.solved] are implemented to recognize a valid and successfully solved results. The values of `instance` and `strategy` in `solve` are completely solver-specific at this level. The [`Result`][solverpy.tools.typing.Result] is, however, always a dictionary guaranteed to contain at least the keys `status` and `runtime`. The value of `status` is one of [`statuses`][solverpy.solver.solver.Solver.statuses] and the value of `runtime` is the solver runtime in seconds. The statuses are also solver-specific. The set [`success`][solverpy.solver.solver.Solver.success] contains all successful statuses, and similarly [`timeouts`][solverpy.solver.solver.Solver.timeouts] contains timeouting statuses. Both sets [`timeouts`][solverpy.solver.solver.Solver.timeouts] and [`success`][solverpy.solver.solver.Solver.success] are expected to be subsets of [`statuses`][solverpy.solver.solver.Solver.statuses] which contain all valid statuses. \"\"\" def __init__ ( self , ** kwargs : Any ): SolverPyObj . __init__ ( self , ** kwargs ) def __str__ ( self ) -> str : return self . name def solve ( self , instance : Any , strategy : Any ) -> \"Result\" : \"\"\" Run the solver with the strategy on the instatance. Process the output and create the result. Args: instance: solver problem instance (filename, or a bid-problem pair, or custom). strategy: solver strategy (filename, sid, or custom). Returns: The SolverPy result dictionary. \"\"\" output = self . run ( instance , strategy ) self . _output = output result = self . process ( output ) return result def valid ( self , result : \"Result\" ) -> bool : \"\"\" A valid status contains at least keys `status` and `runtime`. The status must be a valid status. Args: result: the result \"\"\" return bool ( result ) and \\ ( \"status\" in result ) and \\ ( \"runtime\" in result ) and \\ ( result [ \"status\" ] in self . statuses ) def solved ( self , result : \"Result\" ) -> bool : \"\"\" The result is solved if the status is in the success set. Args: result: the result \"\"\" return bool ( result ) and \\ ( \"status\" in result ) and \\ ( result [ \"status\" ] in self . success ) def run ( self , instance : Any , strategy : Any ) -> str : \"\"\" Run the solver with the strategy on the instatnce. Args: instance: solver problem instance strategy: solver strategy Returns: raw solver output \"\"\" del instance , strategy # unused arguments raise NotImplementedError () def process ( self , output : Any ) -> \"Result\" : \"\"\" Process the solver output and create the result. Args: output: raw solver output Returns: processed result dictionary \"\"\" del output # unused argument raise NotImplementedError () @property def name ( self ) -> str : \"\"\" Solver name. The default name is the class name. \"\"\" return self . __class__ . __name__ @property def success ( self ) -> frozenset [ str ]: \"\"\" The set of successful statuses. \"\"\" raise NotImplementedError () @property def timeouts ( self ) -> frozenset [ str ]: \"\"\" The set of timeout statuses. \"\"\" raise NotImplementedError () @property def statuses ( self ) -> frozenset [ str ]: \"\"\" The set of all valid statuses. \"\"\" raise NotImplementedError ()","title":"Solver"},{"location":"api/solverpy/solver/solver/#solverpy.solver.solver.Solver.name","text":"Solver name. The default name is the class name.","title":"name"},{"location":"api/solverpy/solver/solver/#solverpy.solver.solver.Solver.statuses","text":"The set of all valid statuses.","title":"statuses"},{"location":"api/solverpy/solver/solver/#solverpy.solver.solver.Solver.success","text":"The set of successful statuses.","title":"success"},{"location":"api/solverpy/solver/solver/#solverpy.solver.solver.Solver.timeouts","text":"The set of timeout statuses.","title":"timeouts"},{"location":"api/solverpy/solver/solver/#solverpy.solver.solver.Solver.process","text":"Process the solver output and create the result. Parameters: Name Type Description Default output Any raw solver output required Returns: Type Description Result processed result dictionary Source code in src/solverpy/solver/solver.py 134 135 136 137 138 139 140 141 142 143 144 145 def process ( self , output : Any ) -> \"Result\" : \"\"\" Process the solver output and create the result. Args: output: raw solver output Returns: processed result dictionary \"\"\" del output # unused argument raise NotImplementedError ()","title":"process"},{"location":"api/solverpy/solver/solver/#solverpy.solver.solver.Solver.run","text":"Run the solver with the strategy on the instatnce. Parameters: Name Type Description Default instance Any solver problem instance required strategy Any solver strategy required Returns: Type Description str raw solver output Source code in src/solverpy/solver/solver.py 120 121 122 123 124 125 126 127 128 129 130 131 132 def run ( self , instance : Any , strategy : Any ) -> str : \"\"\" Run the solver with the strategy on the instatnce. Args: instance: solver problem instance strategy: solver strategy Returns: raw solver output \"\"\" del instance , strategy # unused arguments raise NotImplementedError ()","title":"run"},{"location":"api/solverpy/solver/solver/#solverpy.solver.solver.Solver.solve","text":"Run the solver with the strategy on the instatance. Process the output and create the result. Parameters: Name Type Description Default instance Any solver problem instance (filename, or a bid-problem pair, or custom). required strategy Any solver strategy (filename, sid, or custom). required Returns: Type Description Result The SolverPy result dictionary. Source code in src/solverpy/solver/solver.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 def solve ( self , instance : Any , strategy : Any ) -> \"Result\" : \"\"\" Run the solver with the strategy on the instatance. Process the output and create the result. Args: instance: solver problem instance (filename, or a bid-problem pair, or custom). strategy: solver strategy (filename, sid, or custom). Returns: The SolverPy result dictionary. \"\"\" output = self . run ( instance , strategy ) self . _output = output result = self . process ( output ) return result","title":"solve"},{"location":"api/solverpy/solver/solver/#solverpy.solver.solver.Solver.solved","text":"The result is solved if the status is in the success set. Parameters: Name Type Description Default result Result the result required Source code in src/solverpy/solver/solver.py 109 110 111 112 113 114 115 116 117 118 def solved ( self , result : \"Result\" ) -> bool : \"\"\" The result is solved if the status is in the success set. Args: result: the result \"\"\" return bool ( result ) and \\ ( \"status\" in result ) and \\ ( result [ \"status\" ] in self . success )","title":"solved"},{"location":"api/solverpy/solver/solver/#solverpy.solver.solver.Solver.valid","text":"A valid status contains at least keys status and runtime . The status must be a valid status. Parameters: Name Type Description Default result Result the result required Source code in src/solverpy/solver/solver.py 96 97 98 99 100 101 102 103 104 105 106 107 def valid ( self , result : \"Result\" ) -> bool : \"\"\" A valid status contains at least keys `status` and `runtime`. The status must be a valid status. Args: result: the result \"\"\" return bool ( result ) and \\ ( \"status\" in result ) and \\ ( \"runtime\" in result ) and \\ ( result [ \"status\" ] in self . statuses )","title":"valid"},{"location":"api/solverpy/solver/solverpy/","text":"module solverpy solverpy.solver.solverpy SolverPy Bases: PluginSolver Source code in src/solverpy/solver/solverpy.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 class SolverPy ( PluginSolver ): def __init__ ( self , limits : Limits , plugins : list [ \"Plugin\" ] = [], ** kwargs : Any , ): assert limits . limit . startswith ( \"T\" ) self . _limits : Limits = limits self . _exitcode : int = - 1 self . _timeouts = frozenset () self . _success = frozenset () self . _statuses = frozenset () plugins = plugins + [ Limiter (), ] PluginSolver . __init__ ( self , plugins = plugins , ** kwargs ) def __hash__ ( self ): return hash ( str ( self )) def __eq__ ( self , other ): if not isinstance ( other , SolverPy ): return False return str ( self ) == str ( other ) def simulate ( self , result : \"Result\" ) -> \"Result | None\" : \"Simulate run from the past result.\" if result [ \"status\" ] in self . timeouts : #if result[\"status\"] not in self.success: # we might want this? oldlimits = Limits ( result [ \"limit\" ], {}) # the cached result is timeout if oldlimits < self . _limits : #if result[\"runtime\"] < self.timeout: # recompute since we have more time or/and space return None elif result [ \"status\" ] in self . success : # the cached result is solved if result [ \"runtime\" ] > self . _limits . timeout : #if result[\"runtime\"] > self.timeout: # simulated timeout return dict ( result , status = \"TIMEOUT\" , runtime = self . _limits . timeout , ) elif result [ \"status\" ] in self . statuses : # the cached result is unknow/GaveUp oldlimits = Limits ( result [ \"limit\" ], {}) if oldlimits > self . _limits : # recompute if we have less resources (maybe timeout?) # TODO: is this correct? return None else : # recompute unknown results (GaveUp, unknown) # TODO: do we want to always recompute? return None # the result is applicable without changes return result @property def timeouts ( self ) -> frozenset [ str ]: return self . _timeouts @property def success ( self ) -> frozenset [ str ]: return self . _success @property def statuses ( self ) -> frozenset [ str ]: return self . _statuses simulate ( result : Result ) -> Result | None Simulate run from the past result. Source code in src/solverpy/solver/solverpy.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 def simulate ( self , result : \"Result\" ) -> \"Result | None\" : \"Simulate run from the past result.\" if result [ \"status\" ] in self . timeouts : #if result[\"status\"] not in self.success: # we might want this? oldlimits = Limits ( result [ \"limit\" ], {}) # the cached result is timeout if oldlimits < self . _limits : #if result[\"runtime\"] < self.timeout: # recompute since we have more time or/and space return None elif result [ \"status\" ] in self . success : # the cached result is solved if result [ \"runtime\" ] > self . _limits . timeout : #if result[\"runtime\"] > self.timeout: # simulated timeout return dict ( result , status = \"TIMEOUT\" , runtime = self . _limits . timeout , ) elif result [ \"status\" ] in self . statuses : # the cached result is unknow/GaveUp oldlimits = Limits ( result [ \"limit\" ], {}) if oldlimits > self . _limits : # recompute if we have less resources (maybe timeout?) # TODO: is this correct? return None else : # recompute unknown results (GaveUp, unknown) # TODO: do we want to always recompute? return None # the result is applicable without changes return result","title":"\ud83e\udd16 solverpy"},{"location":"api/solverpy/solver/solverpy/#module-solverpy","text":"","title":"module solverpy"},{"location":"api/solverpy/solver/solverpy/#solverpy.solver.solverpy","text":"","title":"solverpy"},{"location":"api/solverpy/solver/solverpy/#solverpy.solver.solverpy.SolverPy","text":"Bases: PluginSolver Source code in src/solverpy/solver/solverpy.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 class SolverPy ( PluginSolver ): def __init__ ( self , limits : Limits , plugins : list [ \"Plugin\" ] = [], ** kwargs : Any , ): assert limits . limit . startswith ( \"T\" ) self . _limits : Limits = limits self . _exitcode : int = - 1 self . _timeouts = frozenset () self . _success = frozenset () self . _statuses = frozenset () plugins = plugins + [ Limiter (), ] PluginSolver . __init__ ( self , plugins = plugins , ** kwargs ) def __hash__ ( self ): return hash ( str ( self )) def __eq__ ( self , other ): if not isinstance ( other , SolverPy ): return False return str ( self ) == str ( other ) def simulate ( self , result : \"Result\" ) -> \"Result | None\" : \"Simulate run from the past result.\" if result [ \"status\" ] in self . timeouts : #if result[\"status\"] not in self.success: # we might want this? oldlimits = Limits ( result [ \"limit\" ], {}) # the cached result is timeout if oldlimits < self . _limits : #if result[\"runtime\"] < self.timeout: # recompute since we have more time or/and space return None elif result [ \"status\" ] in self . success : # the cached result is solved if result [ \"runtime\" ] > self . _limits . timeout : #if result[\"runtime\"] > self.timeout: # simulated timeout return dict ( result , status = \"TIMEOUT\" , runtime = self . _limits . timeout , ) elif result [ \"status\" ] in self . statuses : # the cached result is unknow/GaveUp oldlimits = Limits ( result [ \"limit\" ], {}) if oldlimits > self . _limits : # recompute if we have less resources (maybe timeout?) # TODO: is this correct? return None else : # recompute unknown results (GaveUp, unknown) # TODO: do we want to always recompute? return None # the result is applicable without changes return result @property def timeouts ( self ) -> frozenset [ str ]: return self . _timeouts @property def success ( self ) -> frozenset [ str ]: return self . _success @property def statuses ( self ) -> frozenset [ str ]: return self . _statuses","title":"SolverPy"},{"location":"api/solverpy/solver/solverpy/#solverpy.solver.solverpy.SolverPy.simulate","text":"Simulate run from the past result. Source code in src/solverpy/solver/solverpy.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 def simulate ( self , result : \"Result\" ) -> \"Result | None\" : \"Simulate run from the past result.\" if result [ \"status\" ] in self . timeouts : #if result[\"status\"] not in self.success: # we might want this? oldlimits = Limits ( result [ \"limit\" ], {}) # the cached result is timeout if oldlimits < self . _limits : #if result[\"runtime\"] < self.timeout: # recompute since we have more time or/and space return None elif result [ \"status\" ] in self . success : # the cached result is solved if result [ \"runtime\" ] > self . _limits . timeout : #if result[\"runtime\"] > self.timeout: # simulated timeout return dict ( result , status = \"TIMEOUT\" , runtime = self . _limits . timeout , ) elif result [ \"status\" ] in self . statuses : # the cached result is unknow/GaveUp oldlimits = Limits ( result [ \"limit\" ], {}) if oldlimits > self . _limits : # recompute if we have less resources (maybe timeout?) # TODO: is this correct? return None else : # recompute unknown results (GaveUp, unknown) # TODO: do we want to always recompute? return None # the result is applicable without changes return result","title":"simulate"},{"location":"api/solverpy/solver/stdinsolver/","text":"module stdinsolver solverpy.solver.stdinsolver","title":"\ud83e\udd16 stdinsolver"},{"location":"api/solverpy/solver/stdinsolver/#module-stdinsolver","text":"","title":"module stdinsolver"},{"location":"api/solverpy/solver/stdinsolver/#solverpy.solver.stdinsolver","text":"","title":"stdinsolver"},{"location":"api/solverpy/solver/atp/","text":"Atp Overview solverpy.solver.atp E Bases: ShellSolver E Prover Source code in src/solverpy/solver/atp/eprover.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 class E ( ShellSolver ): \"\"\" E Prover \"\"\" def __init__ ( self , limit : str , binary : str = E_BINARY , static : str = E_STATIC , complete : bool = True , plugins : list [ \"Plugin\" ] = [], ): cmd = f \" { binary } { static } \" plugins = plugins + [ Time (), Tptp ( complete = complete ), ] ShellSolver . __init__ ( self , cmd , limit , E_BUILDER , plugins , 15 , complete , ) def process ( self , output : str ) -> \"Result\" : result = patterns . keyval ( E_PAT , output , E_TABLE ) result = patterns . mapval ( result , human . numeric ) return result","title":"\u2139\ufe0f Overview"},{"location":"api/solverpy/solver/atp/#atp-overview","text":"","title":"Atp Overview"},{"location":"api/solverpy/solver/atp/#solverpy.solver.atp","text":"","title":"atp"},{"location":"api/solverpy/solver/atp/#solverpy.solver.atp.E","text":"Bases: ShellSolver E Prover Source code in src/solverpy/solver/atp/eprover.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 class E ( ShellSolver ): \"\"\" E Prover \"\"\" def __init__ ( self , limit : str , binary : str = E_BINARY , static : str = E_STATIC , complete : bool = True , plugins : list [ \"Plugin\" ] = [], ): cmd = f \" { binary } { static } \" plugins = plugins + [ Time (), Tptp ( complete = complete ), ] ShellSolver . __init__ ( self , cmd , limit , E_BUILDER , plugins , 15 , complete , ) def process ( self , output : str ) -> \"Result\" : result = patterns . keyval ( E_PAT , output , E_TABLE ) result = patterns . mapval ( result , human . numeric ) return result","title":"E"},{"location":"api/solverpy/solver/atp/cvc5/","text":"module cvc5 solverpy.solver.atp.cvc5","title":"\ud83e\udd16 cvc5"},{"location":"api/solverpy/solver/atp/cvc5/#module-cvc5","text":"","title":"module cvc5"},{"location":"api/solverpy/solver/atp/cvc5/#solverpy.solver.atp.cvc5","text":"","title":"cvc5"},{"location":"api/solverpy/solver/atp/eprover/","text":"module eprover solverpy.solver.atp.eprover E Bases: ShellSolver E Prover Source code in src/solverpy/solver/atp/eprover.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 class E ( ShellSolver ): \"\"\" E Prover \"\"\" def __init__ ( self , limit : str , binary : str = E_BINARY , static : str = E_STATIC , complete : bool = True , plugins : list [ \"Plugin\" ] = [], ): cmd = f \" { binary } { static } \" plugins = plugins + [ Time (), Tptp ( complete = complete ), ] ShellSolver . __init__ ( self , cmd , limit , E_BUILDER , plugins , 15 , complete , ) def process ( self , output : str ) -> \"Result\" : result = patterns . keyval ( E_PAT , output , E_TABLE ) result = patterns . mapval ( result , human . numeric ) return result","title":"\ud83e\udd16 eprover"},{"location":"api/solverpy/solver/atp/eprover/#module-eprover","text":"","title":"module eprover"},{"location":"api/solverpy/solver/atp/eprover/#solverpy.solver.atp.eprover","text":"","title":"eprover"},{"location":"api/solverpy/solver/atp/eprover/#solverpy.solver.atp.eprover.E","text":"Bases: ShellSolver E Prover Source code in src/solverpy/solver/atp/eprover.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 class E ( ShellSolver ): \"\"\" E Prover \"\"\" def __init__ ( self , limit : str , binary : str = E_BINARY , static : str = E_STATIC , complete : bool = True , plugins : list [ \"Plugin\" ] = [], ): cmd = f \" { binary } { static } \" plugins = plugins + [ Time (), Tptp ( complete = complete ), ] ShellSolver . __init__ ( self , cmd , limit , E_BUILDER , plugins , 15 , complete , ) def process ( self , output : str ) -> \"Result\" : result = patterns . keyval ( E_PAT , output , E_TABLE ) result = patterns . mapval ( result , human . numeric ) return result","title":"E"},{"location":"api/solverpy/solver/atp/lash/","text":"module lash solverpy.solver.atp.lash","title":"\ud83e\udd16 lash"},{"location":"api/solverpy/solver/atp/lash/#module-lash","text":"","title":"module lash"},{"location":"api/solverpy/solver/atp/lash/#solverpy.solver.atp.lash","text":"","title":"lash"},{"location":"api/solverpy/solver/atp/prover9/","text":"module prover9 solverpy.solver.atp.prover9","title":"\ud83e\udd16 prover9"},{"location":"api/solverpy/solver/atp/prover9/#module-prover9","text":"","title":"module prover9"},{"location":"api/solverpy/solver/atp/prover9/#solverpy.solver.atp.prover9","text":"","title":"prover9"},{"location":"api/solverpy/solver/atp/vampire/","text":"module vampire solverpy.solver.atp.vampire","title":"\ud83e\udd16 vampire"},{"location":"api/solverpy/solver/atp/vampire/#module-vampire","text":"","title":"module vampire"},{"location":"api/solverpy/solver/atp/vampire/#solverpy.solver.atp.vampire","text":"","title":"vampire"},{"location":"api/solverpy/solver/plugins/","text":"Plugins Overview solverpy.solver.plugins The plugins module. outputs ( flatten = True , compress = True ) Debugging plugins. Source code in src/solverpy/solver/plugins/__init__.py 17 18 19 20 21 22 23 24 def outputs ( flatten = True , compress = True ): \"\"\"Debugging plugins.\"\"\" return [ Bid (), Sid (), Outputs ( flatten , compress ), Errors ( flatten , compress ), ]","title":"\u2139\ufe0f Overview"},{"location":"api/solverpy/solver/plugins/#plugins-overview","text":"","title":"Plugins Overview"},{"location":"api/solverpy/solver/plugins/#solverpy.solver.plugins","text":"The plugins module.","title":"plugins"},{"location":"api/solverpy/solver/plugins/#solverpy.solver.plugins.outputs","text":"Debugging plugins. Source code in src/solverpy/solver/plugins/__init__.py 17 18 19 20 21 22 23 24 def outputs ( flatten = True , compress = True ): \"\"\"Debugging plugins.\"\"\" return [ Bid (), Sid (), Outputs ( flatten , compress ), Errors ( flatten , compress ), ]","title":"outputs"},{"location":"api/solverpy/solver/plugins/decorator/","text":"module decorator solverpy.solver.plugins.decorator","title":"\ud83e\udd16 decorator"},{"location":"api/solverpy/solver/plugins/decorator/#module-decorator","text":"","title":"module decorator"},{"location":"api/solverpy/solver/plugins/decorator/#solverpy.solver.plugins.decorator","text":"","title":"decorator"},{"location":"api/solverpy/solver/plugins/plugin/","text":"module plugin solverpy.solver.plugins.plugin Plugin Bases: SolverPyObj Base class for plugins. Source code in src/solverpy/solver/plugins/plugin.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Plugin ( SolverPyObj ): \"\"\"Base class for plugins.\"\"\" def __init__ ( self , pid : str | None = None , ** kwargs : Any ): SolverPyObj . __init__ ( self , ** kwargs ) self . _id = pid def register ( self , solver : Any ) -> None : del solver # unused argument raise NotImplementedError () @property def id ( self ) -> str | None : return self . _id","title":"\ud83e\udd16 plugin"},{"location":"api/solverpy/solver/plugins/plugin/#module-plugin","text":"","title":"module plugin"},{"location":"api/solverpy/solver/plugins/plugin/#solverpy.solver.plugins.plugin","text":"","title":"plugin"},{"location":"api/solverpy/solver/plugins/plugin/#solverpy.solver.plugins.plugin.Plugin","text":"Bases: SolverPyObj Base class for plugins. Source code in src/solverpy/solver/plugins/plugin.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Plugin ( SolverPyObj ): \"\"\"Base class for plugins.\"\"\" def __init__ ( self , pid : str | None = None , ** kwargs : Any ): SolverPyObj . __init__ ( self , ** kwargs ) self . _id = pid def register ( self , solver : Any ) -> None : del solver # unused argument raise NotImplementedError () @property def id ( self ) -> str | None : return self . _id","title":"Plugin"},{"location":"api/solverpy/solver/plugins/translator/","text":"module translator solverpy.solver.plugins.translator","title":"\ud83e\udd16 translator"},{"location":"api/solverpy/solver/plugins/translator/#module-translator","text":"","title":"module translator"},{"location":"api/solverpy/solver/plugins/translator/#solverpy.solver.plugins.translator","text":"","title":"translator"},{"location":"api/solverpy/solver/plugins/db/","text":"Db Overview solverpy.solver.plugins.db Bid Bases: Translator Benchmark ids translator. Source code in src/solverpy/solver/plugins/db/bid.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Bid ( Translator ): \"Benchmark ids translator.\" def __init__ ( self , ** kwargs ): Translator . __init__ ( self , ** kwargs ) def translate ( self , instance : tuple [ str , str ], strategy : Any ) -> tuple [ str , Any ]: ( bid , problem ) = instance instance0 = bids . path ( bid , problem ) return ( instance0 , strategy ) Sid Bases: Translator Strategy ids translator. Source code in src/solverpy/solver/plugins/db/sid.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Sid ( Translator ): \"Strategy ids translator.\" def translate ( self , instance : Any , strategy : str , ) -> tuple [ Any , str ]: sid = strategy strategy0 = sids . load ( sid ) if \"@@@\" in strategy0 : ( sid , args ) = sids . split ( sid ) strategy0 = sids . instatiate ( strategy0 , args ) return ( instance , strategy0 )","title":"\u2139\ufe0f Overview"},{"location":"api/solverpy/solver/plugins/db/#db-overview","text":"","title":"Db Overview"},{"location":"api/solverpy/solver/plugins/db/#solverpy.solver.plugins.db","text":"","title":"db"},{"location":"api/solverpy/solver/plugins/db/#solverpy.solver.plugins.db.Bid","text":"Bases: Translator Benchmark ids translator. Source code in src/solverpy/solver/plugins/db/bid.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Bid ( Translator ): \"Benchmark ids translator.\" def __init__ ( self , ** kwargs ): Translator . __init__ ( self , ** kwargs ) def translate ( self , instance : tuple [ str , str ], strategy : Any ) -> tuple [ str , Any ]: ( bid , problem ) = instance instance0 = bids . path ( bid , problem ) return ( instance0 , strategy )","title":"Bid"},{"location":"api/solverpy/solver/plugins/db/#solverpy.solver.plugins.db.Sid","text":"Bases: Translator Strategy ids translator. Source code in src/solverpy/solver/plugins/db/sid.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Sid ( Translator ): \"Strategy ids translator.\" def translate ( self , instance : Any , strategy : str , ) -> tuple [ Any , str ]: sid = strategy strategy0 = sids . load ( sid ) if \"@@@\" in strategy0 : ( sid , args ) = sids . split ( sid ) strategy0 = sids . instatiate ( strategy0 , args ) return ( instance , strategy0 )","title":"Sid"},{"location":"api/solverpy/solver/plugins/db/bid/","text":"module bid solverpy.solver.plugins.db.bid Bid Bases: Translator Benchmark ids translator. Source code in src/solverpy/solver/plugins/db/bid.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Bid ( Translator ): \"Benchmark ids translator.\" def __init__ ( self , ** kwargs ): Translator . __init__ ( self , ** kwargs ) def translate ( self , instance : tuple [ str , str ], strategy : Any ) -> tuple [ str , Any ]: ( bid , problem ) = instance instance0 = bids . path ( bid , problem ) return ( instance0 , strategy )","title":"\ud83e\udd16 bid"},{"location":"api/solverpy/solver/plugins/db/bid/#module-bid","text":"","title":"module bid"},{"location":"api/solverpy/solver/plugins/db/bid/#solverpy.solver.plugins.db.bid","text":"","title":"bid"},{"location":"api/solverpy/solver/plugins/db/bid/#solverpy.solver.plugins.db.bid.Bid","text":"Bases: Translator Benchmark ids translator. Source code in src/solverpy/solver/plugins/db/bid.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Bid ( Translator ): \"Benchmark ids translator.\" def __init__ ( self , ** kwargs ): Translator . __init__ ( self , ** kwargs ) def translate ( self , instance : tuple [ str , str ], strategy : Any ) -> tuple [ str , Any ]: ( bid , problem ) = instance instance0 = bids . path ( bid , problem ) return ( instance0 , strategy )","title":"Bid"},{"location":"api/solverpy/solver/plugins/db/errors/","text":"module errors solverpy.solver.plugins.db.errors","title":"\ud83e\udd16 errors"},{"location":"api/solverpy/solver/plugins/db/errors/#module-errors","text":"","title":"module errors"},{"location":"api/solverpy/solver/plugins/db/errors/#solverpy.solver.plugins.db.errors","text":"","title":"errors"},{"location":"api/solverpy/solver/plugins/db/outputs/","text":"module outputs solverpy.solver.plugins.db.outputs","title":"\ud83e\udd16 outputs"},{"location":"api/solverpy/solver/plugins/db/outputs/#module-outputs","text":"","title":"module outputs"},{"location":"api/solverpy/solver/plugins/db/outputs/#solverpy.solver.plugins.db.outputs","text":"","title":"outputs"},{"location":"api/solverpy/solver/plugins/db/sid/","text":"module sid solverpy.solver.plugins.db.sid Sid Bases: Translator Strategy ids translator. Source code in src/solverpy/solver/plugins/db/sid.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Sid ( Translator ): \"Strategy ids translator.\" def translate ( self , instance : Any , strategy : str , ) -> tuple [ Any , str ]: sid = strategy strategy0 = sids . load ( sid ) if \"@@@\" in strategy0 : ( sid , args ) = sids . split ( sid ) strategy0 = sids . instatiate ( strategy0 , args ) return ( instance , strategy0 )","title":"\ud83e\udd16 sid"},{"location":"api/solverpy/solver/plugins/db/sid/#module-sid","text":"","title":"module sid"},{"location":"api/solverpy/solver/plugins/db/sid/#solverpy.solver.plugins.db.sid","text":"","title":"sid"},{"location":"api/solverpy/solver/plugins/db/sid/#solverpy.solver.plugins.db.sid.Sid","text":"Bases: Translator Strategy ids translator. Source code in src/solverpy/solver/plugins/db/sid.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Sid ( Translator ): \"Strategy ids translator.\" def translate ( self , instance : Any , strategy : str , ) -> tuple [ Any , str ]: sid = strategy strategy0 = sids . load ( sid ) if \"@@@\" in strategy0 : ( sid , args ) = sids . split ( sid ) strategy0 = sids . instatiate ( strategy0 , args ) return ( instance , strategy0 )","title":"Sid"},{"location":"api/solverpy/solver/plugins/shell/","text":"Shell Overview solverpy.solver.plugins.shell Limits Bases: Decorator , Translator This is either a decorator or a translator based on the value of cmdline . Source code in src/solverpy/solver/plugins/shell/limits.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 class Limits ( Decorator , Translator ): \"\"\" This is either a decorator or a translator based on the value of `cmdline`. \"\"\" def __init__ ( self , limit : str , builder : \"LimitBuilder\" , cmdline : bool = True , inputfile : bool = False , ): Plugin . __init__ ( self , limit = limit , cmdline = cmdline , ) lims = { x [ 0 ]: x [ 1 :] for x in limit . split ( \"-\" ) if x } assert \"T\" in lims self . timeout = int ( lims [ \"T\" ]) self . memory = float ( lims [ \"M\" ]) if \"M\" in lims else None try : lims = [ build ( builder [ x ], y ) for ( x , y ) in lims . items () if x in builder ] except Exception as e : print ( e ) raise Exception ( f \"solverpy: Invalid limit string: { limit } \" ) delim = \" \" if cmdline else \"\" self . strat = delim . join ( lims ) self . cmdline = cmdline #self.args = \" \".join(lims) self . limit = limit self . _inputfile = inputfile def register ( self , solver : \"SolverPy\" ) -> None : if self . cmdline : solver . decorators . append ( self ) else : solver . translators . append ( self ) def __str__ ( self ) -> str : return self . limit def __lt__ ( self , other ): if self . limit and not other . limit : return None if self . memory and not other . memory : return None if not self . memory : return ( self . timeout < other . timeout ) else : return ( self . timeout < other . timeout ) or ( self . memory < other . memory ) #def __le__(self, other): # return (self.key == other.key) or (self < other) def decorate ( self , cmd : str , instance : Any , strategy : Any , ) -> str : del instance , strategy # unused arguments if self . cmdline : input = \" /dev/stdin\" if self . _inputfile else \"\" return f \" { cmd } { self . strategy }{ input } \" if self . strategy else cmd else : return cmd def translate ( self , instance : Any , strategy : str , ) -> tuple [ Any , str ]: if not self . cmdline : return ( instance , self . strategy + strategy ) else : return ( instance , strategy ) @property def strategy ( self ) -> str : return self . strat","title":"\u2139\ufe0f Overview"},{"location":"api/solverpy/solver/plugins/shell/#shell-overview","text":"","title":"Shell Overview"},{"location":"api/solverpy/solver/plugins/shell/#solverpy.solver.plugins.shell","text":"","title":"shell"},{"location":"api/solverpy/solver/plugins/shell/#solverpy.solver.plugins.shell.Limits","text":"Bases: Decorator , Translator This is either a decorator or a translator based on the value of cmdline . Source code in src/solverpy/solver/plugins/shell/limits.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 class Limits ( Decorator , Translator ): \"\"\" This is either a decorator or a translator based on the value of `cmdline`. \"\"\" def __init__ ( self , limit : str , builder : \"LimitBuilder\" , cmdline : bool = True , inputfile : bool = False , ): Plugin . __init__ ( self , limit = limit , cmdline = cmdline , ) lims = { x [ 0 ]: x [ 1 :] for x in limit . split ( \"-\" ) if x } assert \"T\" in lims self . timeout = int ( lims [ \"T\" ]) self . memory = float ( lims [ \"M\" ]) if \"M\" in lims else None try : lims = [ build ( builder [ x ], y ) for ( x , y ) in lims . items () if x in builder ] except Exception as e : print ( e ) raise Exception ( f \"solverpy: Invalid limit string: { limit } \" ) delim = \" \" if cmdline else \"\" self . strat = delim . join ( lims ) self . cmdline = cmdline #self.args = \" \".join(lims) self . limit = limit self . _inputfile = inputfile def register ( self , solver : \"SolverPy\" ) -> None : if self . cmdline : solver . decorators . append ( self ) else : solver . translators . append ( self ) def __str__ ( self ) -> str : return self . limit def __lt__ ( self , other ): if self . limit and not other . limit : return None if self . memory and not other . memory : return None if not self . memory : return ( self . timeout < other . timeout ) else : return ( self . timeout < other . timeout ) or ( self . memory < other . memory ) #def __le__(self, other): # return (self.key == other.key) or (self < other) def decorate ( self , cmd : str , instance : Any , strategy : Any , ) -> str : del instance , strategy # unused arguments if self . cmdline : input = \" /dev/stdin\" if self . _inputfile else \"\" return f \" { cmd } { self . strategy }{ input } \" if self . strategy else cmd else : return cmd def translate ( self , instance : Any , strategy : str , ) -> tuple [ Any , str ]: if not self . cmdline : return ( instance , self . strategy + strategy ) else : return ( instance , strategy ) @property def strategy ( self ) -> str : return self . strat","title":"Limits"},{"location":"api/solverpy/solver/plugins/shell/limits/","text":"module limits solverpy.solver.plugins.shell.limits Limits Bases: Decorator , Translator This is either a decorator or a translator based on the value of cmdline . Source code in src/solverpy/solver/plugins/shell/limits.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 class Limits ( Decorator , Translator ): \"\"\" This is either a decorator or a translator based on the value of `cmdline`. \"\"\" def __init__ ( self , limit : str , builder : \"LimitBuilder\" , cmdline : bool = True , inputfile : bool = False , ): Plugin . __init__ ( self , limit = limit , cmdline = cmdline , ) lims = { x [ 0 ]: x [ 1 :] for x in limit . split ( \"-\" ) if x } assert \"T\" in lims self . timeout = int ( lims [ \"T\" ]) self . memory = float ( lims [ \"M\" ]) if \"M\" in lims else None try : lims = [ build ( builder [ x ], y ) for ( x , y ) in lims . items () if x in builder ] except Exception as e : print ( e ) raise Exception ( f \"solverpy: Invalid limit string: { limit } \" ) delim = \" \" if cmdline else \"\" self . strat = delim . join ( lims ) self . cmdline = cmdline #self.args = \" \".join(lims) self . limit = limit self . _inputfile = inputfile def register ( self , solver : \"SolverPy\" ) -> None : if self . cmdline : solver . decorators . append ( self ) else : solver . translators . append ( self ) def __str__ ( self ) -> str : return self . limit def __lt__ ( self , other ): if self . limit and not other . limit : return None if self . memory and not other . memory : return None if not self . memory : return ( self . timeout < other . timeout ) else : return ( self . timeout < other . timeout ) or ( self . memory < other . memory ) #def __le__(self, other): # return (self.key == other.key) or (self < other) def decorate ( self , cmd : str , instance : Any , strategy : Any , ) -> str : del instance , strategy # unused arguments if self . cmdline : input = \" /dev/stdin\" if self . _inputfile else \"\" return f \" { cmd } { self . strategy }{ input } \" if self . strategy else cmd else : return cmd def translate ( self , instance : Any , strategy : str , ) -> tuple [ Any , str ]: if not self . cmdline : return ( instance , self . strategy + strategy ) else : return ( instance , strategy ) @property def strategy ( self ) -> str : return self . strat","title":"\ud83e\udd16 limits"},{"location":"api/solverpy/solver/plugins/shell/limits/#module-limits","text":"","title":"module limits"},{"location":"api/solverpy/solver/plugins/shell/limits/#solverpy.solver.plugins.shell.limits","text":"","title":"limits"},{"location":"api/solverpy/solver/plugins/shell/limits/#solverpy.solver.plugins.shell.limits.Limits","text":"Bases: Decorator , Translator This is either a decorator or a translator based on the value of cmdline . Source code in src/solverpy/solver/plugins/shell/limits.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 class Limits ( Decorator , Translator ): \"\"\" This is either a decorator or a translator based on the value of `cmdline`. \"\"\" def __init__ ( self , limit : str , builder : \"LimitBuilder\" , cmdline : bool = True , inputfile : bool = False , ): Plugin . __init__ ( self , limit = limit , cmdline = cmdline , ) lims = { x [ 0 ]: x [ 1 :] for x in limit . split ( \"-\" ) if x } assert \"T\" in lims self . timeout = int ( lims [ \"T\" ]) self . memory = float ( lims [ \"M\" ]) if \"M\" in lims else None try : lims = [ build ( builder [ x ], y ) for ( x , y ) in lims . items () if x in builder ] except Exception as e : print ( e ) raise Exception ( f \"solverpy: Invalid limit string: { limit } \" ) delim = \" \" if cmdline else \"\" self . strat = delim . join ( lims ) self . cmdline = cmdline #self.args = \" \".join(lims) self . limit = limit self . _inputfile = inputfile def register ( self , solver : \"SolverPy\" ) -> None : if self . cmdline : solver . decorators . append ( self ) else : solver . translators . append ( self ) def __str__ ( self ) -> str : return self . limit def __lt__ ( self , other ): if self . limit and not other . limit : return None if self . memory and not other . memory : return None if not self . memory : return ( self . timeout < other . timeout ) else : return ( self . timeout < other . timeout ) or ( self . memory < other . memory ) #def __le__(self, other): # return (self.key == other.key) or (self < other) def decorate ( self , cmd : str , instance : Any , strategy : Any , ) -> str : del instance , strategy # unused arguments if self . cmdline : input = \" /dev/stdin\" if self . _inputfile else \"\" return f \" { cmd } { self . strategy }{ input } \" if self . strategy else cmd else : return cmd def translate ( self , instance : Any , strategy : str , ) -> tuple [ Any , str ]: if not self . cmdline : return ( instance , self . strategy + strategy ) else : return ( instance , strategy ) @property def strategy ( self ) -> str : return self . strat","title":"Limits"},{"location":"api/solverpy/solver/plugins/shell/memory/","text":"module memory solverpy.solver.plugins.shell.memory","title":"\ud83e\udd16 memory"},{"location":"api/solverpy/solver/plugins/shell/memory/#module-memory","text":"","title":"module memory"},{"location":"api/solverpy/solver/plugins/shell/memory/#solverpy.solver.plugins.shell.memory","text":"","title":"memory"},{"location":"api/solverpy/solver/plugins/shell/time/","text":"module time solverpy.solver.plugins.shell.time","title":"\ud83e\udd16 time"},{"location":"api/solverpy/solver/plugins/shell/time/#module-time","text":"","title":"module time"},{"location":"api/solverpy/solver/plugins/shell/time/#solverpy.solver.plugins.shell.time","text":"","title":"time"},{"location":"api/solverpy/solver/plugins/shell/timeout/","text":"module timeout solverpy.solver.plugins.shell.timeout","title":"\ud83e\udd16 timeout"},{"location":"api/solverpy/solver/plugins/shell/timeout/#module-timeout","text":"","title":"module timeout"},{"location":"api/solverpy/solver/plugins/shell/timeout/#solverpy.solver.plugins.shell.timeout","text":"","title":"timeout"},{"location":"api/solverpy/solver/plugins/status/","text":"Status Overview solverpy.solver.plugins.status","title":"\u2139\ufe0f Overview"},{"location":"api/solverpy/solver/plugins/status/#status-overview","text":"","title":"Status Overview"},{"location":"api/solverpy/solver/plugins/status/#solverpy.solver.plugins.status","text":"","title":"status"},{"location":"api/solverpy/solver/plugins/status/limiter/","text":"module limiter solverpy.solver.plugins.status.limiter","title":"\ud83e\udd16 limiter"},{"location":"api/solverpy/solver/plugins/status/limiter/#module-limiter","text":"","title":"module limiter"},{"location":"api/solverpy/solver/plugins/status/limiter/#solverpy.solver.plugins.status.limiter","text":"","title":"limiter"},{"location":"api/solverpy/solver/plugins/status/smt/","text":"module smt solverpy.solver.plugins.status.smt","title":"\ud83e\udd16 smt"},{"location":"api/solverpy/solver/plugins/status/smt/#module-smt","text":"","title":"module smt"},{"location":"api/solverpy/solver/plugins/status/smt/#solverpy.solver.plugins.status.smt","text":"","title":"smt"},{"location":"api/solverpy/solver/plugins/status/tptp/","text":"module tptp solverpy.solver.plugins.status.tptp","title":"\ud83e\udd16 tptp"},{"location":"api/solverpy/solver/plugins/status/tptp/#module-tptp","text":"","title":"module tptp"},{"location":"api/solverpy/solver/plugins/status/tptp/#solverpy.solver.plugins.status.tptp","text":"","title":"tptp"},{"location":"api/solverpy/solver/smt/","text":"Smt Overview solverpy.solver.smt","title":"\u2139\ufe0f Overview"},{"location":"api/solverpy/solver/smt/#smt-overview","text":"","title":"Smt Overview"},{"location":"api/solverpy/solver/smt/#solverpy.solver.smt","text":"","title":"smt"},{"location":"api/solverpy/solver/smt/bitwuzla/","text":"module bitwuzla solverpy.solver.smt.bitwuzla","title":"\ud83e\udd16 bitwuzla"},{"location":"api/solverpy/solver/smt/bitwuzla/#module-bitwuzla","text":"","title":"module bitwuzla"},{"location":"api/solverpy/solver/smt/bitwuzla/#solverpy.solver.smt.bitwuzla","text":"","title":"bitwuzla"},{"location":"api/solverpy/solver/smt/cvc5/","text":"module cvc5 solverpy.solver.smt.cvc5","title":"\ud83e\udd16 cvc5"},{"location":"api/solverpy/solver/smt/cvc5/#module-cvc5","text":"","title":"module cvc5"},{"location":"api/solverpy/solver/smt/cvc5/#solverpy.solver.smt.cvc5","text":"","title":"cvc5"},{"location":"api/solverpy/solver/smt/z3/","text":"module z3 solverpy.solver.smt.z3","title":"\ud83e\udd16 z3"},{"location":"api/solverpy/solver/smt/z3/#module-z3","text":"","title":"module z3"},{"location":"api/solverpy/solver/smt/z3/#solverpy.solver.smt.z3","text":"","title":"z3"},{"location":"api/solverpy/task/","text":"Task Overview solverpy.task","title":"Task Overview"},{"location":"api/solverpy/task/#task-overview","text":"","title":"Task Overview"},{"location":"api/solverpy/task/#solverpy.task","text":"","title":"task"},{"location":"api/solverpy/task/bar/","text":"module bar solverpy.task.bar","title":"\ud83e\udd16 bar"},{"location":"api/solverpy/task/bar/#module-bar","text":"","title":"module bar"},{"location":"api/solverpy/task/bar/#solverpy.task.bar","text":"","title":"bar"},{"location":"api/solverpy/task/launcher/","text":"module launcher solverpy.task.launcher run ( tasks : list [ Task ], cores : int = 4 , chunksize : int = 1 ) -> Any Launch tasks in parallel on multiple cores and return results. :param tasks: list of task to be executed (instances of Task) :param cores: number of worker threads (Default value = 4) :param chunksize: chunksize for Pool.map_async (Default value = 1) Source code in src/solverpy/task/launcher.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 def run ( tasks : list [ \"Task\" ], cores : int = 4 , chunksize : int = 1 , ) -> Any : \"\"\"Launch `tasks` in parallel on multiple cores and return results. :param tasks: list of task to be executed (instances of Task) :param cores: number of worker threads (Default value = 4) :param chunksize: chunksize for Pool.map_async (Default value = 1) \"\"\" pool = mp . get_context ( \"spawn\" ) . Pool ( cores ) try : runner = pool . map_async ( runtask_single , tasks , chunksize = chunksize ) results = runner . get ( WAIT ) pool . close () pool . join () return results except ( Exception , KeyboardInterrupt ): pool . terminate () raise","title":"\ud83e\udd16 launcher"},{"location":"api/solverpy/task/launcher/#module-launcher","text":"","title":"module launcher"},{"location":"api/solverpy/task/launcher/#solverpy.task.launcher","text":"","title":"launcher"},{"location":"api/solverpy/task/launcher/#solverpy.task.launcher.run","text":"Launch tasks in parallel on multiple cores and return results. :param tasks: list of task to be executed (instances of Task) :param cores: number of worker threads (Default value = 4) :param chunksize: chunksize for Pool.map_async (Default value = 1) Source code in src/solverpy/task/launcher.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 def run ( tasks : list [ \"Task\" ], cores : int = 4 , chunksize : int = 1 , ) -> Any : \"\"\"Launch `tasks` in parallel on multiple cores and return results. :param tasks: list of task to be executed (instances of Task) :param cores: number of worker threads (Default value = 4) :param chunksize: chunksize for Pool.map_async (Default value = 1) \"\"\" pool = mp . get_context ( \"spawn\" ) . Pool ( cores ) try : runner = pool . map_async ( runtask_single , tasks , chunksize = chunksize ) results = runner . get ( WAIT ) pool . close () pool . join () return results except ( Exception , KeyboardInterrupt ): pool . terminate () raise","title":"run"},{"location":"api/solverpy/task/logtalker/","text":"module logtalker solverpy.task.logtalker","title":"module logtalker"},{"location":"api/solverpy/task/logtalker/#module-logtalker","text":"","title":"module logtalker"},{"location":"api/solverpy/task/logtalker/#solverpy.task.logtalker","text":"","title":"logtalker"},{"location":"api/solverpy/task/remotetalker/","text":"module remotetalker solverpy.task.remotetalker RemoteTalker Bases: Talker Source code in src/solverpy/task/remotetalker.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 class RemoteTalker ( Talker ): REMOTES = { \"log_config\" , \"log_start\" , \"log_stop\" , \"begin\" , \"end\" , \"next\" , \"terminate\" , \"launching\" , \"finished\" , \"done\" , } def __init__ ( self , local : Talker ): Talker . __init__ ( self ) manager = multiprocessing . get_context ( \"spawn\" ) . Manager () self . _remote_queue = manager . Queue () self . _listening_thread = None self . _stop_listening = threading . Event () self . _local = local def __getattribute__ ( self , name ): if name in RemoteTalker . REMOTES : def wrapper ( * args , ** kwargs ): queue = object . __getattribute__ ( self , '_remote_queue' ) queue . put (( name , args , kwargs )) return wrapper return super () . __getattribute__ ( name ) def listening_start ( self ): \"\"\"Start listening thread (non-blocking).\"\"\" super () . listening_start () if self . _listening_thread and self . _listening_thread . is_alive (): logger . warning ( \"Listening thread already running\" ) return self . _stop_listening . clear () self . _listening_thread = threading . Thread ( target = self . _listen_loop , daemon = True , ) self . _listening_thread . start () def listening_stop ( self ): \"\"\"Stop the listening thread.\"\"\" super () . listening_stop () if not ( self . _listening_thread and self . _listening_thread . is_alive ()): logger . warning ( \"No listening thread to stop\" ) return self . _stop_listening . set () self . _listening_thread . join ( timeout = 2.0 ) self . _listening_thread = None def _listen_loop ( self ): \"\"\"Internal method that runs in the listening thread.\"\"\" while not self . _stop_listening . is_set (): try : # Block until item arrives or timeout method , args , kwargs = self . _remote_queue . get ( timeout = 0.2 ) self . listening_handle ( method , args , kwargs ) except : # Timeout occurred, check stop flag and loop again pass def listening_handle ( self , method , args , kwargs ): \"\"\"Handle received method calls by delegating to local talker.\"\"\" assert method in RemoteTalker . REMOTES handler = None try : handler = getattr ( self . _local , method ) except AttributeError : logger . error ( f \"Method ' { method } ' not found on local talker \\n { self . _local } \\n { dir ( self . _local ) } \" ) assert handler try : handler ( * args , ** kwargs ) except Exception as e : logger . error ( f \"Error calling { method } : { e } \" , exc_info = True ) listening_handle ( method , args , kwargs ) Handle received method calls by delegating to local talker. Source code in src/solverpy/task/remotetalker.py 80 81 82 83 84 85 86 87 88 89 90 91 92 def listening_handle ( self , method , args , kwargs ): \"\"\"Handle received method calls by delegating to local talker.\"\"\" assert method in RemoteTalker . REMOTES handler = None try : handler = getattr ( self . _local , method ) except AttributeError : logger . error ( f \"Method ' { method } ' not found on local talker \\n { self . _local } \\n { dir ( self . _local ) } \" ) assert handler try : handler ( * args , ** kwargs ) except Exception as e : logger . error ( f \"Error calling { method } : { e } \" , exc_info = True ) listening_start () Start listening thread (non-blocking). Source code in src/solverpy/task/remotetalker.py 44 45 46 47 48 49 50 51 52 53 54 55 56 def listening_start ( self ): \"\"\"Start listening thread (non-blocking).\"\"\" super () . listening_start () if self . _listening_thread and self . _listening_thread . is_alive (): logger . warning ( \"Listening thread already running\" ) return self . _stop_listening . clear () self . _listening_thread = threading . Thread ( target = self . _listen_loop , daemon = True , ) self . _listening_thread . start () listening_stop () Stop the listening thread. Source code in src/solverpy/task/remotetalker.py 58 59 60 61 62 63 64 65 66 67 def listening_stop ( self ): \"\"\"Stop the listening thread.\"\"\" super () . listening_stop () if not ( self . _listening_thread and self . _listening_thread . is_alive ()): logger . warning ( \"No listening thread to stop\" ) return self . _stop_listening . set () self . _listening_thread . join ( timeout = 2.0 ) self . _listening_thread = None","title":"module remotetalker"},{"location":"api/solverpy/task/remotetalker/#module-remotetalker","text":"","title":"module remotetalker"},{"location":"api/solverpy/task/remotetalker/#solverpy.task.remotetalker","text":"","title":"remotetalker"},{"location":"api/solverpy/task/remotetalker/#solverpy.task.remotetalker.RemoteTalker","text":"Bases: Talker Source code in src/solverpy/task/remotetalker.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 class RemoteTalker ( Talker ): REMOTES = { \"log_config\" , \"log_start\" , \"log_stop\" , \"begin\" , \"end\" , \"next\" , \"terminate\" , \"launching\" , \"finished\" , \"done\" , } def __init__ ( self , local : Talker ): Talker . __init__ ( self ) manager = multiprocessing . get_context ( \"spawn\" ) . Manager () self . _remote_queue = manager . Queue () self . _listening_thread = None self . _stop_listening = threading . Event () self . _local = local def __getattribute__ ( self , name ): if name in RemoteTalker . REMOTES : def wrapper ( * args , ** kwargs ): queue = object . __getattribute__ ( self , '_remote_queue' ) queue . put (( name , args , kwargs )) return wrapper return super () . __getattribute__ ( name ) def listening_start ( self ): \"\"\"Start listening thread (non-blocking).\"\"\" super () . listening_start () if self . _listening_thread and self . _listening_thread . is_alive (): logger . warning ( \"Listening thread already running\" ) return self . _stop_listening . clear () self . _listening_thread = threading . Thread ( target = self . _listen_loop , daemon = True , ) self . _listening_thread . start () def listening_stop ( self ): \"\"\"Stop the listening thread.\"\"\" super () . listening_stop () if not ( self . _listening_thread and self . _listening_thread . is_alive ()): logger . warning ( \"No listening thread to stop\" ) return self . _stop_listening . set () self . _listening_thread . join ( timeout = 2.0 ) self . _listening_thread = None def _listen_loop ( self ): \"\"\"Internal method that runs in the listening thread.\"\"\" while not self . _stop_listening . is_set (): try : # Block until item arrives or timeout method , args , kwargs = self . _remote_queue . get ( timeout = 0.2 ) self . listening_handle ( method , args , kwargs ) except : # Timeout occurred, check stop flag and loop again pass def listening_handle ( self , method , args , kwargs ): \"\"\"Handle received method calls by delegating to local talker.\"\"\" assert method in RemoteTalker . REMOTES handler = None try : handler = getattr ( self . _local , method ) except AttributeError : logger . error ( f \"Method ' { method } ' not found on local talker \\n { self . _local } \\n { dir ( self . _local ) } \" ) assert handler try : handler ( * args , ** kwargs ) except Exception as e : logger . error ( f \"Error calling { method } : { e } \" , exc_info = True )","title":"RemoteTalker"},{"location":"api/solverpy/task/remotetalker/#solverpy.task.remotetalker.RemoteTalker.listening_handle","text":"Handle received method calls by delegating to local talker. Source code in src/solverpy/task/remotetalker.py 80 81 82 83 84 85 86 87 88 89 90 91 92 def listening_handle ( self , method , args , kwargs ): \"\"\"Handle received method calls by delegating to local talker.\"\"\" assert method in RemoteTalker . REMOTES handler = None try : handler = getattr ( self . _local , method ) except AttributeError : logger . error ( f \"Method ' { method } ' not found on local talker \\n { self . _local } \\n { dir ( self . _local ) } \" ) assert handler try : handler ( * args , ** kwargs ) except Exception as e : logger . error ( f \"Error calling { method } : { e } \" , exc_info = True )","title":"listening_handle"},{"location":"api/solverpy/task/remotetalker/#solverpy.task.remotetalker.RemoteTalker.listening_start","text":"Start listening thread (non-blocking). Source code in src/solverpy/task/remotetalker.py 44 45 46 47 48 49 50 51 52 53 54 55 56 def listening_start ( self ): \"\"\"Start listening thread (non-blocking).\"\"\" super () . listening_start () if self . _listening_thread and self . _listening_thread . is_alive (): logger . warning ( \"Listening thread already running\" ) return self . _stop_listening . clear () self . _listening_thread = threading . Thread ( target = self . _listen_loop , daemon = True , ) self . _listening_thread . start ()","title":"listening_start"},{"location":"api/solverpy/task/remotetalker/#solverpy.task.remotetalker.RemoteTalker.listening_stop","text":"Stop the listening thread. Source code in src/solverpy/task/remotetalker.py 58 59 60 61 62 63 64 65 66 67 def listening_stop ( self ): \"\"\"Stop the listening thread.\"\"\" super () . listening_stop () if not ( self . _listening_thread and self . _listening_thread . is_alive ()): logger . warning ( \"No listening thread to stop\" ) return self . _stop_listening . set () self . _listening_thread . join ( timeout = 2.0 ) self . _listening_thread = None","title":"listening_stop"},{"location":"api/solverpy/task/shelltask/","text":"module shelltask solverpy.task.shelltask","title":"\ud83e\udd16 shelltask"},{"location":"api/solverpy/task/shelltask/#module-shelltask","text":"","title":"module shelltask"},{"location":"api/solverpy/task/shelltask/#solverpy.task.shelltask","text":"","title":"shelltask"},{"location":"api/solverpy/task/solvertalker/","text":"module solvertalker solverpy.task.solvertalker","title":"module solvertalker"},{"location":"api/solverpy/task/solvertalker/#module-solvertalker","text":"","title":"module solvertalker"},{"location":"api/solverpy/task/solvertalker/#solverpy.task.solvertalker","text":"","title":"solvertalker"},{"location":"api/solverpy/task/solvertask/","text":"module solvertask solverpy.task.solvertask Defines the SolverTask class. SolverTask Bases: Task Represents a task to be executed by a SolverPy solver. This is a basic interface for the database which stores results of SolverTask . Source code in src/solverpy/task/solvertask.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 class SolverTask ( Task ): \"\"\" Represents a task to be executed by a [`SolverPy`][solverpy.solver.solverpy.SolverPy] solver. This is a basic interface for the database which stores results of [`SolverTask`][solverpy.task.solvertask.SolverTask]. \"\"\" def __init__ ( self , solver : \"SolverPy\" , bid : str , sid : str , problem : str , calls : list [ tuple [ str , str , Any , Any ]] = [], ): \"\"\" Create a new task to execute `solver` on problem `problem` from benchmark `bid` using strategy `sid`. Args: solver: the solver based on [`SolverPy`][solverpy.solver.solverpy.SolverPy] bid: the benchmark id sid: the strategy id problem: the problem from the benchmark calls: the plugin calls to be executed before solving the task \"\"\" Task . __init__ ( self ) self . _solver = solver self . bid = bid self . sid = sid self . problem = problem self . _calls = calls def __str__ ( self ) -> str : return f \" { self . solver } : { self . sid } @ { self . bid } / { self . problem } \" def __eq__ ( self , other ): if not isinstance ( other , self . __class__ ): return False return ( f \" { self . solver } \" == f \" { other . solver } \" \\ and self . bid == other . bid \\ and self . sid == other . sid \\ and self . problem == other . problem ) def __hash__ ( self ): return hash (( str ( self . solver ), self . bid , self . sid , self . problem , )) def run ( self ) -> \"Result\" : \"\"\" Run the task and return the result. First, plugin calls from `calls` given to the constructor are executed on the [`solver`][solverpy.task.solvertask.SolverTask.solver]. Then, [`SolverPy.solve`][solverpy.solver.solverpy.SolverPy.solve] is called on [`instance`][solverpy.task.solvertask.SolverTask.instance] and [`strategy`][solverpy.task.solvertask.SolverTask.strategy]. Returns: the result dictionary \"\"\" if self . logqueue : Talker . log_config ( self . logqueue ) for ( pid , method , args , kwargs ) in self . _calls : self . solver . call ( pid , method , * args , ** kwargs ) return self . solver . solve ( self . instance , self . strategy ) def status ( self , result : \"Result\" ) -> bool | None : \"\"\" Translate the result to (typically smaller) status to send it over the queue. Args: result: the result Returns: the status \"\"\" if not self . solver . valid ( result ): return None return self . solver . solved ( result ) @property def instance ( self ) -> tuple [ str , str ]: \"\"\" Get the instance of this solver task as a benchmark-problem pair. Returns: the pair of benchmark id and problem name \"\"\" return ( self . bid , self . problem ) @property def strategy ( self ) -> str : \"\"\" Get the strategy of this solver task as a strategy id. Returns: the strategy \"\"\" return self . sid @property def solver ( self ) -> \"SolverPy\" : \"\"\" Get the [`SolverPy`][solverpy.solver.solverpy.SolverPy] solver of this solver task. Returns: the solver \"\"\" return self . _solver instance : tuple [ str , str ] property Get the instance of this solver task as a benchmark-problem pair. Returns: Type Description tuple [ str , str ] the pair of benchmark id and problem name solver : SolverPy property Get the SolverPy solver of this solver task. Returns: Type Description SolverPy the solver strategy : str property Get the strategy of this solver task as a strategy id. Returns: Type Description str the strategy __init__ ( solver : SolverPy , bid : str , sid : str , problem : str , calls : list [ tuple [ str , str , Any , Any ]] = []) Create a new task to execute solver on problem problem from benchmark bid using strategy sid . Parameters: Name Type Description Default solver SolverPy the solver based on SolverPy required bid str the benchmark id required sid str the strategy id required problem str the problem from the benchmark required calls list [ tuple [ str , str , Any , Any ]] the plugin calls to be executed before solving the task [] Source code in src/solverpy/task/solvertask.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 def __init__ ( self , solver : \"SolverPy\" , bid : str , sid : str , problem : str , calls : list [ tuple [ str , str , Any , Any ]] = [], ): \"\"\" Create a new task to execute `solver` on problem `problem` from benchmark `bid` using strategy `sid`. Args: solver: the solver based on [`SolverPy`][solverpy.solver.solverpy.SolverPy] bid: the benchmark id sid: the strategy id problem: the problem from the benchmark calls: the plugin calls to be executed before solving the task \"\"\" Task . __init__ ( self ) self . _solver = solver self . bid = bid self . sid = sid self . problem = problem self . _calls = calls run () -> Result Run the task and return the result. First, plugin calls from calls given to the constructor are executed on the solver . Then, SolverPy.solve is called on instance and strategy . Returns: Type Description Result the result dictionary Source code in src/solverpy/task/solvertask.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 def run ( self ) -> \"Result\" : \"\"\" Run the task and return the result. First, plugin calls from `calls` given to the constructor are executed on the [`solver`][solverpy.task.solvertask.SolverTask.solver]. Then, [`SolverPy.solve`][solverpy.solver.solverpy.SolverPy.solve] is called on [`instance`][solverpy.task.solvertask.SolverTask.instance] and [`strategy`][solverpy.task.solvertask.SolverTask.strategy]. Returns: the result dictionary \"\"\" if self . logqueue : Talker . log_config ( self . logqueue ) for ( pid , method , args , kwargs ) in self . _calls : self . solver . call ( pid , method , * args , ** kwargs ) return self . solver . solve ( self . instance , self . strategy ) status ( result : Result ) -> bool | None Translate the result to (typically smaller) status to send it over the queue. Parameters: Name Type Description Default result Result the result required Returns: Type Description bool | None the status Source code in src/solverpy/task/solvertask.py 86 87 88 89 90 91 92 93 94 95 96 97 98 99 def status ( self , result : \"Result\" ) -> bool | None : \"\"\" Translate the result to (typically smaller) status to send it over the queue. Args: result: the result Returns: the status \"\"\" if not self . solver . valid ( result ): return None return self . solver . solved ( result )","title":"\ud83e\udd16 solvertask"},{"location":"api/solverpy/task/solvertask/#module-solvertask","text":"","title":"module solvertask"},{"location":"api/solverpy/task/solvertask/#solverpy.task.solvertask","text":"Defines the SolverTask class.","title":"solvertask"},{"location":"api/solverpy/task/solvertask/#solverpy.task.solvertask.SolverTask","text":"Bases: Task Represents a task to be executed by a SolverPy solver. This is a basic interface for the database which stores results of SolverTask . Source code in src/solverpy/task/solvertask.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 class SolverTask ( Task ): \"\"\" Represents a task to be executed by a [`SolverPy`][solverpy.solver.solverpy.SolverPy] solver. This is a basic interface for the database which stores results of [`SolverTask`][solverpy.task.solvertask.SolverTask]. \"\"\" def __init__ ( self , solver : \"SolverPy\" , bid : str , sid : str , problem : str , calls : list [ tuple [ str , str , Any , Any ]] = [], ): \"\"\" Create a new task to execute `solver` on problem `problem` from benchmark `bid` using strategy `sid`. Args: solver: the solver based on [`SolverPy`][solverpy.solver.solverpy.SolverPy] bid: the benchmark id sid: the strategy id problem: the problem from the benchmark calls: the plugin calls to be executed before solving the task \"\"\" Task . __init__ ( self ) self . _solver = solver self . bid = bid self . sid = sid self . problem = problem self . _calls = calls def __str__ ( self ) -> str : return f \" { self . solver } : { self . sid } @ { self . bid } / { self . problem } \" def __eq__ ( self , other ): if not isinstance ( other , self . __class__ ): return False return ( f \" { self . solver } \" == f \" { other . solver } \" \\ and self . bid == other . bid \\ and self . sid == other . sid \\ and self . problem == other . problem ) def __hash__ ( self ): return hash (( str ( self . solver ), self . bid , self . sid , self . problem , )) def run ( self ) -> \"Result\" : \"\"\" Run the task and return the result. First, plugin calls from `calls` given to the constructor are executed on the [`solver`][solverpy.task.solvertask.SolverTask.solver]. Then, [`SolverPy.solve`][solverpy.solver.solverpy.SolverPy.solve] is called on [`instance`][solverpy.task.solvertask.SolverTask.instance] and [`strategy`][solverpy.task.solvertask.SolverTask.strategy]. Returns: the result dictionary \"\"\" if self . logqueue : Talker . log_config ( self . logqueue ) for ( pid , method , args , kwargs ) in self . _calls : self . solver . call ( pid , method , * args , ** kwargs ) return self . solver . solve ( self . instance , self . strategy ) def status ( self , result : \"Result\" ) -> bool | None : \"\"\" Translate the result to (typically smaller) status to send it over the queue. Args: result: the result Returns: the status \"\"\" if not self . solver . valid ( result ): return None return self . solver . solved ( result ) @property def instance ( self ) -> tuple [ str , str ]: \"\"\" Get the instance of this solver task as a benchmark-problem pair. Returns: the pair of benchmark id and problem name \"\"\" return ( self . bid , self . problem ) @property def strategy ( self ) -> str : \"\"\" Get the strategy of this solver task as a strategy id. Returns: the strategy \"\"\" return self . sid @property def solver ( self ) -> \"SolverPy\" : \"\"\" Get the [`SolverPy`][solverpy.solver.solverpy.SolverPy] solver of this solver task. Returns: the solver \"\"\" return self . _solver","title":"SolverTask"},{"location":"api/solverpy/task/solvertask/#solverpy.task.solvertask.SolverTask.instance","text":"Get the instance of this solver task as a benchmark-problem pair. Returns: Type Description tuple [ str , str ] the pair of benchmark id and problem name","title":"instance"},{"location":"api/solverpy/task/solvertask/#solverpy.task.solvertask.SolverTask.solver","text":"Get the SolverPy solver of this solver task. Returns: Type Description SolverPy the solver","title":"solver"},{"location":"api/solverpy/task/solvertask/#solverpy.task.solvertask.SolverTask.strategy","text":"Get the strategy of this solver task as a strategy id. Returns: Type Description str the strategy","title":"strategy"},{"location":"api/solverpy/task/solvertask/#solverpy.task.solvertask.SolverTask.__init__","text":"Create a new task to execute solver on problem problem from benchmark bid using strategy sid . Parameters: Name Type Description Default solver SolverPy the solver based on SolverPy required bid str the benchmark id required sid str the strategy id required problem str the problem from the benchmark required calls list [ tuple [ str , str , Any , Any ]] the plugin calls to be executed before solving the task [] Source code in src/solverpy/task/solvertask.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 def __init__ ( self , solver : \"SolverPy\" , bid : str , sid : str , problem : str , calls : list [ tuple [ str , str , Any , Any ]] = [], ): \"\"\" Create a new task to execute `solver` on problem `problem` from benchmark `bid` using strategy `sid`. Args: solver: the solver based on [`SolverPy`][solverpy.solver.solverpy.SolverPy] bid: the benchmark id sid: the strategy id problem: the problem from the benchmark calls: the plugin calls to be executed before solving the task \"\"\" Task . __init__ ( self ) self . _solver = solver self . bid = bid self . sid = sid self . problem = problem self . _calls = calls","title":"__init__"},{"location":"api/solverpy/task/solvertask/#solverpy.task.solvertask.SolverTask.run","text":"Run the task and return the result. First, plugin calls from calls given to the constructor are executed on the solver . Then, SolverPy.solve is called on instance and strategy . Returns: Type Description Result the result dictionary Source code in src/solverpy/task/solvertask.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 def run ( self ) -> \"Result\" : \"\"\" Run the task and return the result. First, plugin calls from `calls` given to the constructor are executed on the [`solver`][solverpy.task.solvertask.SolverTask.solver]. Then, [`SolverPy.solve`][solverpy.solver.solverpy.SolverPy.solve] is called on [`instance`][solverpy.task.solvertask.SolverTask.instance] and [`strategy`][solverpy.task.solvertask.SolverTask.strategy]. Returns: the result dictionary \"\"\" if self . logqueue : Talker . log_config ( self . logqueue ) for ( pid , method , args , kwargs ) in self . _calls : self . solver . call ( pid , method , * args , ** kwargs ) return self . solver . solve ( self . instance , self . strategy )","title":"run"},{"location":"api/solverpy/task/solvertask/#solverpy.task.solvertask.SolverTask.status","text":"Translate the result to (typically smaller) status to send it over the queue. Parameters: Name Type Description Default result Result the result required Returns: Type Description bool | None the status Source code in src/solverpy/task/solvertask.py 86 87 88 89 90 91 92 93 94 95 96 97 98 99 def status ( self , result : \"Result\" ) -> bool | None : \"\"\" Translate the result to (typically smaller) status to send it over the queue. Args: result: the result Returns: the status \"\"\" if not self . solver . valid ( result ): return None return self . solver . solved ( result )","title":"status"},{"location":"api/solverpy/task/talker/","text":"module talker solverpy.task.talker Talker Source code in src/solverpy/task/talker.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 class Talker : def __init__ ( self ): self . _log_queue : Queue [ Any ] | None = None @staticmethod def log_config ( queue ): \"\"\"Configure child process logger to use the queue.\"\"\" if not queue : return logger . debug ( \"redirecting logger to the queue\" ) root = logging . getLogger () root . handlers . clear () for name in logging . root . manager . loggerDict : logging . getLogger ( name ) . handlers . clear () root . addHandler ( QueueHandler ( queue )) root . setLevel ( logging . INFO ) logger . debug ( \"logging redirected\" ) def log_start ( self ): \"\"\"Start parent logging from the queue.\"\"\" root = logging . getLogger () self . _log_queue = mp . get_context ( \"spawn\" ) . Manager () . Queue () self . _listener = QueueListener ( self . _log_queue , * root . handlers ) self . _listener . start () def log_stop ( self ): \"\"\"Stop parent logging from the queue.\"\"\" if self . _listener : self . _listener . stop () self . _listener = None #logging.getLogger().handlers = self._handlers.copy() def listening_start ( self ): self . log_start () def listening_stop ( self ): self . log_stop () #def begin(self, total: int, *, desc: str, **kwargs): # del total, desc, kwargs # unused arguments # raise NotImplementedError( # \"Talker.begin: abstract method not implemented.\") def begin ( self , jobs : list [ \"SolverJob\" ], * , refjob : \"SolverJob | None\" = None , sidnames : bool = True , ** kwargs , ): del jobs , refjob , sidnames , kwargs raise NotImplementedError ( \"Talker.begin: abstract method not implemented.\" ) def end ( self , results : dict [ \"SolverJob\" , \"Result\" ], refjob : \"SolverJob | None\" = None , ): del results , refjob # unused arguments self . terminate () def next ( self , job : \"SolverJob\" ): del job # unused arguments pass def terminate ( self ): pass def launching ( self , tasks : Sequence [ \"Task\" ]): if self . _log_queue is None : return for task in tasks : task . logqueue = self . _log_queue def finished ( self , task : \"SolverTask\" , result : \"Result\" ): del task , result # unused arguments pass def done ( self ): pass log_config ( queue ) staticmethod Configure child process logger to use the queue. Source code in src/solverpy/task/talker.py 21 22 23 24 25 26 27 28 29 30 31 32 33 @staticmethod def log_config ( queue ): \"\"\"Configure child process logger to use the queue.\"\"\" if not queue : return logger . debug ( \"redirecting logger to the queue\" ) root = logging . getLogger () root . handlers . clear () for name in logging . root . manager . loggerDict : logging . getLogger ( name ) . handlers . clear () root . addHandler ( QueueHandler ( queue )) root . setLevel ( logging . INFO ) logger . debug ( \"logging redirected\" ) log_start () Start parent logging from the queue. Source code in src/solverpy/task/talker.py 35 36 37 38 39 40 def log_start ( self ): \"\"\"Start parent logging from the queue.\"\"\" root = logging . getLogger () self . _log_queue = mp . get_context ( \"spawn\" ) . Manager () . Queue () self . _listener = QueueListener ( self . _log_queue , * root . handlers ) self . _listener . start () log_stop () Stop parent logging from the queue. Source code in src/solverpy/task/talker.py 42 43 44 45 46 def log_stop ( self ): \"\"\"Stop parent logging from the queue.\"\"\" if self . _listener : self . _listener . stop () self . _listener = None","title":"module talker"},{"location":"api/solverpy/task/talker/#module-talker","text":"","title":"module talker"},{"location":"api/solverpy/task/talker/#solverpy.task.talker","text":"","title":"talker"},{"location":"api/solverpy/task/talker/#solverpy.task.talker.Talker","text":"Source code in src/solverpy/task/talker.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 class Talker : def __init__ ( self ): self . _log_queue : Queue [ Any ] | None = None @staticmethod def log_config ( queue ): \"\"\"Configure child process logger to use the queue.\"\"\" if not queue : return logger . debug ( \"redirecting logger to the queue\" ) root = logging . getLogger () root . handlers . clear () for name in logging . root . manager . loggerDict : logging . getLogger ( name ) . handlers . clear () root . addHandler ( QueueHandler ( queue )) root . setLevel ( logging . INFO ) logger . debug ( \"logging redirected\" ) def log_start ( self ): \"\"\"Start parent logging from the queue.\"\"\" root = logging . getLogger () self . _log_queue = mp . get_context ( \"spawn\" ) . Manager () . Queue () self . _listener = QueueListener ( self . _log_queue , * root . handlers ) self . _listener . start () def log_stop ( self ): \"\"\"Stop parent logging from the queue.\"\"\" if self . _listener : self . _listener . stop () self . _listener = None #logging.getLogger().handlers = self._handlers.copy() def listening_start ( self ): self . log_start () def listening_stop ( self ): self . log_stop () #def begin(self, total: int, *, desc: str, **kwargs): # del total, desc, kwargs # unused arguments # raise NotImplementedError( # \"Talker.begin: abstract method not implemented.\") def begin ( self , jobs : list [ \"SolverJob\" ], * , refjob : \"SolverJob | None\" = None , sidnames : bool = True , ** kwargs , ): del jobs , refjob , sidnames , kwargs raise NotImplementedError ( \"Talker.begin: abstract method not implemented.\" ) def end ( self , results : dict [ \"SolverJob\" , \"Result\" ], refjob : \"SolverJob | None\" = None , ): del results , refjob # unused arguments self . terminate () def next ( self , job : \"SolverJob\" ): del job # unused arguments pass def terminate ( self ): pass def launching ( self , tasks : Sequence [ \"Task\" ]): if self . _log_queue is None : return for task in tasks : task . logqueue = self . _log_queue def finished ( self , task : \"SolverTask\" , result : \"Result\" ): del task , result # unused arguments pass def done ( self ): pass","title":"Talker"},{"location":"api/solverpy/task/talker/#solverpy.task.talker.Talker.log_config","text":"Configure child process logger to use the queue. Source code in src/solverpy/task/talker.py 21 22 23 24 25 26 27 28 29 30 31 32 33 @staticmethod def log_config ( queue ): \"\"\"Configure child process logger to use the queue.\"\"\" if not queue : return logger . debug ( \"redirecting logger to the queue\" ) root = logging . getLogger () root . handlers . clear () for name in logging . root . manager . loggerDict : logging . getLogger ( name ) . handlers . clear () root . addHandler ( QueueHandler ( queue )) root . setLevel ( logging . INFO ) logger . debug ( \"logging redirected\" )","title":"log_config"},{"location":"api/solverpy/task/talker/#solverpy.task.talker.Talker.log_start","text":"Start parent logging from the queue. Source code in src/solverpy/task/talker.py 35 36 37 38 39 40 def log_start ( self ): \"\"\"Start parent logging from the queue.\"\"\" root = logging . getLogger () self . _log_queue = mp . get_context ( \"spawn\" ) . Manager () . Queue () self . _listener = QueueListener ( self . _log_queue , * root . handlers ) self . _listener . start ()","title":"log_start"},{"location":"api/solverpy/task/talker/#solverpy.task.talker.Talker.log_stop","text":"Stop parent logging from the queue. Source code in src/solverpy/task/talker.py 42 43 44 45 46 def log_stop ( self ): \"\"\"Stop parent logging from the queue.\"\"\" if self . _listener : self . _listener . stop () self . _listener = None","title":"log_stop"},{"location":"api/solverpy/task/task/","text":"module task solverpy.task.task Task A generic executable task/job. Represents a task that can be executed. The result can be returned or communicated over a queue. The abstract method run should run the task and return the result. Tasks are typically executed in different threads. Hence modification to the Task instance might not be visible to the main thread. Also the returned result should be as small as possible to limit inter-process communication. Alternatively, the communication queue can be used to send the result to the main thread. If the queue is set, the result is transformed to the status and this status is pushed onto the queue (see Task.runtask ). Status is also propagated to the progress bar using the status bar handler (see RunningBar.status ). DefaultBar ignores the status. RunningBar expects the status for failed tasks to be None, and non-None otherwise. SolvingBar expects True for solved tasks, False for unsolved, and None for failed tasks. Source code in src/solverpy/task/task.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 class Task : \"\"\"A generic executable task/job. Represents a task that can be executed. The result can be returned or communicated over a queue. The abstract method `run` should run the task and return the result. Tasks are typically executed in different threads. Hence modification to the Task instance might not be visible to the main thread. Also the returned result should be as small as possible to limit inter-process communication. Alternatively, the communication queue can be used to send the result to the main thread. If the queue is set, the result is transformed to the `status` and this status is pushed onto the queue (see `Task.runtask`). Status is also propagated to the progress bar using the `status` bar handler (see `RunningBar.status`). `DefaultBar` ignores the status. `RunningBar` expects the status for failed tasks to be None, and non-None otherwise. `SolvingBar` expects `True` for solved tasks, `False` for unsolved, and `None` for failed tasks. \"\"\" def __init__ ( self , queue : \"Queue[Any] | None\" = None , talker : \"Talker | None\" = None , ): \"\"\"Init the task. :param queue: communication queue (optional) \"\"\" self . _log_queue = queue self . _talker = talker def run ( self ) -> Any : \"\"\"Run the task and return the result.\"\"\" raise NotImplementedError ( \"Task.run: abstract method not implemented.\" ) @property def logqueue ( self ) -> \"Queue[Any] | None\" : \"\"\"Get the queue.\"\"\" return self . _log_queue @logqueue . setter def logqueue ( self , q : \"Queue[Any]\" ): \"\"\"Set the queue. :param q: the queue \"\"\" self . _log_queue = q #@property #def talker(self) -> \"Talker | None\": # \"\"\"Get the talker.\"\"\" # return self._talker #@talker.setter #def talker(self, talker: \"Talker | None\"): # \"\"\"Set the talker. # :param t: the talker # \"\"\" # self._talker = talker def status ( self , result : Any , ) -> Any : \"\"\"Translate the result to (typically smaller) status to send it over the queue.\" :param result: the result \"\"\" return ( result is not None ) @staticmethod def runtask ( task : \"Task\" ): \"\"\"Run the task andd announce the result over the queue. :param task: the task to be ran \"\"\" signal . signal ( signal . SIGINT , signal . SIG_IGN ) try : res = task . run () status = task . status ( res ) except Exception as e : import traceback logger . warning ( f \"Exception:: { e } \" ) logger . warning ( f \"Task:: { task } \" ) logger . warning ( f \"Error:: { traceback . format_exc () } \" ) status = None res = None #except KeyboardInterrupt as e: # raise e # #return None if status is None : logger . debug ( f \"failed task: { task } \" ) #if task.queue is not None: # task.queue.put(status) return res logqueue : Queue [ Any ] | None property writable Get the queue. __init__ ( queue : Queue [ Any ] | None = None , talker : Talker | None = None ) Init the task. :param queue: communication queue (optional) Source code in src/solverpy/task/task.py 35 36 37 38 39 40 41 42 43 44 45 46 def __init__ ( self , queue : \"Queue[Any] | None\" = None , talker : \"Talker | None\" = None , ): \"\"\"Init the task. :param queue: communication queue (optional) \"\"\" self . _log_queue = queue self . _talker = talker run () -> Any Run the task and return the result. Source code in src/solverpy/task/task.py 48 49 50 def run ( self ) -> Any : \"\"\"Run the task and return the result.\"\"\" raise NotImplementedError ( \"Task.run: abstract method not implemented.\" ) runtask ( task : Task ) staticmethod Run the task andd announce the result over the queue. :param task: the task to be ran Source code in src/solverpy/task/task.py 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 @staticmethod def runtask ( task : \"Task\" ): \"\"\"Run the task andd announce the result over the queue. :param task: the task to be ran \"\"\" signal . signal ( signal . SIGINT , signal . SIG_IGN ) try : res = task . run () status = task . status ( res ) except Exception as e : import traceback logger . warning ( f \"Exception:: { e } \" ) logger . warning ( f \"Task:: { task } \" ) logger . warning ( f \"Error:: { traceback . format_exc () } \" ) status = None res = None #except KeyboardInterrupt as e: # raise e # #return None if status is None : logger . debug ( f \"failed task: { task } \" ) #if task.queue is not None: # task.queue.put(status) return res status ( result : Any ) -> Any Translate the result to (typically smaller) status to send it over the queue.\" :param result: the result Source code in src/solverpy/task/task.py 80 81 82 83 84 85 86 87 88 89 90 def status ( self , result : Any , ) -> Any : \"\"\"Translate the result to (typically smaller) status to send it over the queue.\" :param result: the result \"\"\" return ( result is not None ) runtask ( task : Task ) -> Any Run task and return the result. :param task: Source code in src/solverpy/task/task.py 129 130 131 132 133 134 135 def runtask ( task : Task ) -> Any : \"\"\"Run task and return the result. :param task: \"\"\" return ( task , task . runtask ( task )) runtask_single ( task : Task ) -> Any Run task and return the result. :param task: Source code in src/solverpy/task/task.py 120 121 122 123 124 125 126 def runtask_single ( task : Task ) -> Any : \"\"\"Run task and return the result. :param task: \"\"\" return task . runtask ( task )","title":"\ud83e\udd16 task"},{"location":"api/solverpy/task/task/#module-task","text":"","title":"module task"},{"location":"api/solverpy/task/task/#solverpy.task.task","text":"","title":"task"},{"location":"api/solverpy/task/task/#solverpy.task.task.Task","text":"A generic executable task/job. Represents a task that can be executed. The result can be returned or communicated over a queue. The abstract method run should run the task and return the result. Tasks are typically executed in different threads. Hence modification to the Task instance might not be visible to the main thread. Also the returned result should be as small as possible to limit inter-process communication. Alternatively, the communication queue can be used to send the result to the main thread. If the queue is set, the result is transformed to the status and this status is pushed onto the queue (see Task.runtask ). Status is also propagated to the progress bar using the status bar handler (see RunningBar.status ). DefaultBar ignores the status. RunningBar expects the status for failed tasks to be None, and non-None otherwise. SolvingBar expects True for solved tasks, False for unsolved, and None for failed tasks. Source code in src/solverpy/task/task.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 class Task : \"\"\"A generic executable task/job. Represents a task that can be executed. The result can be returned or communicated over a queue. The abstract method `run` should run the task and return the result. Tasks are typically executed in different threads. Hence modification to the Task instance might not be visible to the main thread. Also the returned result should be as small as possible to limit inter-process communication. Alternatively, the communication queue can be used to send the result to the main thread. If the queue is set, the result is transformed to the `status` and this status is pushed onto the queue (see `Task.runtask`). Status is also propagated to the progress bar using the `status` bar handler (see `RunningBar.status`). `DefaultBar` ignores the status. `RunningBar` expects the status for failed tasks to be None, and non-None otherwise. `SolvingBar` expects `True` for solved tasks, `False` for unsolved, and `None` for failed tasks. \"\"\" def __init__ ( self , queue : \"Queue[Any] | None\" = None , talker : \"Talker | None\" = None , ): \"\"\"Init the task. :param queue: communication queue (optional) \"\"\" self . _log_queue = queue self . _talker = talker def run ( self ) -> Any : \"\"\"Run the task and return the result.\"\"\" raise NotImplementedError ( \"Task.run: abstract method not implemented.\" ) @property def logqueue ( self ) -> \"Queue[Any] | None\" : \"\"\"Get the queue.\"\"\" return self . _log_queue @logqueue . setter def logqueue ( self , q : \"Queue[Any]\" ): \"\"\"Set the queue. :param q: the queue \"\"\" self . _log_queue = q #@property #def talker(self) -> \"Talker | None\": # \"\"\"Get the talker.\"\"\" # return self._talker #@talker.setter #def talker(self, talker: \"Talker | None\"): # \"\"\"Set the talker. # :param t: the talker # \"\"\" # self._talker = talker def status ( self , result : Any , ) -> Any : \"\"\"Translate the result to (typically smaller) status to send it over the queue.\" :param result: the result \"\"\" return ( result is not None ) @staticmethod def runtask ( task : \"Task\" ): \"\"\"Run the task andd announce the result over the queue. :param task: the task to be ran \"\"\" signal . signal ( signal . SIGINT , signal . SIG_IGN ) try : res = task . run () status = task . status ( res ) except Exception as e : import traceback logger . warning ( f \"Exception:: { e } \" ) logger . warning ( f \"Task:: { task } \" ) logger . warning ( f \"Error:: { traceback . format_exc () } \" ) status = None res = None #except KeyboardInterrupt as e: # raise e # #return None if status is None : logger . debug ( f \"failed task: { task } \" ) #if task.queue is not None: # task.queue.put(status) return res","title":"Task"},{"location":"api/solverpy/task/task/#solverpy.task.task.Task.logqueue","text":"Get the queue.","title":"logqueue"},{"location":"api/solverpy/task/task/#solverpy.task.task.Task.__init__","text":"Init the task. :param queue: communication queue (optional) Source code in src/solverpy/task/task.py 35 36 37 38 39 40 41 42 43 44 45 46 def __init__ ( self , queue : \"Queue[Any] | None\" = None , talker : \"Talker | None\" = None , ): \"\"\"Init the task. :param queue: communication queue (optional) \"\"\" self . _log_queue = queue self . _talker = talker","title":"__init__"},{"location":"api/solverpy/task/task/#solverpy.task.task.Task.run","text":"Run the task and return the result. Source code in src/solverpy/task/task.py 48 49 50 def run ( self ) -> Any : \"\"\"Run the task and return the result.\"\"\" raise NotImplementedError ( \"Task.run: abstract method not implemented.\" )","title":"run"},{"location":"api/solverpy/task/task/#solverpy.task.task.Task.runtask","text":"Run the task andd announce the result over the queue. :param task: the task to be ran Source code in src/solverpy/task/task.py 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 @staticmethod def runtask ( task : \"Task\" ): \"\"\"Run the task andd announce the result over the queue. :param task: the task to be ran \"\"\" signal . signal ( signal . SIGINT , signal . SIG_IGN ) try : res = task . run () status = task . status ( res ) except Exception as e : import traceback logger . warning ( f \"Exception:: { e } \" ) logger . warning ( f \"Task:: { task } \" ) logger . warning ( f \"Error:: { traceback . format_exc () } \" ) status = None res = None #except KeyboardInterrupt as e: # raise e # #return None if status is None : logger . debug ( f \"failed task: { task } \" ) #if task.queue is not None: # task.queue.put(status) return res","title":"runtask"},{"location":"api/solverpy/task/task/#solverpy.task.task.Task.status","text":"Translate the result to (typically smaller) status to send it over the queue.\" :param result: the result Source code in src/solverpy/task/task.py 80 81 82 83 84 85 86 87 88 89 90 def status ( self , result : Any , ) -> Any : \"\"\"Translate the result to (typically smaller) status to send it over the queue.\" :param result: the result \"\"\" return ( result is not None )","title":"status"},{"location":"api/solverpy/task/task/#solverpy.task.task.runtask","text":"Run task and return the result. :param task: Source code in src/solverpy/task/task.py 129 130 131 132 133 134 135 def runtask ( task : Task ) -> Any : \"\"\"Run task and return the result. :param task: \"\"\" return ( task , task . runtask ( task ))","title":"runtask"},{"location":"api/solverpy/task/task/#solverpy.task.task.runtask_single","text":"Run task and return the result. :param task: Source code in src/solverpy/task/task.py 120 121 122 123 124 125 126 def runtask_single ( task : Task ) -> Any : \"\"\"Run task and return the result. :param task: \"\"\" return task . runtask ( task )","title":"runtask_single"},{"location":"api/solverpy/tools/external/","text":"module external solverpy.tools.external catching ( func : Callable ) -> Callable Decorator that catches exceptions and returns them as strings in the case an exception is raised. Source code in src/solverpy/tools/external.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 def catching ( func : Callable ) -> Callable : \"\"\" Decorator that catches exceptions and returns them as strings in the case an exception is raised. \"\"\" @wraps ( func ) def wrapper ( * args , ** kwargs ): try : return func ( * args , ** kwargs ) except Exception as e : return str ( e ) return wrapper external ( func : Callable ) -> Callable Decorator that runs a function in a separate process. Source code in src/solverpy/tools/external.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 def external ( func : Callable ) -> Callable : \"\"\" Decorator that runs a function in a separate process. \"\"\" @wraps ( func ) def wrapper ( * args , ** kwargs ): queue = multiprocessing . Queue () def target (): try : result = func ( * args , ** kwargs ) queue . put (( True , result )) except Exception as e : queue . put (( False , e )) process = multiprocessing . Process ( target = target ) process . start () process . join () if process . exitcode != 0 : raise RuntimeError ( f \"Process failed with exit code { process . exitcode } \" ) ( success , data ) = queue . get () if success : return data else : raise data return wrapper","title":"\ud83e\udd16 external"},{"location":"api/solverpy/tools/external/#module-external","text":"","title":"module external"},{"location":"api/solverpy/tools/external/#solverpy.tools.external","text":"","title":"external"},{"location":"api/solverpy/tools/external/#solverpy.tools.external.catching","text":"Decorator that catches exceptions and returns them as strings in the case an exception is raised. Source code in src/solverpy/tools/external.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 def catching ( func : Callable ) -> Callable : \"\"\" Decorator that catches exceptions and returns them as strings in the case an exception is raised. \"\"\" @wraps ( func ) def wrapper ( * args , ** kwargs ): try : return func ( * args , ** kwargs ) except Exception as e : return str ( e ) return wrapper","title":"catching"},{"location":"api/solverpy/tools/external/#solverpy.tools.external.external","text":"Decorator that runs a function in a separate process. Source code in src/solverpy/tools/external.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 def external ( func : Callable ) -> Callable : \"\"\" Decorator that runs a function in a separate process. \"\"\" @wraps ( func ) def wrapper ( * args , ** kwargs ): queue = multiprocessing . Queue () def target (): try : result = func ( * args , ** kwargs ) queue . put (( True , result )) except Exception as e : queue . put (( False , e )) process = multiprocessing . Process ( target = target ) process . start () process . join () if process . exitcode != 0 : raise RuntimeError ( f \"Process failed with exit code { process . exitcode } \" ) ( success , data ) = queue . get () if success : return data else : raise data return wrapper","title":"external"},{"location":"api/solverpy/tools/human/","text":"module human solverpy.tools.human","title":"\ud83e\udd16 human"},{"location":"api/solverpy/tools/human/#module-human","text":"","title":"module human"},{"location":"api/solverpy/tools/human/#solverpy.tools.human","text":"","title":"human"},{"location":"api/solverpy/tools/log/","text":"module log solverpy.tools.log","title":"\ud83e\udd16 log"},{"location":"api/solverpy/tools/log/#module-log","text":"","title":"module log"},{"location":"api/solverpy/tools/log/#solverpy.tools.log","text":"","title":"log"},{"location":"api/solverpy/tools/patterns/","text":"module patterns solverpy.tools.patterns","title":"\ud83e\udd16 patterns"},{"location":"api/solverpy/tools/patterns/#module-patterns","text":"","title":"module patterns"},{"location":"api/solverpy/tools/patterns/#solverpy.tools.patterns","text":"","title":"patterns"},{"location":"api/solverpy/tools/redirect/","text":"module redirect solverpy.tools.redirect","title":"\ud83e\udd16 redirect"},{"location":"api/solverpy/tools/redirect/#module-redirect","text":"","title":"module redirect"},{"location":"api/solverpy/tools/redirect/#solverpy.tools.redirect","text":"","title":"redirect"},{"location":"api/solverpy/tools/timeme/","text":"module timeme solverpy.tools.timeme","title":"\ud83e\udd16 timeme"},{"location":"api/solverpy/tools/timeme/#module-timeme","text":"","title":"module timeme"},{"location":"api/solverpy/tools/timeme/#solverpy.tools.timeme","text":"","title":"timeme"},{"location":"api/solverpy/tools/typing/","text":"module typing solverpy.tools.typing Result = dict [ str , Any ] module-attribute Generic solver result. Status = str module-attribute Solver task status.","title":"\ud83e\udd16 typing"},{"location":"api/solverpy/tools/typing/#module-typing","text":"","title":"module typing"},{"location":"api/solverpy/tools/typing/#solverpy.tools.typing","text":"","title":"typing"},{"location":"api/solverpy/tools/typing/#solverpy.tools.typing.Result","text":"Generic solver result.","title":"Result"},{"location":"api/solverpy/tools/typing/#solverpy.tools.typing.Status","text":"Solver task status.","title":"Status"},{"location":"api/solverpy/tools/markdown/dia/","text":"module dia solverpy.tools.markdown.dia","title":"\ud83e\udd16 dia"},{"location":"api/solverpy/tools/markdown/dia/#module-dia","text":"","title":"module dia"},{"location":"api/solverpy/tools/markdown/dia/#solverpy.tools.markdown.dia","text":"","title":"dia"},{"location":"api/solverpy/tools/markdown/plantuml/","text":"module plantuml solverpy.tools.markdown.plantuml","title":"\ud83e\udd16 plantuml"},{"location":"api/solverpy/tools/markdown/plantuml/#module-plantuml","text":"","title":"module plantuml"},{"location":"api/solverpy/tools/markdown/plantuml/#solverpy.tools.markdown.plantuml","text":"","title":"plantuml"}]}
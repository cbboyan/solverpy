# Generated from Tptp.g4 by ANTLR 4.10.1
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,99,1638,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,
        7,6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,
        13,2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,
        20,7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,
        26,2,27,7,27,2,28,7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,
        33,7,33,2,34,7,34,2,35,7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,
        39,2,40,7,40,2,41,7,41,2,42,7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,
        46,7,46,2,47,7,47,2,48,7,48,2,49,7,49,2,50,7,50,2,51,7,51,2,52,7,
        52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,7,56,2,57,7,57,2,58,7,58,2,
        59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,7,63,2,64,7,64,2,65,7,
        65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,7,70,2,71,7,71,2,
        72,7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,7,77,2,78,7,
        78,2,79,7,79,2,80,7,80,2,81,7,81,2,82,7,82,2,83,7,83,2,84,7,84,2,
        85,7,85,2,86,7,86,2,87,7,87,2,88,7,88,2,89,7,89,2,90,7,90,2,91,7,
        91,2,92,7,92,2,93,7,93,2,94,7,94,2,95,7,95,2,96,7,96,2,97,7,97,2,
        98,7,98,2,99,7,99,2,100,7,100,2,101,7,101,2,102,7,102,2,103,7,103,
        2,104,7,104,2,105,7,105,2,106,7,106,2,107,7,107,2,108,7,108,2,109,
        7,109,2,110,7,110,2,111,7,111,2,112,7,112,2,113,7,113,2,114,7,114,
        2,115,7,115,2,116,7,116,2,117,7,117,2,118,7,118,2,119,7,119,2,120,
        7,120,2,121,7,121,2,122,7,122,2,123,7,123,2,124,7,124,2,125,7,125,
        2,126,7,126,2,127,7,127,2,128,7,128,2,129,7,129,2,130,7,130,2,131,
        7,131,2,132,7,132,2,133,7,133,2,134,7,134,2,135,7,135,2,136,7,136,
        2,137,7,137,2,138,7,138,2,139,7,139,2,140,7,140,2,141,7,141,2,142,
        7,142,2,143,7,143,2,144,7,144,2,145,7,145,2,146,7,146,2,147,7,147,
        2,148,7,148,2,149,7,149,2,150,7,150,2,151,7,151,2,152,7,152,2,153,
        7,153,2,154,7,154,2,155,7,155,2,156,7,156,2,157,7,157,2,158,7,158,
        2,159,7,159,2,160,7,160,2,161,7,161,2,162,7,162,2,163,7,163,2,164,
        7,164,2,165,7,165,2,166,7,166,2,167,7,167,2,168,7,168,2,169,7,169,
        2,170,7,170,2,171,7,171,2,172,7,172,2,173,7,173,2,174,7,174,2,175,
        7,175,2,176,7,176,2,177,7,177,2,178,7,178,2,179,7,179,2,180,7,180,
        2,181,7,181,2,182,7,182,2,183,7,183,2,184,7,184,2,185,7,185,2,186,
        7,186,2,187,7,187,2,188,7,188,2,189,7,189,2,190,7,190,2,191,7,191,
        2,192,7,192,2,193,7,193,2,194,7,194,2,195,7,195,2,196,7,196,2,197,
        7,197,2,198,7,198,2,199,7,199,2,200,7,200,1,0,5,0,404,8,0,10,0,12,
        0,407,9,0,1,0,1,0,1,1,1,1,3,1,413,8,1,1,2,1,2,1,2,1,2,1,2,1,2,1,
        2,3,2,422,8,2,1,3,1,3,1,3,1,3,1,3,1,3,1,3,3,3,431,8,3,1,3,1,3,1,
        4,1,4,1,5,1,5,1,5,1,5,1,5,1,5,1,5,3,5,444,8,5,1,5,1,5,1,6,1,6,1,
        6,1,6,1,6,1,6,1,6,3,6,455,8,6,1,6,1,6,1,7,1,7,1,7,1,7,1,7,1,7,1,
        7,3,7,466,8,7,1,7,1,7,1,8,1,8,1,8,1,8,1,8,1,8,1,8,3,8,477,8,8,1,
        8,1,8,1,9,1,9,1,9,1,9,1,9,1,9,1,9,3,9,488,8,9,1,9,1,9,1,10,1,10,
        1,10,1,10,1,10,1,10,1,10,3,10,499,8,10,1,10,1,10,1,11,1,11,1,11,
        3,11,506,8,11,1,12,1,12,1,13,1,13,3,13,512,8,13,1,14,1,14,1,14,1,
        14,3,14,518,8,14,1,15,1,15,1,15,3,15,523,8,15,1,16,1,16,1,16,1,16,
        1,17,1,17,1,17,3,17,532,8,17,1,18,1,18,1,18,1,18,1,18,1,18,1,18,
        1,18,5,18,542,8,18,10,18,12,18,545,9,18,1,19,1,19,1,19,1,19,1,19,
        1,19,1,19,1,19,5,19,555,8,19,10,19,12,19,558,9,19,1,20,1,20,1,20,
        1,20,1,20,1,20,1,20,1,20,5,20,568,8,20,10,20,12,20,571,9,20,1,21,
        1,21,1,21,1,21,1,21,1,21,1,21,1,21,1,21,1,21,3,21,583,8,21,1,22,
        1,22,1,22,1,23,1,23,1,23,1,23,1,23,1,23,1,24,1,24,1,24,5,24,597,
        8,24,10,24,12,24,600,9,24,1,25,1,25,3,25,604,8,25,1,26,1,26,1,26,
        1,26,1,27,1,27,1,27,1,27,1,27,1,28,1,28,1,28,1,28,3,28,619,8,28,
        1,29,1,29,1,29,1,29,1,29,1,29,1,29,1,29,1,29,1,29,1,29,1,29,1,29,
        1,29,1,29,1,29,3,29,637,8,29,1,30,1,30,1,30,3,30,642,8,30,1,31,1,
        31,1,31,1,31,1,31,1,31,1,31,1,31,1,32,1,32,1,32,1,32,1,32,1,32,1,
        33,1,33,1,34,1,34,1,34,1,34,1,35,1,35,1,35,1,35,1,35,3,35,669,8,
        35,1,36,1,36,1,36,1,36,1,37,1,37,1,37,3,37,678,8,37,1,38,1,38,1,
        39,1,39,1,40,1,40,1,40,3,40,687,8,40,1,41,1,41,1,41,1,41,1,41,1,
        41,1,41,1,41,3,41,697,8,41,1,42,1,42,1,42,1,42,1,42,1,42,1,42,1,
        42,5,42,707,8,42,10,42,12,42,710,9,42,1,43,1,43,1,43,1,43,1,43,1,
        43,1,43,1,43,5,43,720,8,43,10,43,12,43,723,9,43,1,44,1,44,1,44,1,
        44,1,44,1,44,1,44,1,44,3,44,733,8,44,1,45,1,45,1,45,1,45,1,45,1,
        45,1,45,1,45,1,45,1,45,3,45,745,8,45,1,46,1,46,1,46,5,46,750,8,46,
        10,46,12,46,753,9,46,1,47,1,47,3,47,757,8,47,1,48,1,48,1,49,1,49,
        1,49,3,49,764,8,49,1,50,1,50,1,50,3,50,769,8,50,1,51,1,51,3,51,773,
        8,51,1,52,1,52,1,52,1,52,1,53,1,53,3,53,781,8,53,1,54,1,54,1,54,
        1,54,1,54,1,54,1,54,1,54,5,54,791,8,54,10,54,12,54,794,9,54,1,55,
        1,55,1,55,1,55,1,55,1,55,1,55,1,55,5,55,804,8,55,10,55,12,55,807,
        9,55,1,56,1,56,1,56,1,56,1,56,1,56,1,56,1,56,1,56,3,56,818,8,56,
        1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,58,1,58,1,58,5,58,830,8,58,
        10,58,12,58,833,9,58,1,59,1,59,3,59,837,8,59,1,60,1,60,1,60,1,60,
        1,61,1,61,1,61,1,61,3,61,847,8,61,1,62,1,62,1,63,1,63,1,63,1,63,
        1,63,1,63,1,63,1,63,1,64,1,64,1,64,1,64,1,64,1,64,1,64,1,64,1,64,
        1,64,1,64,1,64,3,64,871,8,64,1,65,1,65,1,65,1,65,1,65,3,65,878,8,
        65,1,66,1,66,1,66,5,66,883,8,66,10,66,12,66,886,9,66,1,67,1,67,1,
        67,1,67,1,67,1,67,1,67,1,67,3,67,896,8,67,1,68,1,68,1,68,1,68,1,
        68,1,68,1,68,1,68,3,68,906,8,68,1,69,1,69,1,69,1,69,1,69,3,69,913,
        8,69,1,70,1,70,1,70,5,70,918,8,70,10,70,12,70,921,9,70,1,71,1,71,
        1,71,1,71,1,71,1,71,1,71,1,71,3,71,931,8,71,1,72,1,72,1,72,1,72,
        1,72,1,72,1,72,1,72,3,72,941,8,72,1,73,1,73,1,73,1,73,1,73,1,73,
        1,73,1,73,3,73,951,8,73,1,74,1,74,1,74,1,74,1,74,3,74,958,8,74,1,
        75,1,75,1,75,5,75,963,8,75,10,75,12,75,966,9,75,1,76,1,76,1,76,1,
        76,1,76,1,76,1,76,1,76,3,76,976,8,76,1,77,1,77,1,77,1,77,1,78,1,
        78,1,78,1,78,1,78,1,78,1,78,3,78,989,8,78,1,79,1,79,1,79,1,79,1,
        79,1,79,1,79,1,80,1,80,1,80,1,80,1,80,3,80,1003,8,80,1,81,1,81,1,
        81,1,81,1,81,3,81,1010,8,81,1,82,1,82,1,82,1,82,1,82,1,82,1,82,1,
        82,3,82,1020,8,82,1,83,1,83,1,83,5,83,1025,8,83,10,83,12,83,1028,
        9,83,1,84,1,84,1,84,1,84,1,85,1,85,1,85,1,85,1,85,1,85,1,85,1,85,
        5,85,1042,8,85,10,85,12,85,1045,9,85,1,86,1,86,3,86,1049,8,86,1,
        87,1,87,3,87,1053,8,87,1,88,1,88,1,88,1,88,1,88,1,88,1,88,1,89,1,
        89,3,89,1064,8,89,1,90,1,90,3,90,1068,8,90,1,91,1,91,3,91,1072,8,
        91,1,92,1,92,1,92,1,92,1,93,1,93,3,93,1080,8,93,1,94,1,94,1,94,1,
        94,1,94,1,94,1,94,1,94,5,94,1090,8,94,10,94,12,94,1093,9,94,1,95,
        1,95,1,95,1,95,1,95,1,95,1,95,1,95,5,95,1103,8,95,10,95,12,95,1106,
        9,95,1,96,1,96,1,96,1,96,1,96,1,96,1,96,3,96,1115,8,96,1,97,1,97,
        1,97,1,97,1,97,1,97,1,97,1,98,1,98,1,98,5,98,1127,8,98,10,98,12,
        98,1130,9,98,1,99,1,99,1,99,1,99,3,99,1136,8,99,1,100,1,100,1,100,
        1,100,1,101,1,101,1,101,3,101,1145,8,101,1,102,1,102,1,103,1,103,
        3,103,1151,8,103,1,104,1,104,1,105,1,105,1,105,1,105,1,106,1,106,
        1,107,1,107,1,107,1,107,1,107,1,107,3,107,1167,8,107,1,108,1,108,
        3,108,1171,8,108,1,109,1,109,1,110,1,110,1,110,1,110,1,110,1,110,
        3,110,1181,8,110,1,111,1,111,1,111,1,111,1,111,1,111,3,111,1189,
        8,111,1,112,1,112,1,112,5,112,1194,8,112,10,112,12,112,1197,9,112,
        1,113,1,113,1,113,1,113,1,113,3,113,1204,8,113,1,114,1,114,1,114,
        3,114,1209,8,114,1,115,1,115,1,115,1,115,1,115,1,115,1,115,1,115,
        1,116,1,116,1,116,1,116,1,116,1,116,1,116,1,116,1,116,1,116,1,116,
        1,116,3,116,1231,8,116,1,117,1,117,1,117,1,117,1,117,3,117,1238,
        8,117,1,118,1,118,1,118,1,118,1,118,1,118,1,118,1,118,3,118,1248,
        8,118,1,119,1,119,1,119,1,119,1,119,3,119,1255,8,119,1,120,1,120,
        1,120,5,120,1260,8,120,10,120,12,120,1263,9,120,1,121,1,121,1,121,
        1,121,1,121,3,121,1270,8,121,1,122,1,122,1,122,1,122,1,122,1,122,
        5,122,1278,8,122,10,122,12,122,1281,9,122,1,123,1,123,1,123,1,123,
        3,123,1287,8,123,1,124,1,124,1,124,3,124,1292,8,124,1,125,1,125,
        1,126,1,126,1,127,1,127,1,127,1,127,3,127,1302,8,127,1,128,1,128,
        3,128,1306,8,128,1,129,1,129,1,130,1,130,3,130,1312,8,130,1,131,
        1,131,1,132,1,132,1,133,1,133,1,134,1,134,1,135,1,135,1,136,1,136,
        1,137,1,137,1,138,1,138,1,139,1,139,3,139,1332,8,139,1,140,1,140,
        3,140,1336,8,140,1,141,1,141,1,142,1,142,1,143,1,143,1,144,1,144,
        1,145,1,145,1,146,1,146,1,147,1,147,1,148,1,148,1,149,1,149,1,150,
        1,150,3,150,1358,8,150,1,151,1,151,1,152,1,152,1,152,1,152,1,152,
        1,152,1,152,1,152,3,152,1370,8,152,1,153,1,153,1,153,5,153,1375,
        8,153,10,153,12,153,1378,9,153,1,154,1,154,3,154,1382,8,154,1,155,
        1,155,1,155,1,155,1,155,1,155,1,155,1,155,1,156,1,156,1,157,1,157,
        1,157,1,157,1,157,3,157,1399,8,157,1,158,1,158,1,158,5,158,1404,
        8,158,10,158,12,158,1407,9,158,1,159,1,159,3,159,1411,8,159,1,160,
        1,160,1,160,1,161,1,161,1,161,3,161,1419,8,161,1,161,1,161,1,162,
        1,162,1,163,1,163,1,163,3,163,1428,8,163,1,164,1,164,1,164,3,164,
        1433,8,164,1,164,1,164,1,165,1,165,1,165,1,166,1,166,1,166,3,166,
        1443,8,166,1,166,1,166,1,167,1,167,1,168,1,168,1,168,3,168,1452,
        8,168,1,168,1,168,1,169,1,169,1,170,1,170,1,170,1,171,1,171,1,171,
        1,171,1,171,1,171,3,171,1467,8,171,1,172,1,172,1,172,5,172,1472,
        8,172,10,172,12,172,1475,9,172,1,173,1,173,1,173,3,173,1480,8,173,
        1,174,1,174,3,174,1484,8,174,1,175,1,175,1,175,1,175,1,176,1,176,
        1,176,1,176,1,177,1,177,1,177,1,177,3,177,1498,8,177,1,178,1,178,
        1,178,1,178,1,178,3,178,1505,8,178,1,179,1,179,1,180,1,180,1,180,
        1,180,1,180,1,180,1,180,1,181,1,181,1,181,1,181,1,181,1,181,1,182,
        1,182,1,182,1,182,1,183,1,183,1,183,1,183,1,183,1,183,1,183,1,183,
        1,184,1,184,1,184,5,184,1537,8,184,10,184,12,184,1540,9,184,1,185,
        1,185,3,185,1544,8,185,1,186,1,186,1,186,3,186,1549,8,186,1,186,
        1,186,1,187,1,187,1,187,1,187,1,187,1,188,1,188,1,188,5,188,1561,
        8,188,10,188,12,188,1564,9,188,1,189,1,189,1,189,1,189,1,189,1,189,
        3,189,1572,8,189,1,190,1,190,1,190,1,190,1,190,1,190,3,190,1580,
        8,190,1,191,1,191,1,191,1,191,1,191,1,192,1,192,1,192,1,192,1,192,
        1,192,1,192,1,192,1,192,1,192,1,192,1,192,1,192,1,192,1,192,1,192,
        1,192,1,192,1,192,1,192,3,192,1607,8,192,1,193,1,193,1,193,1,193,
        1,193,3,193,1614,8,193,1,194,1,194,1,194,5,194,1619,8,194,10,194,
        12,194,1622,9,194,1,195,1,195,3,195,1626,8,195,1,196,1,196,1,197,
        1,197,1,198,1,198,1,199,1,199,1,200,1,200,1,200,0,11,36,38,40,84,
        86,108,110,170,188,190,244,201,0,2,4,6,8,10,12,14,16,18,20,22,24,
        26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,
        70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,
        110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,
        142,144,146,148,150,152,154,156,158,160,162,164,166,168,170,172,
        174,176,178,180,182,184,186,188,190,192,194,196,198,200,202,204,
        206,208,210,212,214,216,218,220,222,224,226,228,230,232,234,236,
        238,240,242,244,246,248,250,252,254,256,258,260,262,264,266,268,
        270,272,274,276,278,280,282,284,286,288,290,292,294,296,298,300,
        302,304,306,308,310,312,314,316,318,320,322,324,326,328,330,332,
        334,336,338,340,342,344,346,348,350,352,354,356,358,360,362,364,
        366,368,370,372,374,376,378,380,382,384,386,388,390,392,394,396,
        398,400,0,9,3,0,61,61,63,63,65,65,2,0,54,54,59,59,5,0,53,53,58,58,
        62,62,64,64,66,66,2,0,57,57,60,60,1,0,46,51,1,0,44,45,2,0,56,56,
        68,68,1,0,94,95,3,0,74,74,77,77,80,80,1621,0,405,1,0,0,0,2,412,1,
        0,0,0,4,421,1,0,0,0,6,423,1,0,0,0,8,434,1,0,0,0,10,436,1,0,0,0,12,
        447,1,0,0,0,14,458,1,0,0,0,16,469,1,0,0,0,18,480,1,0,0,0,20,491,
        1,0,0,0,22,502,1,0,0,0,24,507,1,0,0,0,26,511,1,0,0,0,28,517,1,0,
        0,0,30,522,1,0,0,0,32,524,1,0,0,0,34,531,1,0,0,0,36,533,1,0,0,0,
        38,546,1,0,0,0,40,559,1,0,0,0,42,582,1,0,0,0,44,584,1,0,0,0,46,587,
        1,0,0,0,48,593,1,0,0,0,50,603,1,0,0,0,52,605,1,0,0,0,54,609,1,0,
        0,0,56,618,1,0,0,0,58,636,1,0,0,0,60,641,1,0,0,0,62,643,1,0,0,0,
        64,651,1,0,0,0,66,657,1,0,0,0,68,659,1,0,0,0,70,668,1,0,0,0,72,670,
        1,0,0,0,74,677,1,0,0,0,76,679,1,0,0,0,78,681,1,0,0,0,80,686,1,0,
        0,0,82,696,1,0,0,0,84,698,1,0,0,0,86,711,1,0,0,0,88,732,1,0,0,0,
        90,744,1,0,0,0,92,746,1,0,0,0,94,756,1,0,0,0,96,758,1,0,0,0,98,763,
        1,0,0,0,100,768,1,0,0,0,102,772,1,0,0,0,104,774,1,0,0,0,106,780,
        1,0,0,0,108,782,1,0,0,0,110,795,1,0,0,0,112,817,1,0,0,0,114,819,
        1,0,0,0,116,826,1,0,0,0,118,836,1,0,0,0,120,838,1,0,0,0,122,846,
        1,0,0,0,124,848,1,0,0,0,126,850,1,0,0,0,128,870,1,0,0,0,130,877,
        1,0,0,0,132,879,1,0,0,0,134,895,1,0,0,0,136,905,1,0,0,0,138,912,
        1,0,0,0,140,914,1,0,0,0,142,930,1,0,0,0,144,940,1,0,0,0,146,950,
        1,0,0,0,148,957,1,0,0,0,150,959,1,0,0,0,152,975,1,0,0,0,154,977,
        1,0,0,0,156,988,1,0,0,0,158,990,1,0,0,0,160,1002,1,0,0,0,162,1009,
        1,0,0,0,164,1019,1,0,0,0,166,1021,1,0,0,0,168,1029,1,0,0,0,170,1033,
        1,0,0,0,172,1048,1,0,0,0,174,1052,1,0,0,0,176,1054,1,0,0,0,178,1063,
        1,0,0,0,180,1067,1,0,0,0,182,1071,1,0,0,0,184,1073,1,0,0,0,186,1079,
        1,0,0,0,188,1081,1,0,0,0,190,1094,1,0,0,0,192,1114,1,0,0,0,194,1116,
        1,0,0,0,196,1123,1,0,0,0,198,1135,1,0,0,0,200,1137,1,0,0,0,202,1144,
        1,0,0,0,204,1146,1,0,0,0,206,1150,1,0,0,0,208,1152,1,0,0,0,210,1154,
        1,0,0,0,212,1158,1,0,0,0,214,1166,1,0,0,0,216,1170,1,0,0,0,218,1172,
        1,0,0,0,220,1180,1,0,0,0,222,1188,1,0,0,0,224,1190,1,0,0,0,226,1203,
        1,0,0,0,228,1208,1,0,0,0,230,1210,1,0,0,0,232,1230,1,0,0,0,234,1237,
        1,0,0,0,236,1247,1,0,0,0,238,1254,1,0,0,0,240,1256,1,0,0,0,242,1269,
        1,0,0,0,244,1271,1,0,0,0,246,1286,1,0,0,0,248,1291,1,0,0,0,250,1293,
        1,0,0,0,252,1295,1,0,0,0,254,1301,1,0,0,0,256,1305,1,0,0,0,258,1307,
        1,0,0,0,260,1311,1,0,0,0,262,1313,1,0,0,0,264,1315,1,0,0,0,266,1317,
        1,0,0,0,268,1319,1,0,0,0,270,1321,1,0,0,0,272,1323,1,0,0,0,274,1325,
        1,0,0,0,276,1327,1,0,0,0,278,1331,1,0,0,0,280,1335,1,0,0,0,282,1337,
        1,0,0,0,284,1339,1,0,0,0,286,1341,1,0,0,0,288,1343,1,0,0,0,290,1345,
        1,0,0,0,292,1347,1,0,0,0,294,1349,1,0,0,0,296,1351,1,0,0,0,298,1353,
        1,0,0,0,300,1357,1,0,0,0,302,1359,1,0,0,0,304,1369,1,0,0,0,306,1371,
        1,0,0,0,308,1381,1,0,0,0,310,1383,1,0,0,0,312,1391,1,0,0,0,314,1398,
        1,0,0,0,316,1400,1,0,0,0,318,1408,1,0,0,0,320,1412,1,0,0,0,322,1415,
        1,0,0,0,324,1422,1,0,0,0,326,1427,1,0,0,0,328,1429,1,0,0,0,330,1436,
        1,0,0,0,332,1439,1,0,0,0,334,1446,1,0,0,0,336,1448,1,0,0,0,338,1455,
        1,0,0,0,340,1457,1,0,0,0,342,1466,1,0,0,0,344,1468,1,0,0,0,346,1479,
        1,0,0,0,348,1483,1,0,0,0,350,1485,1,0,0,0,352,1489,1,0,0,0,354,1497,
        1,0,0,0,356,1504,1,0,0,0,358,1506,1,0,0,0,360,1508,1,0,0,0,362,1515,
        1,0,0,0,364,1521,1,0,0,0,366,1525,1,0,0,0,368,1533,1,0,0,0,370,1543,
        1,0,0,0,372,1545,1,0,0,0,374,1552,1,0,0,0,376,1557,1,0,0,0,378,1571,
        1,0,0,0,380,1579,1,0,0,0,382,1581,1,0,0,0,384,1606,1,0,0,0,386,1613,
        1,0,0,0,388,1615,1,0,0,0,390,1625,1,0,0,0,392,1627,1,0,0,0,394,1629,
        1,0,0,0,396,1631,1,0,0,0,398,1633,1,0,0,0,400,1635,1,0,0,0,402,404,
        3,2,1,0,403,402,1,0,0,0,404,407,1,0,0,0,405,403,1,0,0,0,405,406,
        1,0,0,0,406,408,1,0,0,0,407,405,1,0,0,0,408,409,5,0,0,1,409,1,1,
        0,0,0,410,413,3,4,2,0,411,413,3,372,186,0,412,410,1,0,0,0,412,411,
        1,0,0,0,413,3,1,0,0,0,414,422,3,10,5,0,415,422,3,12,6,0,416,422,
        3,14,7,0,417,422,3,16,8,0,418,422,3,18,9,0,419,422,3,20,10,0,420,
        422,3,6,3,0,421,414,1,0,0,0,421,415,1,0,0,0,421,416,1,0,0,0,421,
        417,1,0,0,0,421,418,1,0,0,0,421,419,1,0,0,0,421,420,1,0,0,0,422,
        5,1,0,0,0,423,424,5,1,0,0,424,425,3,390,195,0,425,426,5,2,0,0,426,
        427,3,24,12,0,427,428,5,2,0,0,428,430,3,8,4,0,429,431,3,22,11,0,
        430,429,1,0,0,0,430,431,1,0,0,0,431,432,1,0,0,0,432,433,5,3,0,0,
        433,7,1,0,0,0,434,435,3,178,89,0,435,9,1,0,0,0,436,437,5,4,0,0,437,
        438,3,390,195,0,438,439,5,2,0,0,439,440,3,24,12,0,440,441,5,2,0,
        0,441,443,3,26,13,0,442,444,3,22,11,0,443,442,1,0,0,0,443,444,1,
        0,0,0,444,445,1,0,0,0,445,446,5,3,0,0,446,11,1,0,0,0,447,448,5,5,
        0,0,448,449,3,390,195,0,449,450,5,2,0,0,450,451,3,24,12,0,451,452,
        5,2,0,0,452,454,3,94,47,0,453,455,3,22,11,0,454,453,1,0,0,0,454,
        455,1,0,0,0,455,456,1,0,0,0,456,457,5,3,0,0,457,13,1,0,0,0,458,459,
        5,6,0,0,459,460,3,390,195,0,460,461,5,2,0,0,461,462,3,24,12,0,462,
        463,5,2,0,0,463,465,3,98,49,0,464,466,3,22,11,0,465,464,1,0,0,0,
        465,466,1,0,0,0,466,467,1,0,0,0,467,468,5,3,0,0,468,15,1,0,0,0,469,
        470,5,7,0,0,470,471,3,390,195,0,471,472,5,2,0,0,472,473,3,24,12,
        0,473,474,5,2,0,0,474,476,3,172,86,0,475,477,3,22,11,0,476,475,1,
        0,0,0,476,477,1,0,0,0,477,478,1,0,0,0,478,479,5,3,0,0,479,17,1,0,
        0,0,480,481,5,8,0,0,481,482,3,390,195,0,482,483,5,2,0,0,483,484,
        3,24,12,0,484,485,5,2,0,0,485,487,3,178,89,0,486,488,3,22,11,0,487,
        486,1,0,0,0,487,488,1,0,0,0,488,489,1,0,0,0,489,490,5,3,0,0,490,
        19,1,0,0,0,491,492,5,9,0,0,492,493,3,390,195,0,493,494,5,2,0,0,494,
        495,3,24,12,0,495,496,5,2,0,0,496,498,3,242,121,0,497,499,3,22,11,
        0,498,497,1,0,0,0,498,499,1,0,0,0,499,500,1,0,0,0,500,501,5,3,0,
        0,501,21,1,0,0,0,502,503,5,2,0,0,503,505,3,304,152,0,504,506,3,340,
        170,0,505,504,1,0,0,0,505,506,1,0,0,0,506,23,1,0,0,0,507,508,5,94,
        0,0,508,25,1,0,0,0,509,512,3,28,14,0,510,512,3,88,44,0,511,509,1,
        0,0,0,511,510,1,0,0,0,512,27,1,0,0,0,513,518,3,30,15,0,514,518,3,
        42,21,0,515,518,3,68,34,0,516,518,3,72,36,0,517,513,1,0,0,0,517,
        514,1,0,0,0,517,515,1,0,0,0,517,516,1,0,0,0,518,29,1,0,0,0,519,523,
        3,32,16,0,520,523,3,34,17,0,521,523,3,80,40,0,522,519,1,0,0,0,522,
        520,1,0,0,0,522,521,1,0,0,0,523,31,1,0,0,0,524,525,3,42,21,0,525,
        526,3,254,127,0,526,527,3,42,21,0,527,33,1,0,0,0,528,532,3,36,18,
        0,529,532,3,38,19,0,530,532,3,40,20,0,531,528,1,0,0,0,531,529,1,
        0,0,0,531,530,1,0,0,0,532,35,1,0,0,0,533,534,6,18,-1,0,534,535,3,
        42,21,0,535,536,5,44,0,0,536,537,3,42,21,0,537,543,1,0,0,0,538,539,
        10,1,0,0,539,540,5,44,0,0,540,542,3,42,21,0,541,538,1,0,0,0,542,
        545,1,0,0,0,543,541,1,0,0,0,543,544,1,0,0,0,544,37,1,0,0,0,545,543,
        1,0,0,0,546,547,6,19,-1,0,547,548,3,42,21,0,548,549,5,45,0,0,549,
        550,3,42,21,0,550,556,1,0,0,0,551,552,10,1,0,0,552,553,5,45,0,0,
        553,555,3,42,21,0,554,551,1,0,0,0,555,558,1,0,0,0,556,554,1,0,0,
        0,556,557,1,0,0,0,557,39,1,0,0,0,558,556,1,0,0,0,559,560,6,20,-1,
        0,560,561,3,42,21,0,561,562,5,67,0,0,562,563,3,42,21,0,563,569,1,
        0,0,0,564,565,10,1,0,0,565,566,5,67,0,0,566,568,3,42,21,0,567,564,
        1,0,0,0,568,571,1,0,0,0,569,567,1,0,0,0,569,570,1,0,0,0,570,41,1,
        0,0,0,571,569,1,0,0,0,572,583,3,44,22,0,573,583,3,54,27,0,574,583,
        3,56,28,0,575,583,3,62,31,0,576,583,3,64,32,0,577,583,3,90,45,0,
        578,579,5,10,0,0,579,580,3,28,14,0,580,581,5,11,0,0,581,583,1,0,
        0,0,582,572,1,0,0,0,582,573,1,0,0,0,582,574,1,0,0,0,582,575,1,0,
        0,0,582,576,1,0,0,0,582,577,1,0,0,0,582,578,1,0,0,0,583,43,1,0,0,
        0,584,585,3,46,23,0,585,586,3,42,21,0,586,45,1,0,0,0,587,588,3,248,
        124,0,588,589,5,12,0,0,589,590,3,48,24,0,590,591,5,13,0,0,591,592,
        5,14,0,0,592,47,1,0,0,0,593,598,3,50,25,0,594,595,5,2,0,0,595,597,
        3,50,25,0,596,594,1,0,0,0,597,600,1,0,0,0,598,596,1,0,0,0,598,599,
        1,0,0,0,599,49,1,0,0,0,600,598,1,0,0,0,601,604,3,52,26,0,602,604,
        3,302,151,0,603,601,1,0,0,0,603,602,1,0,0,0,604,51,1,0,0,0,605,606,
        3,302,151,0,606,607,5,14,0,0,607,608,3,74,37,0,608,53,1,0,0,0,609,
        610,3,256,128,0,610,611,5,10,0,0,611,612,3,28,14,0,612,613,5,11,
        0,0,613,55,1,0,0,0,614,619,3,58,29,0,615,619,3,302,151,0,616,619,
        3,300,150,0,617,619,3,60,30,0,618,614,1,0,0,0,618,615,1,0,0,0,618,
        616,1,0,0,0,618,617,1,0,0,0,619,57,1,0,0,0,620,637,3,278,139,0,621,
        622,3,290,145,0,622,623,5,10,0,0,623,624,3,66,33,0,624,625,5,11,
        0,0,625,637,1,0,0,0,626,627,3,298,149,0,627,628,5,10,0,0,628,629,
        3,66,33,0,629,630,5,11,0,0,630,637,1,0,0,0,631,632,3,294,147,0,632,
        633,5,10,0,0,633,634,3,66,33,0,634,635,5,11,0,0,635,637,1,0,0,0,
        636,620,1,0,0,0,636,621,1,0,0,0,636,626,1,0,0,0,636,631,1,0,0,0,
        637,59,1,0,0,0,638,642,3,254,127,0,639,642,3,266,133,0,640,642,3,
        256,128,0,641,638,1,0,0,0,641,639,1,0,0,0,641,640,1,0,0,0,642,61,
        1,0,0,0,643,644,5,15,0,0,644,645,3,28,14,0,645,646,5,2,0,0,646,647,
        3,28,14,0,647,648,5,2,0,0,648,649,3,28,14,0,649,650,5,11,0,0,650,
        63,1,0,0,0,651,652,5,16,0,0,652,653,3,42,21,0,653,654,5,2,0,0,654,
        655,3,26,13,0,655,656,5,11,0,0,656,65,1,0,0,0,657,658,3,92,46,0,
        658,67,1,0,0,0,659,660,3,70,35,0,660,661,5,14,0,0,661,662,3,74,37,
        0,662,69,1,0,0,0,663,669,3,56,28,0,664,665,5,10,0,0,665,666,3,28,
        14,0,666,667,5,11,0,0,667,669,1,0,0,0,668,663,1,0,0,0,668,664,1,
        0,0,0,669,71,1,0,0,0,670,671,3,56,28,0,671,672,5,72,0,0,672,673,
        3,56,28,0,673,73,1,0,0,0,674,678,3,76,38,0,675,678,3,82,41,0,676,
        678,3,78,39,0,677,674,1,0,0,0,677,675,1,0,0,0,677,676,1,0,0,0,678,
        75,1,0,0,0,679,680,3,42,21,0,680,77,1,0,0,0,681,682,3,40,20,0,682,
        79,1,0,0,0,683,687,3,82,41,0,684,687,3,84,42,0,685,687,3,86,43,0,
        686,683,1,0,0,0,686,684,1,0,0,0,686,685,1,0,0,0,687,81,1,0,0,0,688,
        689,3,76,38,0,689,690,5,69,0,0,690,691,3,76,38,0,691,697,1,0,0,0,
        692,693,3,76,38,0,693,694,5,69,0,0,694,695,3,82,41,0,695,697,1,0,
        0,0,696,688,1,0,0,0,696,692,1,0,0,0,697,83,1,0,0,0,698,699,6,42,
        -1,0,699,700,3,76,38,0,700,701,5,70,0,0,701,702,3,76,38,0,702,708,
        1,0,0,0,703,704,10,1,0,0,704,705,5,70,0,0,705,707,3,76,38,0,706,
        703,1,0,0,0,707,710,1,0,0,0,708,706,1,0,0,0,708,709,1,0,0,0,709,
        85,1,0,0,0,710,708,1,0,0,0,711,712,6,43,-1,0,712,713,3,76,38,0,713,
        714,5,71,0,0,714,715,3,76,38,0,715,721,1,0,0,0,716,717,10,1,0,0,
        717,718,5,71,0,0,718,720,3,76,38,0,719,716,1,0,0,0,720,723,1,0,0,
        0,721,719,1,0,0,0,721,722,1,0,0,0,722,87,1,0,0,0,723,721,1,0,0,0,
        724,725,3,90,45,0,725,726,5,73,0,0,726,727,3,90,45,0,727,733,1,0,
        0,0,728,729,5,10,0,0,729,730,3,88,44,0,730,731,5,11,0,0,731,733,
        1,0,0,0,732,724,1,0,0,0,732,728,1,0,0,0,733,89,1,0,0,0,734,745,5,
        17,0,0,735,736,5,12,0,0,736,737,3,92,46,0,737,738,5,13,0,0,738,745,
        1,0,0,0,739,745,5,18,0,0,740,741,5,19,0,0,741,742,3,92,46,0,742,
        743,5,20,0,0,743,745,1,0,0,0,744,734,1,0,0,0,744,735,1,0,0,0,744,
        739,1,0,0,0,744,740,1,0,0,0,745,91,1,0,0,0,746,751,3,28,14,0,747,
        748,5,2,0,0,748,750,3,28,14,0,749,747,1,0,0,0,750,753,1,0,0,0,751,
        749,1,0,0,0,751,752,1,0,0,0,752,93,1,0,0,0,753,751,1,0,0,0,754,757,
        3,96,48,0,755,757,3,88,44,0,756,754,1,0,0,0,756,755,1,0,0,0,757,
        95,1,0,0,0,758,759,3,28,14,0,759,97,1,0,0,0,760,764,3,100,50,0,761,
        764,3,152,76,0,762,764,3,146,73,0,763,760,1,0,0,0,763,761,1,0,0,
        0,763,762,1,0,0,0,764,99,1,0,0,0,765,769,3,102,51,0,766,769,3,112,
        56,0,767,769,3,154,77,0,768,765,1,0,0,0,768,766,1,0,0,0,768,767,
        1,0,0,0,769,101,1,0,0,0,770,773,3,104,52,0,771,773,3,106,53,0,772,
        770,1,0,0,0,772,771,1,0,0,0,773,103,1,0,0,0,774,775,3,112,56,0,775,
        776,3,264,132,0,776,777,3,112,56,0,777,105,1,0,0,0,778,781,3,108,
        54,0,779,781,3,110,55,0,780,778,1,0,0,0,780,779,1,0,0,0,781,107,
        1,0,0,0,782,783,6,54,-1,0,783,784,3,112,56,0,784,785,5,44,0,0,785,
        786,3,112,56,0,786,792,1,0,0,0,787,788,10,1,0,0,788,789,5,44,0,0,
        789,791,3,112,56,0,790,787,1,0,0,0,791,794,1,0,0,0,792,790,1,0,0,
        0,792,793,1,0,0,0,793,109,1,0,0,0,794,792,1,0,0,0,795,796,6,55,-1,
        0,796,797,3,112,56,0,797,798,5,45,0,0,798,799,3,112,56,0,799,805,
        1,0,0,0,800,801,10,1,0,0,801,802,5,45,0,0,802,804,3,112,56,0,803,
        800,1,0,0,0,804,807,1,0,0,0,805,803,1,0,0,0,805,806,1,0,0,0,806,
        111,1,0,0,0,807,805,1,0,0,0,808,818,3,114,57,0,809,818,3,122,61,
        0,810,818,3,124,62,0,811,818,3,126,63,0,812,818,3,128,64,0,813,814,
        5,10,0,0,814,815,3,100,50,0,815,816,5,11,0,0,816,818,1,0,0,0,817,
        808,1,0,0,0,817,809,1,0,0,0,817,810,1,0,0,0,817,811,1,0,0,0,817,
        812,1,0,0,0,817,813,1,0,0,0,818,113,1,0,0,0,819,820,3,262,131,0,
        820,821,5,12,0,0,821,822,3,116,58,0,822,823,5,13,0,0,823,824,5,14,
        0,0,824,825,3,112,56,0,825,115,1,0,0,0,826,831,3,118,59,0,827,828,
        5,2,0,0,828,830,3,118,59,0,829,827,1,0,0,0,830,833,1,0,0,0,831,829,
        1,0,0,0,831,832,1,0,0,0,832,117,1,0,0,0,833,831,1,0,0,0,834,837,
        3,120,60,0,835,837,3,302,151,0,836,834,1,0,0,0,836,835,1,0,0,0,837,
        119,1,0,0,0,838,839,3,302,151,0,839,840,5,14,0,0,840,841,3,164,82,
        0,841,121,1,0,0,0,842,843,3,268,134,0,843,844,3,112,56,0,844,847,
        1,0,0,0,845,847,3,200,100,0,846,842,1,0,0,0,846,845,1,0,0,0,847,
        123,1,0,0,0,848,849,3,202,101,0,849,125,1,0,0,0,850,851,5,21,0,0,
        851,852,3,100,50,0,852,853,5,2,0,0,853,854,3,100,50,0,854,855,5,
        2,0,0,855,856,3,100,50,0,856,857,5,11,0,0,857,127,1,0,0,0,858,859,
        5,22,0,0,859,860,3,130,65,0,860,861,5,2,0,0,861,862,3,98,49,0,862,
        863,5,11,0,0,863,871,1,0,0,0,864,865,5,23,0,0,865,866,3,138,69,0,
        866,867,5,2,0,0,867,868,3,98,49,0,868,869,5,11,0,0,869,871,1,0,0,
        0,870,858,1,0,0,0,870,864,1,0,0,0,871,129,1,0,0,0,872,878,3,134,
        67,0,873,874,5,12,0,0,874,875,3,132,66,0,875,876,5,13,0,0,876,878,
        1,0,0,0,877,872,1,0,0,0,877,873,1,0,0,0,878,131,1,0,0,0,879,884,
        3,134,67,0,880,881,5,2,0,0,881,883,3,134,67,0,882,880,1,0,0,0,883,
        886,1,0,0,0,884,882,1,0,0,0,884,885,1,0,0,0,885,133,1,0,0,0,886,
        884,1,0,0,0,887,888,5,57,0,0,888,889,5,12,0,0,889,890,3,116,58,0,
        890,891,5,13,0,0,891,892,5,14,0,0,892,893,3,134,67,0,893,896,1,0,
        0,0,894,896,3,136,68,0,895,887,1,0,0,0,895,894,1,0,0,0,896,135,1,
        0,0,0,897,898,3,214,107,0,898,899,5,56,0,0,899,900,3,226,113,0,900,
        906,1,0,0,0,901,902,5,10,0,0,902,903,3,136,68,0,903,904,5,11,0,0,
        904,906,1,0,0,0,905,897,1,0,0,0,905,901,1,0,0,0,906,137,1,0,0,0,
        907,913,3,142,71,0,908,909,5,12,0,0,909,910,3,140,70,0,910,911,5,
        13,0,0,911,913,1,0,0,0,912,907,1,0,0,0,912,908,1,0,0,0,913,139,1,
        0,0,0,914,919,3,142,71,0,915,916,5,2,0,0,916,918,3,142,71,0,917,
        915,1,0,0,0,918,921,1,0,0,0,919,917,1,0,0,0,919,920,1,0,0,0,920,
        141,1,0,0,0,921,919,1,0,0,0,922,923,5,57,0,0,923,924,5,12,0,0,924,
        925,3,116,58,0,925,926,5,13,0,0,926,927,5,14,0,0,927,928,3,142,71,
        0,928,931,1,0,0,0,929,931,3,144,72,0,930,922,1,0,0,0,930,929,1,0,
        0,0,931,143,1,0,0,0,932,933,3,204,102,0,933,934,5,46,0,0,934,935,
        3,112,56,0,935,941,1,0,0,0,936,937,5,10,0,0,937,938,3,144,72,0,938,
        939,5,11,0,0,939,941,1,0,0,0,940,932,1,0,0,0,940,936,1,0,0,0,941,
        145,1,0,0,0,942,943,3,148,74,0,943,944,5,73,0,0,944,945,3,148,74,
        0,945,951,1,0,0,0,946,947,5,10,0,0,947,948,3,146,73,0,948,949,5,
        11,0,0,949,951,1,0,0,0,950,942,1,0,0,0,950,946,1,0,0,0,951,147,1,
        0,0,0,952,958,5,17,0,0,953,954,5,12,0,0,954,955,3,150,75,0,955,956,
        5,13,0,0,956,958,1,0,0,0,957,952,1,0,0,0,957,953,1,0,0,0,958,149,
        1,0,0,0,959,964,3,100,50,0,960,961,5,2,0,0,961,963,3,100,50,0,962,
        960,1,0,0,0,963,966,1,0,0,0,964,962,1,0,0,0,964,965,1,0,0,0,965,
        151,1,0,0,0,966,964,1,0,0,0,967,968,3,280,140,0,968,969,5,14,0,0,
        969,970,3,156,78,0,970,976,1,0,0,0,971,972,5,10,0,0,972,973,3,152,
        76,0,973,974,5,11,0,0,974,976,1,0,0,0,975,967,1,0,0,0,975,971,1,
        0,0,0,976,153,1,0,0,0,977,978,3,280,140,0,978,979,5,72,0,0,979,980,
        3,278,139,0,980,155,1,0,0,0,981,989,3,164,82,0,982,989,3,168,84,
        0,983,989,3,158,79,0,984,985,5,10,0,0,985,986,3,156,78,0,986,987,
        5,11,0,0,987,989,1,0,0,0,988,981,1,0,0,0,988,982,1,0,0,0,988,983,
        1,0,0,0,988,984,1,0,0,0,989,157,1,0,0,0,990,991,5,54,0,0,991,992,
        5,12,0,0,992,993,3,116,58,0,993,994,5,13,0,0,994,995,5,14,0,0,995,
        996,3,160,80,0,996,159,1,0,0,0,997,1003,3,164,82,0,998,999,5,10,
        0,0,999,1000,3,168,84,0,1000,1001,5,11,0,0,1001,1003,1,0,0,0,1002,
        997,1,0,0,0,1002,998,1,0,0,0,1003,161,1,0,0,0,1004,1010,3,164,82,
        0,1005,1006,5,10,0,0,1006,1007,3,170,85,0,1007,1008,5,11,0,0,1008,
        1010,1,0,0,0,1009,1004,1,0,0,0,1009,1005,1,0,0,0,1010,163,1,0,0,
        0,1011,1020,3,270,135,0,1012,1020,3,274,137,0,1013,1014,3,272,136,
        0,1014,1015,5,10,0,0,1015,1016,3,166,83,0,1016,1017,5,11,0,0,1017,
        1020,1,0,0,0,1018,1020,3,302,151,0,1019,1011,1,0,0,0,1019,1012,1,
        0,0,0,1019,1013,1,0,0,0,1019,1018,1,0,0,0,1020,165,1,0,0,0,1021,
        1026,3,164,82,0,1022,1023,5,2,0,0,1023,1025,3,164,82,0,1024,1022,
        1,0,0,0,1025,1028,1,0,0,0,1026,1024,1,0,0,0,1026,1027,1,0,0,0,1027,
        167,1,0,0,0,1028,1026,1,0,0,0,1029,1030,3,162,81,0,1030,1031,5,69,
        0,0,1031,1032,3,164,82,0,1032,169,1,0,0,0,1033,1034,6,85,-1,0,1034,
        1035,3,162,81,0,1035,1036,5,70,0,0,1036,1037,3,164,82,0,1037,1043,
        1,0,0,0,1038,1039,10,1,0,0,1039,1040,5,70,0,0,1040,1042,3,164,82,
        0,1041,1038,1,0,0,0,1042,1045,1,0,0,0,1043,1041,1,0,0,0,1043,1044,
        1,0,0,0,1044,171,1,0,0,0,1045,1043,1,0,0,0,1046,1049,3,174,87,0,
        1047,1049,3,152,76,0,1048,1046,1,0,0,0,1048,1047,1,0,0,0,1049,173,
        1,0,0,0,1050,1053,3,176,88,0,1051,1053,3,242,121,0,1052,1050,1,0,
        0,0,1052,1051,1,0,0,0,1053,175,1,0,0,0,1054,1055,5,57,0,0,1055,1056,
        5,12,0,0,1056,1057,3,116,58,0,1057,1058,5,13,0,0,1058,1059,5,14,
        0,0,1059,1060,3,242,121,0,1060,177,1,0,0,0,1061,1064,3,180,90,0,
        1062,1064,3,236,118,0,1063,1061,1,0,0,0,1063,1062,1,0,0,0,1064,179,
        1,0,0,0,1065,1068,3,182,91,0,1066,1068,3,192,96,0,1067,1065,1,0,
        0,0,1067,1066,1,0,0,0,1068,181,1,0,0,0,1069,1072,3,184,92,0,1070,
        1072,3,186,93,0,1071,1069,1,0,0,0,1071,1070,1,0,0,0,1072,183,1,0,
        0,0,1073,1074,3,192,96,0,1074,1075,3,264,132,0,1075,1076,3,192,96,
        0,1076,185,1,0,0,0,1077,1080,3,188,94,0,1078,1080,3,190,95,0,1079,
        1077,1,0,0,0,1079,1078,1,0,0,0,1080,187,1,0,0,0,1081,1082,6,94,-1,
        0,1082,1083,3,192,96,0,1083,1084,5,44,0,0,1084,1085,3,192,96,0,1085,
        1091,1,0,0,0,1086,1087,10,1,0,0,1087,1088,5,44,0,0,1088,1090,3,192,
        96,0,1089,1086,1,0,0,0,1090,1093,1,0,0,0,1091,1089,1,0,0,0,1091,
        1092,1,0,0,0,1092,189,1,0,0,0,1093,1091,1,0,0,0,1094,1095,6,95,-1,
        0,1095,1096,3,192,96,0,1096,1097,5,45,0,0,1097,1098,3,192,96,0,1098,
        1104,1,0,0,0,1099,1100,10,1,0,0,1100,1101,5,45,0,0,1101,1103,3,192,
        96,0,1102,1099,1,0,0,0,1103,1106,1,0,0,0,1104,1102,1,0,0,0,1104,
        1105,1,0,0,0,1105,191,1,0,0,0,1106,1104,1,0,0,0,1107,1115,3,194,
        97,0,1108,1115,3,198,99,0,1109,1115,3,202,101,0,1110,1111,5,10,0,
        0,1111,1112,3,180,90,0,1112,1113,5,11,0,0,1113,1115,1,0,0,0,1114,
        1107,1,0,0,0,1114,1108,1,0,0,0,1114,1109,1,0,0,0,1114,1110,1,0,0,
        0,1115,193,1,0,0,0,1116,1117,3,262,131,0,1117,1118,5,12,0,0,1118,
        1119,3,196,98,0,1119,1120,5,13,0,0,1120,1121,5,14,0,0,1121,1122,
        3,192,96,0,1122,195,1,0,0,0,1123,1128,3,302,151,0,1124,1125,5,2,
        0,0,1125,1127,3,302,151,0,1126,1124,1,0,0,0,1127,1130,1,0,0,0,1128,
        1126,1,0,0,0,1128,1129,1,0,0,0,1129,197,1,0,0,0,1130,1128,1,0,0,
        0,1131,1132,3,268,134,0,1132,1133,3,192,96,0,1133,1136,1,0,0,0,1134,
        1136,3,200,100,0,1135,1131,1,0,0,0,1135,1134,1,0,0,0,1136,199,1,
        0,0,0,1137,1138,3,226,113,0,1138,1139,5,55,0,0,1139,1140,3,226,113,
        0,1140,201,1,0,0,0,1141,1145,3,204,102,0,1142,1145,3,206,103,0,1143,
        1145,3,212,106,0,1144,1141,1,0,0,0,1144,1142,1,0,0,0,1144,1143,1,
        0,0,0,1145,203,1,0,0,0,1146,1147,3,214,107,0,1147,205,1,0,0,0,1148,
        1151,3,208,104,0,1149,1151,3,210,105,0,1150,1148,1,0,0,0,1150,1149,
        1,0,0,0,1151,207,1,0,0,0,1152,1153,3,216,108,0,1153,209,1,0,0,0,
        1154,1155,3,226,113,0,1155,1156,3,286,143,0,1156,1157,3,226,113,
        0,1157,211,1,0,0,0,1158,1159,3,222,111,0,1159,213,1,0,0,0,1160,1167,
        3,288,144,0,1161,1162,3,290,145,0,1162,1163,5,10,0,0,1163,1164,3,
        224,112,0,1164,1165,5,11,0,0,1165,1167,1,0,0,0,1166,1160,1,0,0,0,
        1166,1161,1,0,0,0,1167,215,1,0,0,0,1168,1171,3,300,150,0,1169,1171,
        3,218,109,0,1170,1168,1,0,0,0,1170,1169,1,0,0,0,1171,217,1,0,0,0,
        1172,1173,3,220,110,0,1173,219,1,0,0,0,1174,1181,3,296,148,0,1175,
        1176,3,298,149,0,1176,1177,5,10,0,0,1177,1178,3,224,112,0,1178,1179,
        5,11,0,0,1179,1181,1,0,0,0,1180,1174,1,0,0,0,1180,1175,1,0,0,0,1181,
        221,1,0,0,0,1182,1189,3,292,146,0,1183,1184,3,294,147,0,1184,1185,
        5,10,0,0,1185,1186,3,224,112,0,1186,1187,5,11,0,0,1187,1189,1,0,
        0,0,1188,1182,1,0,0,0,1188,1183,1,0,0,0,1189,223,1,0,0,0,1190,1195,
        3,226,113,0,1191,1192,5,2,0,0,1192,1194,3,226,113,0,1193,1191,1,
        0,0,0,1194,1197,1,0,0,0,1195,1193,1,0,0,0,1195,1196,1,0,0,0,1196,
        225,1,0,0,0,1197,1195,1,0,0,0,1198,1204,3,228,114,0,1199,1204,3,
        302,151,0,1200,1204,3,230,115,0,1201,1204,3,232,116,0,1202,1204,
        3,234,117,0,1203,1198,1,0,0,0,1203,1199,1,0,0,0,1203,1200,1,0,0,
        0,1203,1201,1,0,0,0,1203,1202,1,0,0,0,1204,227,1,0,0,0,1205,1209,
        3,214,107,0,1206,1209,3,216,108,0,1207,1209,3,222,111,0,1208,1205,
        1,0,0,0,1208,1206,1,0,0,0,1208,1207,1,0,0,0,1209,229,1,0,0,0,1210,
        1211,5,24,0,0,1211,1212,3,100,50,0,1212,1213,5,2,0,0,1213,1214,3,
        226,113,0,1214,1215,5,2,0,0,1215,1216,3,226,113,0,1216,1217,5,11,
        0,0,1217,231,1,0,0,0,1218,1219,5,25,0,0,1219,1220,3,138,69,0,1220,
        1221,5,2,0,0,1221,1222,3,226,113,0,1222,1223,5,11,0,0,1223,1231,
        1,0,0,0,1224,1225,5,26,0,0,1225,1226,3,130,65,0,1226,1227,5,2,0,
        0,1227,1228,3,226,113,0,1228,1229,5,11,0,0,1229,1231,1,0,0,0,1230,
        1218,1,0,0,0,1230,1224,1,0,0,0,1231,233,1,0,0,0,1232,1238,5,18,0,
        0,1233,1234,5,19,0,0,1234,1235,3,224,112,0,1235,1236,5,20,0,0,1236,
        1238,1,0,0,0,1237,1232,1,0,0,0,1237,1233,1,0,0,0,1238,235,1,0,0,
        0,1239,1240,3,238,119,0,1240,1241,5,73,0,0,1241,1242,3,238,119,0,
        1242,1248,1,0,0,0,1243,1244,5,10,0,0,1244,1245,3,236,118,0,1245,
        1246,5,11,0,0,1246,1248,1,0,0,0,1247,1239,1,0,0,0,1247,1243,1,0,
        0,0,1248,237,1,0,0,0,1249,1255,5,17,0,0,1250,1251,5,12,0,0,1251,
        1252,3,240,120,0,1252,1253,5,13,0,0,1253,1255,1,0,0,0,1254,1249,
        1,0,0,0,1254,1250,1,0,0,0,1255,239,1,0,0,0,1256,1261,3,180,90,0,
        1257,1258,5,2,0,0,1258,1260,3,180,90,0,1259,1257,1,0,0,0,1260,1263,
        1,0,0,0,1261,1259,1,0,0,0,1261,1262,1,0,0,0,1262,241,1,0,0,0,1263,
        1261,1,0,0,0,1264,1270,3,244,122,0,1265,1266,5,10,0,0,1266,1267,
        3,244,122,0,1267,1268,5,11,0,0,1268,1270,1,0,0,0,1269,1264,1,0,0,
        0,1269,1265,1,0,0,0,1270,243,1,0,0,0,1271,1272,6,122,-1,0,1272,1273,
        3,246,123,0,1273,1279,1,0,0,0,1274,1275,10,1,0,0,1275,1276,5,44,
        0,0,1276,1278,3,246,123,0,1277,1274,1,0,0,0,1278,1281,1,0,0,0,1279,
        1277,1,0,0,0,1279,1280,1,0,0,0,1280,245,1,0,0,0,1281,1279,1,0,0,
        0,1282,1287,3,202,101,0,1283,1284,5,52,0,0,1284,1287,3,202,101,0,
        1285,1287,3,200,100,0,1286,1282,1,0,0,0,1286,1283,1,0,0,0,1286,1285,
        1,0,0,0,1287,247,1,0,0,0,1288,1292,3,262,131,0,1289,1292,3,250,125,
        0,1290,1292,3,252,126,0,1291,1288,1,0,0,0,1291,1289,1,0,0,0,1291,
        1290,1,0,0,0,1292,249,1,0,0,0,1293,1294,7,0,0,0,1294,251,1,0,0,0,
        1295,1296,7,1,0,0,1296,253,1,0,0,0,1297,1302,5,56,0,0,1298,1302,
        5,55,0,0,1299,1302,3,264,132,0,1300,1302,5,68,0,0,1301,1297,1,0,
        0,0,1301,1298,1,0,0,0,1301,1299,1,0,0,0,1301,1300,1,0,0,0,1302,255,
        1,0,0,0,1303,1306,3,268,134,0,1304,1306,3,258,129,0,1305,1303,1,
        0,0,0,1305,1304,1,0,0,0,1306,257,1,0,0,0,1307,1308,7,2,0,0,1308,
        259,1,0,0,0,1309,1312,3,264,132,0,1310,1312,5,68,0,0,1311,1309,1,
        0,0,0,1311,1310,1,0,0,0,1312,261,1,0,0,0,1313,1314,7,3,0,0,1314,
        263,1,0,0,0,1315,1316,7,4,0,0,1316,265,1,0,0,0,1317,1318,7,5,0,0,
        1318,267,1,0,0,0,1319,1320,5,52,0,0,1320,269,1,0,0,0,1321,1322,3,
        272,136,0,1322,271,1,0,0,0,1323,1324,3,392,196,0,1324,273,1,0,0,
        0,1325,1326,5,91,0,0,1326,275,1,0,0,0,1327,1328,3,396,198,0,1328,
        277,1,0,0,0,1329,1332,3,280,140,0,1330,1332,3,296,148,0,1331,1329,
        1,0,0,0,1331,1330,1,0,0,0,1332,279,1,0,0,0,1333,1336,3,288,144,0,
        1334,1336,3,292,146,0,1335,1333,1,0,0,0,1335,1334,1,0,0,0,1336,281,
        1,0,0,0,1337,1338,5,91,0,0,1338,283,1,0,0,0,1339,1340,5,91,0,0,1340,
        285,1,0,0,0,1341,1342,7,6,0,0,1342,287,1,0,0,0,1343,1344,3,290,145,
        0,1344,289,1,0,0,0,1345,1346,3,392,196,0,1346,291,1,0,0,0,1347,1348,
        3,294,147,0,1348,293,1,0,0,0,1349,1350,3,396,198,0,1350,295,1,0,
        0,0,1351,1352,3,298,149,0,1352,297,1,0,0,0,1353,1354,3,394,197,0,
        1354,299,1,0,0,0,1355,1358,3,398,199,0,1356,1358,5,96,0,0,1357,1355,
        1,0,0,0,1357,1356,1,0,0,0,1358,301,1,0,0,0,1359,1360,5,93,0,0,1360,
        303,1,0,0,0,1361,1370,3,308,154,0,1362,1370,3,322,161,0,1363,1370,
        3,326,163,0,1364,1370,5,94,0,0,1365,1366,5,12,0,0,1366,1367,3,306,
        153,0,1367,1368,5,13,0,0,1368,1370,1,0,0,0,1369,1361,1,0,0,0,1369,
        1362,1,0,0,0,1369,1363,1,0,0,0,1369,1364,1,0,0,0,1369,1365,1,0,0,
        0,1370,305,1,0,0,0,1371,1376,3,304,152,0,1372,1373,5,2,0,0,1373,
        1375,3,304,152,0,1374,1372,1,0,0,0,1375,1378,1,0,0,0,1376,1374,1,
        0,0,0,1376,1377,1,0,0,0,1377,307,1,0,0,0,1378,1376,1,0,0,0,1379,
        1382,3,390,195,0,1380,1382,3,310,155,0,1381,1379,1,0,0,0,1381,1380,
        1,0,0,0,1382,309,1,0,0,0,1383,1384,5,27,0,0,1384,1385,3,312,156,
        0,1385,1386,5,2,0,0,1386,1387,3,342,171,0,1387,1388,5,2,0,0,1388,
        1389,3,314,157,0,1389,1390,5,11,0,0,1390,311,1,0,0,0,1391,1392,3,
        392,196,0,1392,313,1,0,0,0,1393,1399,5,17,0,0,1394,1395,5,12,0,0,
        1395,1396,3,316,158,0,1396,1397,5,13,0,0,1397,1399,1,0,0,0,1398,
        1393,1,0,0,0,1398,1394,1,0,0,0,1399,315,1,0,0,0,1400,1405,3,318,
        159,0,1401,1402,5,2,0,0,1402,1404,3,318,159,0,1403,1401,1,0,0,0,
        1404,1407,1,0,0,0,1405,1403,1,0,0,0,1405,1406,1,0,0,0,1406,317,1,
        0,0,0,1407,1405,1,0,0,0,1408,1410,3,304,152,0,1409,1411,3,320,160,
        0,1410,1409,1,0,0,0,1410,1411,1,0,0,0,1411,319,1,0,0,0,1412,1413,
        5,14,0,0,1413,1414,3,386,193,0,1414,321,1,0,0,0,1415,1416,5,28,0,
        0,1416,1418,3,324,162,0,1417,1419,3,340,170,0,1418,1417,1,0,0,0,
        1418,1419,1,0,0,0,1419,1420,1,0,0,0,1420,1421,5,11,0,0,1421,323,
        1,0,0,0,1422,1423,5,94,0,0,1423,325,1,0,0,0,1424,1428,3,328,164,
        0,1425,1428,3,332,166,0,1426,1428,3,336,168,0,1427,1424,1,0,0,0,
        1427,1425,1,0,0,0,1427,1426,1,0,0,0,1428,327,1,0,0,0,1429,1430,5,
        29,0,0,1430,1432,3,400,200,0,1431,1433,3,330,165,0,1432,1431,1,0,
        0,0,1432,1433,1,0,0,0,1433,1434,1,0,0,0,1434,1435,5,11,0,0,1435,
        329,1,0,0,0,1436,1437,5,2,0,0,1437,1438,3,390,195,0,1438,331,1,0,
        0,0,1439,1440,5,30,0,0,1440,1442,3,334,167,0,1441,1443,3,340,170,
        0,1442,1441,1,0,0,0,1442,1443,1,0,0,0,1443,1444,1,0,0,0,1444,1445,
        5,11,0,0,1445,333,1,0,0,0,1446,1447,5,94,0,0,1447,335,1,0,0,0,1448,
        1449,5,31,0,0,1449,1451,3,338,169,0,1450,1452,3,340,170,0,1451,1450,
        1,0,0,0,1451,1452,1,0,0,0,1452,1453,1,0,0,0,1453,1454,5,11,0,0,1454,
        337,1,0,0,0,1455,1456,3,392,196,0,1456,339,1,0,0,0,1457,1458,5,2,
        0,0,1458,1459,3,342,171,0,1459,341,1,0,0,0,1460,1467,5,17,0,0,1461,
        1462,5,12,0,0,1462,1463,3,344,172,0,1463,1464,5,13,0,0,1464,1467,
        1,0,0,0,1465,1467,3,386,193,0,1466,1460,1,0,0,0,1466,1461,1,0,0,
        0,1466,1465,1,0,0,0,1467,343,1,0,0,0,1468,1473,3,346,173,0,1469,
        1470,5,2,0,0,1470,1472,3,346,173,0,1471,1469,1,0,0,0,1472,1475,1,
        0,0,0,1473,1471,1,0,0,0,1473,1474,1,0,0,0,1474,345,1,0,0,0,1475,
        1473,1,0,0,0,1476,1480,3,348,174,0,1477,1480,3,354,177,0,1478,1480,
        3,382,191,0,1479,1476,1,0,0,0,1479,1477,1,0,0,0,1479,1478,1,0,0,
        0,1480,347,1,0,0,0,1481,1484,3,350,175,0,1482,1484,3,352,176,0,1483,
        1481,1,0,0,0,1483,1482,1,0,0,0,1484,349,1,0,0,0,1485,1486,5,32,0,
        0,1486,1487,3,392,196,0,1487,1488,5,11,0,0,1488,351,1,0,0,0,1489,
        1490,5,33,0,0,1490,1491,3,392,196,0,1491,1492,5,11,0,0,1492,353,
        1,0,0,0,1493,1498,3,356,178,0,1494,1498,3,362,181,0,1495,1498,3,
        366,183,0,1496,1498,3,364,182,0,1497,1493,1,0,0,0,1497,1494,1,0,
        0,0,1497,1495,1,0,0,0,1497,1496,1,0,0,0,1498,355,1,0,0,0,1499,1500,
        5,34,0,0,1500,1501,3,358,179,0,1501,1502,5,11,0,0,1502,1505,1,0,
        0,0,1503,1505,3,360,180,0,1504,1499,1,0,0,0,1504,1503,1,0,0,0,1505,
        357,1,0,0,0,1506,1507,5,94,0,0,1507,359,1,0,0,0,1508,1509,3,312,
        156,0,1509,1510,5,10,0,0,1510,1511,3,392,196,0,1511,1512,5,2,0,0,
        1512,1513,3,386,193,0,1513,1514,5,11,0,0,1514,361,1,0,0,0,1515,1516,
        5,35,0,0,1516,1517,5,12,0,0,1517,1518,3,376,188,0,1518,1519,5,13,
        0,0,1519,1520,5,11,0,0,1520,363,1,0,0,0,1521,1522,5,36,0,0,1522,
        1523,3,328,164,0,1523,1524,5,11,0,0,1524,365,1,0,0,0,1525,1526,5,
        37,0,0,1526,1527,3,392,196,0,1527,1528,5,2,0,0,1528,1529,5,12,0,
        0,1529,1530,3,368,184,0,1530,1531,5,13,0,0,1531,1532,5,11,0,0,1532,
        367,1,0,0,0,1533,1538,3,370,185,0,1534,1535,5,2,0,0,1535,1537,3,
        370,185,0,1536,1534,1,0,0,0,1537,1540,1,0,0,0,1538,1536,1,0,0,0,
        1538,1539,1,0,0,0,1539,369,1,0,0,0,1540,1538,1,0,0,0,1541,1544,3,
        290,145,0,1542,1544,3,302,151,0,1543,1541,1,0,0,0,1543,1542,1,0,
        0,0,1544,371,1,0,0,0,1545,1546,5,38,0,0,1546,1548,3,400,200,0,1547,
        1549,3,374,187,0,1548,1547,1,0,0,0,1548,1549,1,0,0,0,1549,1550,1,
        0,0,0,1550,1551,5,3,0,0,1551,373,1,0,0,0,1552,1553,5,2,0,0,1553,
        1554,5,12,0,0,1554,1555,3,376,188,0,1555,1556,5,13,0,0,1556,375,
        1,0,0,0,1557,1562,3,390,195,0,1558,1559,5,2,0,0,1559,1561,3,390,
        195,0,1560,1558,1,0,0,0,1561,1564,1,0,0,0,1562,1560,1,0,0,0,1562,
        1563,1,0,0,0,1563,377,1,0,0,0,1564,1562,1,0,0,0,1565,1572,3,380,
        190,0,1566,1567,3,380,190,0,1567,1568,5,14,0,0,1568,1569,3,378,189,
        0,1569,1572,1,0,0,0,1570,1572,3,386,193,0,1571,1565,1,0,0,0,1571,
        1566,1,0,0,0,1571,1570,1,0,0,0,1572,379,1,0,0,0,1573,1580,3,392,
        196,0,1574,1580,3,382,191,0,1575,1580,3,302,151,0,1576,1580,3,398,
        199,0,1577,1580,5,96,0,0,1578,1580,3,384,192,0,1579,1573,1,0,0,0,
        1579,1574,1,0,0,0,1579,1575,1,0,0,0,1579,1576,1,0,0,0,1579,1577,
        1,0,0,0,1579,1578,1,0,0,0,1580,381,1,0,0,0,1581,1582,3,392,196,0,
        1582,1583,5,10,0,0,1583,1584,3,388,194,0,1584,1585,5,11,0,0,1585,
        383,1,0,0,0,1586,1587,5,39,0,0,1587,1588,3,26,13,0,1588,1589,5,11,
        0,0,1589,1607,1,0,0,0,1590,1591,5,40,0,0,1591,1592,3,98,49,0,1592,
        1593,5,11,0,0,1593,1607,1,0,0,0,1594,1595,5,41,0,0,1595,1596,3,178,
        89,0,1596,1597,5,11,0,0,1597,1607,1,0,0,0,1598,1599,5,42,0,0,1599,
        1600,3,242,121,0,1600,1601,5,11,0,0,1601,1607,1,0,0,0,1602,1603,
        5,43,0,0,1603,1604,3,226,113,0,1604,1605,5,11,0,0,1605,1607,1,0,
        0,0,1606,1586,1,0,0,0,1606,1590,1,0,0,0,1606,1594,1,0,0,0,1606,1598,
        1,0,0,0,1606,1602,1,0,0,0,1607,385,1,0,0,0,1608,1614,5,17,0,0,1609,
        1610,5,12,0,0,1610,1611,3,388,194,0,1611,1612,5,13,0,0,1612,1614,
        1,0,0,0,1613,1608,1,0,0,0,1613,1609,1,0,0,0,1614,387,1,0,0,0,1615,
        1620,3,378,189,0,1616,1617,5,2,0,0,1617,1619,3,378,189,0,1618,1616,
        1,0,0,0,1619,1622,1,0,0,0,1620,1618,1,0,0,0,1620,1621,1,0,0,0,1621,
        389,1,0,0,0,1622,1620,1,0,0,0,1623,1626,3,392,196,0,1624,1626,5,
        80,0,0,1625,1623,1,0,0,0,1625,1624,1,0,0,0,1626,391,1,0,0,0,1627,
        1628,7,7,0,0,1628,393,1,0,0,0,1629,1630,5,91,0,0,1630,395,1,0,0,
        0,1631,1632,5,92,0,0,1632,397,1,0,0,0,1633,1634,7,8,0,0,1634,399,
        1,0,0,0,1635,1636,5,95,0,0,1636,401,1,0,0,0,125,405,412,421,430,
        443,454,465,476,487,498,505,511,517,522,531,543,556,569,582,598,
        603,618,636,641,668,677,686,696,708,721,732,744,751,756,763,768,
        772,780,792,805,817,831,836,846,870,877,884,895,905,912,919,930,
        940,950,957,964,975,988,1002,1009,1019,1026,1043,1048,1052,1063,
        1067,1071,1079,1091,1104,1114,1128,1135,1144,1150,1166,1170,1180,
        1188,1195,1203,1208,1230,1237,1247,1254,1261,1269,1279,1286,1291,
        1301,1305,1311,1331,1335,1357,1369,1376,1381,1398,1405,1410,1418,
        1427,1432,1442,1451,1466,1473,1479,1483,1497,1504,1538,1543,1548,
        1562,1571,1579,1606,1613,1620,1625
    ]

class TptpParser ( Parser ):

    grammarFileName = "Tptp.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'tpi('", "','", "').'", "'thf('", "'tfx('", 
                     "'tff('", "'tcf('", "'fof('", "'cnf('", "'('", "')'", 
                     "'['", "']'", "':'", "'$ite('", "'$let('", "'[]'", 
                     "'{}'", "'{'", "'}'", "'$ite_f('", "'$let_tf('", "'$let_ff('", 
                     "'$ite_t('", "'$let_ft('", "'$let_tt('", "'inference('", 
                     "'introduced('", "'file('", "'theory('", "'creator('", 
                     "'description('", "'iquote('", "'status('", "'assumptions('", 
                     "'refutation('", "'new_symbols('", "'include('", "'$thf('", 
                     "'$tff('", "'$fof('", "'$cnf('", "'$fot('", "'|'", 
                     "'&'", "'<=>'", "'=>'", "'<='", "'<~>'", "'~|'", "'~&'", 
                     "'~'", "'!!'", "'!>'", "'!='", "'='", "'!'", "'??'", 
                     "'?*'", "'?'", "'^'", "'@@+'", "'@+'", "'@@-'", "'@-'", 
                     "'@='", "'@'", "':='", "'>'", "'*'", "'+'", "'<<'", 
                     "'-->'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "Or", "And", "Iff", "Impl", "If", "Niff", "Nor", "Nand", 
                      "Not", "ForallComb", "TyForall", "Infix_inequality", 
                      "Infix_equality", "Forall", "ExistsComb", "TyExists", 
                      "Exists", "Lambda", "ChoiceComb", "Choice", "DescriptionComb", 
                      "Description", "EqComb", "App", "Assignment", "Arrow", 
                      "Star", "Plus", "Subtype_sign", "Gentzen_arrow", "Real", 
                      "Signed_real", "Unsigned_real", "Rational", "Signed_rational", 
                      "Unsigned_rational", "Integer", "Signed_integer", 
                      "Unsigned_integer", "Decimal", "Positive_decimal", 
                      "Decimal_exponent", "Decimal_fraction", "Dot_decimal", 
                      "Exp_integer", "Signed_exp_integer", "Unsigned_exp_integer", 
                      "Dollar_word", "Dollar_dollar_word", "Upper_word", 
                      "Lower_word", "Single_quoted", "Distinct_object", 
                      "WS", "Line_comment", "Block_comment" ]

    RULE_tptp_file = 0
    RULE_tptp_input = 1
    RULE_annotated_formula = 2
    RULE_tpi_annotated = 3
    RULE_tpi_formula = 4
    RULE_thf_annotated = 5
    RULE_tfx_annotated = 6
    RULE_tff_annotated = 7
    RULE_tcf_annotated = 8
    RULE_fof_annotated = 9
    RULE_cnf_annotated = 10
    RULE_annotations = 11
    RULE_formula_role = 12
    RULE_thf_formula = 13
    RULE_thf_logic_formula = 14
    RULE_thf_binary_formula = 15
    RULE_thf_binary_pair = 16
    RULE_thf_binary_tuple = 17
    RULE_thf_or_formula = 18
    RULE_thf_and_formula = 19
    RULE_thf_apply_formula = 20
    RULE_thf_unitary_formula = 21
    RULE_thf_quantified_formula = 22
    RULE_thf_quantification = 23
    RULE_thf_variable_list = 24
    RULE_thf_variable = 25
    RULE_thf_typed_variable = 26
    RULE_thf_unary_formula = 27
    RULE_thf_atom = 28
    RULE_thf_function = 29
    RULE_thf_conn_term = 30
    RULE_thf_conditional = 31
    RULE_thf_let = 32
    RULE_thf_arguments = 33
    RULE_thf_type_formula = 34
    RULE_thf_typeable_formula = 35
    RULE_thf_subtype = 36
    RULE_thf_top_level_type = 37
    RULE_thf_unitary_type = 38
    RULE_thf_apply_type = 39
    RULE_thf_binary_type = 40
    RULE_thf_mapping_type = 41
    RULE_thf_xprod_type = 42
    RULE_thf_union_type = 43
    RULE_thf_sequent = 44
    RULE_thf_tuple = 45
    RULE_thf_formula_list = 46
    RULE_tfx_formula = 47
    RULE_tfx_logic_formula = 48
    RULE_tff_formula = 49
    RULE_tff_logic_formula = 50
    RULE_tff_binary_formula = 51
    RULE_tff_binary_nonassoc = 52
    RULE_tff_binary_assoc = 53
    RULE_tff_or_formula = 54
    RULE_tff_and_formula = 55
    RULE_tff_unitary_formula = 56
    RULE_tff_quantified_formula = 57
    RULE_tff_variable_list = 58
    RULE_tff_variable = 59
    RULE_tff_typed_variable = 60
    RULE_tff_unary_formula = 61
    RULE_tff_atomic_formula = 62
    RULE_tff_conditional = 63
    RULE_tff_let = 64
    RULE_tff_let_term_defns = 65
    RULE_tff_let_term_list = 66
    RULE_tff_let_term_defn = 67
    RULE_tff_let_term_binding = 68
    RULE_tff_let_formula_defns = 69
    RULE_tff_let_formula_list = 70
    RULE_tff_let_formula_defn = 71
    RULE_tff_let_formula_binding = 72
    RULE_tff_sequent = 73
    RULE_tff_formula_tuple = 74
    RULE_tff_formula_tuple_list = 75
    RULE_tff_typed_atom = 76
    RULE_tff_subtype = 77
    RULE_tff_top_level_type = 78
    RULE_tf1_quantified_type = 79
    RULE_tff_monotype = 80
    RULE_tff_unitary_type = 81
    RULE_tff_atomic_type = 82
    RULE_tff_type_arguments = 83
    RULE_tff_mapping_type = 84
    RULE_tff_xprod_type = 85
    RULE_tcf_formula = 86
    RULE_tcf_logic_formula = 87
    RULE_tcf_quantified_formula = 88
    RULE_fof_formula = 89
    RULE_fof_logic_formula = 90
    RULE_fof_binary_formula = 91
    RULE_fof_binary_nonassoc = 92
    RULE_fof_binary_assoc = 93
    RULE_fof_or_formula = 94
    RULE_fof_and_formula = 95
    RULE_fof_unitary_formula = 96
    RULE_fof_quantified_formula = 97
    RULE_fof_variable_list = 98
    RULE_fof_unary_formula = 99
    RULE_fof_infix_unary = 100
    RULE_fof_atomic_formula = 101
    RULE_fof_plain_atomic_formula = 102
    RULE_fof_defined_atomic_formula = 103
    RULE_fof_defined_plain_formula = 104
    RULE_fof_defined_infix_formula = 105
    RULE_fof_system_atomic_formula = 106
    RULE_fof_plain_term = 107
    RULE_fof_defined_term = 108
    RULE_fof_defined_atomic_term = 109
    RULE_fof_defined_plain_term = 110
    RULE_fof_system_term = 111
    RULE_fof_arguments = 112
    RULE_fof_term = 113
    RULE_fof_function_term = 114
    RULE_tff_conditional_term = 115
    RULE_tff_let_term = 116
    RULE_tff_tuple_term = 117
    RULE_fof_sequent = 118
    RULE_fof_formula_tuple = 119
    RULE_fof_formula_tuple_list = 120
    RULE_cnf_formula = 121
    RULE_cnf_disjunction = 122
    RULE_cnf_literal = 123
    RULE_thf_quantifier = 124
    RULE_th0_quantifier = 125
    RULE_th1_quantifier = 126
    RULE_thf_pair_connective = 127
    RULE_thf_unary_connective = 128
    RULE_th1_unary_connective = 129
    RULE_tff_pair_connective = 130
    RULE_fof_quantifier = 131
    RULE_binary_connective = 132
    RULE_assoc_connective = 133
    RULE_unary_connective = 134
    RULE_type_constant = 135
    RULE_type_functor = 136
    RULE_defined_type = 137
    RULE_system_type = 138
    RULE_atom = 139
    RULE_untyped_atom = 140
    RULE_defined_proposition = 141
    RULE_defined_predicate = 142
    RULE_defined_infix_pred = 143
    RULE_constant = 144
    RULE_functor = 145
    RULE_system_constant = 146
    RULE_system_functor = 147
    RULE_defined_constant = 148
    RULE_defined_functor = 149
    RULE_defined_term = 150
    RULE_variable = 151
    RULE_source = 152
    RULE_sources = 153
    RULE_dag_source = 154
    RULE_inference_record = 155
    RULE_inference_rule = 156
    RULE_inference_parents = 157
    RULE_parent_list = 158
    RULE_parent_info = 159
    RULE_parent_details = 160
    RULE_internal_source = 161
    RULE_intro_type = 162
    RULE_external_source = 163
    RULE_file_source = 164
    RULE_file_info = 165
    RULE_theory = 166
    RULE_theory_name = 167
    RULE_creator_source = 168
    RULE_creator_name = 169
    RULE_optional_info = 170
    RULE_useful_info = 171
    RULE_info_items = 172
    RULE_info_item = 173
    RULE_formula_item = 174
    RULE_description_item = 175
    RULE_iquote_item = 176
    RULE_inference_item = 177
    RULE_inference_status = 178
    RULE_status_value = 179
    RULE_inference_info = 180
    RULE_assumptions_record = 181
    RULE_refutation = 182
    RULE_new_symbol_record = 183
    RULE_new_symbol_list = 184
    RULE_principal_symbol = 185
    RULE_include = 186
    RULE_formula_selection = 187
    RULE_name_list = 188
    RULE_general_term = 189
    RULE_general_data = 190
    RULE_general_function = 191
    RULE_formula_data = 192
    RULE_general_list = 193
    RULE_general_terms = 194
    RULE_name = 195
    RULE_atomic_word = 196
    RULE_atomic_defined_word = 197
    RULE_atomic_system_word = 198
    RULE_number = 199
    RULE_file_name = 200

    ruleNames =  [ "tptp_file", "tptp_input", "annotated_formula", "tpi_annotated", 
                   "tpi_formula", "thf_annotated", "tfx_annotated", "tff_annotated", 
                   "tcf_annotated", "fof_annotated", "cnf_annotated", "annotations", 
                   "formula_role", "thf_formula", "thf_logic_formula", "thf_binary_formula", 
                   "thf_binary_pair", "thf_binary_tuple", "thf_or_formula", 
                   "thf_and_formula", "thf_apply_formula", "thf_unitary_formula", 
                   "thf_quantified_formula", "thf_quantification", "thf_variable_list", 
                   "thf_variable", "thf_typed_variable", "thf_unary_formula", 
                   "thf_atom", "thf_function", "thf_conn_term", "thf_conditional", 
                   "thf_let", "thf_arguments", "thf_type_formula", "thf_typeable_formula", 
                   "thf_subtype", "thf_top_level_type", "thf_unitary_type", 
                   "thf_apply_type", "thf_binary_type", "thf_mapping_type", 
                   "thf_xprod_type", "thf_union_type", "thf_sequent", "thf_tuple", 
                   "thf_formula_list", "tfx_formula", "tfx_logic_formula", 
                   "tff_formula", "tff_logic_formula", "tff_binary_formula", 
                   "tff_binary_nonassoc", "tff_binary_assoc", "tff_or_formula", 
                   "tff_and_formula", "tff_unitary_formula", "tff_quantified_formula", 
                   "tff_variable_list", "tff_variable", "tff_typed_variable", 
                   "tff_unary_formula", "tff_atomic_formula", "tff_conditional", 
                   "tff_let", "tff_let_term_defns", "tff_let_term_list", 
                   "tff_let_term_defn", "tff_let_term_binding", "tff_let_formula_defns", 
                   "tff_let_formula_list", "tff_let_formula_defn", "tff_let_formula_binding", 
                   "tff_sequent", "tff_formula_tuple", "tff_formula_tuple_list", 
                   "tff_typed_atom", "tff_subtype", "tff_top_level_type", 
                   "tf1_quantified_type", "tff_monotype", "tff_unitary_type", 
                   "tff_atomic_type", "tff_type_arguments", "tff_mapping_type", 
                   "tff_xprod_type", "tcf_formula", "tcf_logic_formula", 
                   "tcf_quantified_formula", "fof_formula", "fof_logic_formula", 
                   "fof_binary_formula", "fof_binary_nonassoc", "fof_binary_assoc", 
                   "fof_or_formula", "fof_and_formula", "fof_unitary_formula", 
                   "fof_quantified_formula", "fof_variable_list", "fof_unary_formula", 
                   "fof_infix_unary", "fof_atomic_formula", "fof_plain_atomic_formula", 
                   "fof_defined_atomic_formula", "fof_defined_plain_formula", 
                   "fof_defined_infix_formula", "fof_system_atomic_formula", 
                   "fof_plain_term", "fof_defined_term", "fof_defined_atomic_term", 
                   "fof_defined_plain_term", "fof_system_term", "fof_arguments", 
                   "fof_term", "fof_function_term", "tff_conditional_term", 
                   "tff_let_term", "tff_tuple_term", "fof_sequent", "fof_formula_tuple", 
                   "fof_formula_tuple_list", "cnf_formula", "cnf_disjunction", 
                   "cnf_literal", "thf_quantifier", "th0_quantifier", "th1_quantifier", 
                   "thf_pair_connective", "thf_unary_connective", "th1_unary_connective", 
                   "tff_pair_connective", "fof_quantifier", "binary_connective", 
                   "assoc_connective", "unary_connective", "type_constant", 
                   "type_functor", "defined_type", "system_type", "atom", 
                   "untyped_atom", "defined_proposition", "defined_predicate", 
                   "defined_infix_pred", "constant", "functor", "system_constant", 
                   "system_functor", "defined_constant", "defined_functor", 
                   "defined_term", "variable", "source", "sources", "dag_source", 
                   "inference_record", "inference_rule", "inference_parents", 
                   "parent_list", "parent_info", "parent_details", "internal_source", 
                   "intro_type", "external_source", "file_source", "file_info", 
                   "theory", "theory_name", "creator_source", "creator_name", 
                   "optional_info", "useful_info", "info_items", "info_item", 
                   "formula_item", "description_item", "iquote_item", "inference_item", 
                   "inference_status", "status_value", "inference_info", 
                   "assumptions_record", "refutation", "new_symbol_record", 
                   "new_symbol_list", "principal_symbol", "include", "formula_selection", 
                   "name_list", "general_term", "general_data", "general_function", 
                   "formula_data", "general_list", "general_terms", "name", 
                   "atomic_word", "atomic_defined_word", "atomic_system_word", 
                   "number", "file_name" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    T__11=12
    T__12=13
    T__13=14
    T__14=15
    T__15=16
    T__16=17
    T__17=18
    T__18=19
    T__19=20
    T__20=21
    T__21=22
    T__22=23
    T__23=24
    T__24=25
    T__25=26
    T__26=27
    T__27=28
    T__28=29
    T__29=30
    T__30=31
    T__31=32
    T__32=33
    T__33=34
    T__34=35
    T__35=36
    T__36=37
    T__37=38
    T__38=39
    T__39=40
    T__40=41
    T__41=42
    T__42=43
    Or=44
    And=45
    Iff=46
    Impl=47
    If=48
    Niff=49
    Nor=50
    Nand=51
    Not=52
    ForallComb=53
    TyForall=54
    Infix_inequality=55
    Infix_equality=56
    Forall=57
    ExistsComb=58
    TyExists=59
    Exists=60
    Lambda=61
    ChoiceComb=62
    Choice=63
    DescriptionComb=64
    Description=65
    EqComb=66
    App=67
    Assignment=68
    Arrow=69
    Star=70
    Plus=71
    Subtype_sign=72
    Gentzen_arrow=73
    Real=74
    Signed_real=75
    Unsigned_real=76
    Rational=77
    Signed_rational=78
    Unsigned_rational=79
    Integer=80
    Signed_integer=81
    Unsigned_integer=82
    Decimal=83
    Positive_decimal=84
    Decimal_exponent=85
    Decimal_fraction=86
    Dot_decimal=87
    Exp_integer=88
    Signed_exp_integer=89
    Unsigned_exp_integer=90
    Dollar_word=91
    Dollar_dollar_word=92
    Upper_word=93
    Lower_word=94
    Single_quoted=95
    Distinct_object=96
    WS=97
    Line_comment=98
    Block_comment=99

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.10.1")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class Tptp_fileContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(TptpParser.EOF, 0)

        def tptp_input(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TptpParser.Tptp_inputContext)
            else:
                return self.getTypedRuleContext(TptpParser.Tptp_inputContext,i)


        def getRuleIndex(self):
            return TptpParser.RULE_tptp_file

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTptp_file" ):
                listener.enterTptp_file(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTptp_file" ):
                listener.exitTptp_file(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTptp_file" ):
                return visitor.visitTptp_file(self)
            else:
                return visitor.visitChildren(self)




    def tptp_file(self):

        localctx = TptpParser.Tptp_fileContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_tptp_file)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 405
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << TptpParser.T__0) | (1 << TptpParser.T__3) | (1 << TptpParser.T__4) | (1 << TptpParser.T__5) | (1 << TptpParser.T__6) | (1 << TptpParser.T__7) | (1 << TptpParser.T__8) | (1 << TptpParser.T__37))) != 0):
                self.state = 402
                self.tptp_input()
                self.state = 407
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 408
            self.match(TptpParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Tptp_inputContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def annotated_formula(self):
            return self.getTypedRuleContext(TptpParser.Annotated_formulaContext,0)


        def include(self):
            return self.getTypedRuleContext(TptpParser.IncludeContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_tptp_input

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTptp_input" ):
                listener.enterTptp_input(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTptp_input" ):
                listener.exitTptp_input(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTptp_input" ):
                return visitor.visitTptp_input(self)
            else:
                return visitor.visitChildren(self)




    def tptp_input(self):

        localctx = TptpParser.Tptp_inputContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_tptp_input)
        try:
            self.state = 412
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TptpParser.T__0, TptpParser.T__3, TptpParser.T__4, TptpParser.T__5, TptpParser.T__6, TptpParser.T__7, TptpParser.T__8]:
                self.enterOuterAlt(localctx, 1)
                self.state = 410
                self.annotated_formula()
                pass
            elif token in [TptpParser.T__37]:
                self.enterOuterAlt(localctx, 2)
                self.state = 411
                self.include()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Annotated_formulaContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def thf_annotated(self):
            return self.getTypedRuleContext(TptpParser.Thf_annotatedContext,0)


        def tfx_annotated(self):
            return self.getTypedRuleContext(TptpParser.Tfx_annotatedContext,0)


        def tff_annotated(self):
            return self.getTypedRuleContext(TptpParser.Tff_annotatedContext,0)


        def tcf_annotated(self):
            return self.getTypedRuleContext(TptpParser.Tcf_annotatedContext,0)


        def fof_annotated(self):
            return self.getTypedRuleContext(TptpParser.Fof_annotatedContext,0)


        def cnf_annotated(self):
            return self.getTypedRuleContext(TptpParser.Cnf_annotatedContext,0)


        def tpi_annotated(self):
            return self.getTypedRuleContext(TptpParser.Tpi_annotatedContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_annotated_formula

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAnnotated_formula" ):
                listener.enterAnnotated_formula(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAnnotated_formula" ):
                listener.exitAnnotated_formula(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAnnotated_formula" ):
                return visitor.visitAnnotated_formula(self)
            else:
                return visitor.visitChildren(self)




    def annotated_formula(self):

        localctx = TptpParser.Annotated_formulaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_annotated_formula)
        try:
            self.state = 421
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TptpParser.T__3]:
                self.enterOuterAlt(localctx, 1)
                self.state = 414
                self.thf_annotated()
                pass
            elif token in [TptpParser.T__4]:
                self.enterOuterAlt(localctx, 2)
                self.state = 415
                self.tfx_annotated()
                pass
            elif token in [TptpParser.T__5]:
                self.enterOuterAlt(localctx, 3)
                self.state = 416
                self.tff_annotated()
                pass
            elif token in [TptpParser.T__6]:
                self.enterOuterAlt(localctx, 4)
                self.state = 417
                self.tcf_annotated()
                pass
            elif token in [TptpParser.T__7]:
                self.enterOuterAlt(localctx, 5)
                self.state = 418
                self.fof_annotated()
                pass
            elif token in [TptpParser.T__8]:
                self.enterOuterAlt(localctx, 6)
                self.state = 419
                self.cnf_annotated()
                pass
            elif token in [TptpParser.T__0]:
                self.enterOuterAlt(localctx, 7)
                self.state = 420
                self.tpi_annotated()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Tpi_annotatedContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self):
            return self.getTypedRuleContext(TptpParser.NameContext,0)


        def formula_role(self):
            return self.getTypedRuleContext(TptpParser.Formula_roleContext,0)


        def tpi_formula(self):
            return self.getTypedRuleContext(TptpParser.Tpi_formulaContext,0)


        def annotations(self):
            return self.getTypedRuleContext(TptpParser.AnnotationsContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_tpi_annotated

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTpi_annotated" ):
                listener.enterTpi_annotated(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTpi_annotated" ):
                listener.exitTpi_annotated(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTpi_annotated" ):
                return visitor.visitTpi_annotated(self)
            else:
                return visitor.visitChildren(self)




    def tpi_annotated(self):

        localctx = TptpParser.Tpi_annotatedContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_tpi_annotated)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 423
            self.match(TptpParser.T__0)
            self.state = 424
            self.name()
            self.state = 425
            self.match(TptpParser.T__1)
            self.state = 426
            self.formula_role()
            self.state = 427
            self.match(TptpParser.T__1)
            self.state = 428
            self.tpi_formula()
            self.state = 430
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==TptpParser.T__1:
                self.state = 429
                self.annotations()


            self.state = 432
            self.match(TptpParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Tpi_formulaContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fof_formula(self):
            return self.getTypedRuleContext(TptpParser.Fof_formulaContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_tpi_formula

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTpi_formula" ):
                listener.enterTpi_formula(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTpi_formula" ):
                listener.exitTpi_formula(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTpi_formula" ):
                return visitor.visitTpi_formula(self)
            else:
                return visitor.visitChildren(self)




    def tpi_formula(self):

        localctx = TptpParser.Tpi_formulaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_tpi_formula)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 434
            self.fof_formula()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Thf_annotatedContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self):
            return self.getTypedRuleContext(TptpParser.NameContext,0)


        def formula_role(self):
            return self.getTypedRuleContext(TptpParser.Formula_roleContext,0)


        def thf_formula(self):
            return self.getTypedRuleContext(TptpParser.Thf_formulaContext,0)


        def annotations(self):
            return self.getTypedRuleContext(TptpParser.AnnotationsContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_thf_annotated

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterThf_annotated" ):
                listener.enterThf_annotated(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitThf_annotated" ):
                listener.exitThf_annotated(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitThf_annotated" ):
                return visitor.visitThf_annotated(self)
            else:
                return visitor.visitChildren(self)




    def thf_annotated(self):

        localctx = TptpParser.Thf_annotatedContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_thf_annotated)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 436
            self.match(TptpParser.T__3)
            self.state = 437
            self.name()
            self.state = 438
            self.match(TptpParser.T__1)
            self.state = 439
            self.formula_role()
            self.state = 440
            self.match(TptpParser.T__1)
            self.state = 441
            self.thf_formula()
            self.state = 443
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==TptpParser.T__1:
                self.state = 442
                self.annotations()


            self.state = 445
            self.match(TptpParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Tfx_annotatedContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self):
            return self.getTypedRuleContext(TptpParser.NameContext,0)


        def formula_role(self):
            return self.getTypedRuleContext(TptpParser.Formula_roleContext,0)


        def tfx_formula(self):
            return self.getTypedRuleContext(TptpParser.Tfx_formulaContext,0)


        def annotations(self):
            return self.getTypedRuleContext(TptpParser.AnnotationsContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_tfx_annotated

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTfx_annotated" ):
                listener.enterTfx_annotated(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTfx_annotated" ):
                listener.exitTfx_annotated(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTfx_annotated" ):
                return visitor.visitTfx_annotated(self)
            else:
                return visitor.visitChildren(self)




    def tfx_annotated(self):

        localctx = TptpParser.Tfx_annotatedContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_tfx_annotated)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 447
            self.match(TptpParser.T__4)
            self.state = 448
            self.name()
            self.state = 449
            self.match(TptpParser.T__1)
            self.state = 450
            self.formula_role()
            self.state = 451
            self.match(TptpParser.T__1)
            self.state = 452
            self.tfx_formula()
            self.state = 454
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==TptpParser.T__1:
                self.state = 453
                self.annotations()


            self.state = 456
            self.match(TptpParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Tff_annotatedContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self):
            return self.getTypedRuleContext(TptpParser.NameContext,0)


        def formula_role(self):
            return self.getTypedRuleContext(TptpParser.Formula_roleContext,0)


        def tff_formula(self):
            return self.getTypedRuleContext(TptpParser.Tff_formulaContext,0)


        def annotations(self):
            return self.getTypedRuleContext(TptpParser.AnnotationsContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_tff_annotated

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTff_annotated" ):
                listener.enterTff_annotated(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTff_annotated" ):
                listener.exitTff_annotated(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTff_annotated" ):
                return visitor.visitTff_annotated(self)
            else:
                return visitor.visitChildren(self)




    def tff_annotated(self):

        localctx = TptpParser.Tff_annotatedContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_tff_annotated)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 458
            self.match(TptpParser.T__5)
            self.state = 459
            self.name()
            self.state = 460
            self.match(TptpParser.T__1)
            self.state = 461
            self.formula_role()
            self.state = 462
            self.match(TptpParser.T__1)
            self.state = 463
            self.tff_formula()
            self.state = 465
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==TptpParser.T__1:
                self.state = 464
                self.annotations()


            self.state = 467
            self.match(TptpParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Tcf_annotatedContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self):
            return self.getTypedRuleContext(TptpParser.NameContext,0)


        def formula_role(self):
            return self.getTypedRuleContext(TptpParser.Formula_roleContext,0)


        def tcf_formula(self):
            return self.getTypedRuleContext(TptpParser.Tcf_formulaContext,0)


        def annotations(self):
            return self.getTypedRuleContext(TptpParser.AnnotationsContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_tcf_annotated

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTcf_annotated" ):
                listener.enterTcf_annotated(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTcf_annotated" ):
                listener.exitTcf_annotated(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTcf_annotated" ):
                return visitor.visitTcf_annotated(self)
            else:
                return visitor.visitChildren(self)




    def tcf_annotated(self):

        localctx = TptpParser.Tcf_annotatedContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_tcf_annotated)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 469
            self.match(TptpParser.T__6)
            self.state = 470
            self.name()
            self.state = 471
            self.match(TptpParser.T__1)
            self.state = 472
            self.formula_role()
            self.state = 473
            self.match(TptpParser.T__1)
            self.state = 474
            self.tcf_formula()
            self.state = 476
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==TptpParser.T__1:
                self.state = 475
                self.annotations()


            self.state = 478
            self.match(TptpParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Fof_annotatedContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self):
            return self.getTypedRuleContext(TptpParser.NameContext,0)


        def formula_role(self):
            return self.getTypedRuleContext(TptpParser.Formula_roleContext,0)


        def fof_formula(self):
            return self.getTypedRuleContext(TptpParser.Fof_formulaContext,0)


        def annotations(self):
            return self.getTypedRuleContext(TptpParser.AnnotationsContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_fof_annotated

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFof_annotated" ):
                listener.enterFof_annotated(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFof_annotated" ):
                listener.exitFof_annotated(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFof_annotated" ):
                return visitor.visitFof_annotated(self)
            else:
                return visitor.visitChildren(self)




    def fof_annotated(self):

        localctx = TptpParser.Fof_annotatedContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_fof_annotated)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 480
            self.match(TptpParser.T__7)
            self.state = 481
            self.name()
            self.state = 482
            self.match(TptpParser.T__1)
            self.state = 483
            self.formula_role()
            self.state = 484
            self.match(TptpParser.T__1)
            self.state = 485
            self.fof_formula()
            self.state = 487
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==TptpParser.T__1:
                self.state = 486
                self.annotations()


            self.state = 489
            self.match(TptpParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Cnf_annotatedContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self):
            return self.getTypedRuleContext(TptpParser.NameContext,0)


        def formula_role(self):
            return self.getTypedRuleContext(TptpParser.Formula_roleContext,0)


        def cnf_formula(self):
            return self.getTypedRuleContext(TptpParser.Cnf_formulaContext,0)


        def annotations(self):
            return self.getTypedRuleContext(TptpParser.AnnotationsContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_cnf_annotated

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCnf_annotated" ):
                listener.enterCnf_annotated(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCnf_annotated" ):
                listener.exitCnf_annotated(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCnf_annotated" ):
                return visitor.visitCnf_annotated(self)
            else:
                return visitor.visitChildren(self)




    def cnf_annotated(self):

        localctx = TptpParser.Cnf_annotatedContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_cnf_annotated)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 491
            self.match(TptpParser.T__8)
            self.state = 492
            self.name()
            self.state = 493
            self.match(TptpParser.T__1)
            self.state = 494
            self.formula_role()
            self.state = 495
            self.match(TptpParser.T__1)
            self.state = 496
            self.cnf_formula()
            self.state = 498
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==TptpParser.T__1:
                self.state = 497
                self.annotations()


            self.state = 500
            self.match(TptpParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AnnotationsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def source(self):
            return self.getTypedRuleContext(TptpParser.SourceContext,0)


        def optional_info(self):
            return self.getTypedRuleContext(TptpParser.Optional_infoContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_annotations

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAnnotations" ):
                listener.enterAnnotations(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAnnotations" ):
                listener.exitAnnotations(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAnnotations" ):
                return visitor.visitAnnotations(self)
            else:
                return visitor.visitChildren(self)




    def annotations(self):

        localctx = TptpParser.AnnotationsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_annotations)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 502
            self.match(TptpParser.T__1)
            self.state = 503
            self.source()
            self.state = 505
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==TptpParser.T__1:
                self.state = 504
                self.optional_info()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Formula_roleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Lower_word(self):
            return self.getToken(TptpParser.Lower_word, 0)

        def getRuleIndex(self):
            return TptpParser.RULE_formula_role

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFormula_role" ):
                listener.enterFormula_role(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFormula_role" ):
                listener.exitFormula_role(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFormula_role" ):
                return visitor.visitFormula_role(self)
            else:
                return visitor.visitChildren(self)




    def formula_role(self):

        localctx = TptpParser.Formula_roleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_formula_role)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 507
            self.match(TptpParser.Lower_word)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Thf_formulaContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def thf_logic_formula(self):
            return self.getTypedRuleContext(TptpParser.Thf_logic_formulaContext,0)


        def thf_sequent(self):
            return self.getTypedRuleContext(TptpParser.Thf_sequentContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_thf_formula

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterThf_formula" ):
                listener.enterThf_formula(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitThf_formula" ):
                listener.exitThf_formula(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitThf_formula" ):
                return visitor.visitThf_formula(self)
            else:
                return visitor.visitChildren(self)




    def thf_formula(self):

        localctx = TptpParser.Thf_formulaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_thf_formula)
        try:
            self.state = 511
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,11,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 509
                self.thf_logic_formula()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 510
                self.thf_sequent()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Thf_logic_formulaContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def thf_binary_formula(self):
            return self.getTypedRuleContext(TptpParser.Thf_binary_formulaContext,0)


        def thf_unitary_formula(self):
            return self.getTypedRuleContext(TptpParser.Thf_unitary_formulaContext,0)


        def thf_type_formula(self):
            return self.getTypedRuleContext(TptpParser.Thf_type_formulaContext,0)


        def thf_subtype(self):
            return self.getTypedRuleContext(TptpParser.Thf_subtypeContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_thf_logic_formula

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterThf_logic_formula" ):
                listener.enterThf_logic_formula(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitThf_logic_formula" ):
                listener.exitThf_logic_formula(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitThf_logic_formula" ):
                return visitor.visitThf_logic_formula(self)
            else:
                return visitor.visitChildren(self)




    def thf_logic_formula(self):

        localctx = TptpParser.Thf_logic_formulaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_thf_logic_formula)
        try:
            self.state = 517
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,12,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 513
                self.thf_binary_formula()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 514
                self.thf_unitary_formula()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 515
                self.thf_type_formula()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 516
                self.thf_subtype()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Thf_binary_formulaContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def thf_binary_pair(self):
            return self.getTypedRuleContext(TptpParser.Thf_binary_pairContext,0)


        def thf_binary_tuple(self):
            return self.getTypedRuleContext(TptpParser.Thf_binary_tupleContext,0)


        def thf_binary_type(self):
            return self.getTypedRuleContext(TptpParser.Thf_binary_typeContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_thf_binary_formula

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterThf_binary_formula" ):
                listener.enterThf_binary_formula(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitThf_binary_formula" ):
                listener.exitThf_binary_formula(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitThf_binary_formula" ):
                return visitor.visitThf_binary_formula(self)
            else:
                return visitor.visitChildren(self)




    def thf_binary_formula(self):

        localctx = TptpParser.Thf_binary_formulaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_thf_binary_formula)
        try:
            self.state = 522
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,13,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 519
                self.thf_binary_pair()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 520
                self.thf_binary_tuple()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 521
                self.thf_binary_type()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Thf_binary_pairContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def thf_unitary_formula(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TptpParser.Thf_unitary_formulaContext)
            else:
                return self.getTypedRuleContext(TptpParser.Thf_unitary_formulaContext,i)


        def thf_pair_connective(self):
            return self.getTypedRuleContext(TptpParser.Thf_pair_connectiveContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_thf_binary_pair

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterThf_binary_pair" ):
                listener.enterThf_binary_pair(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitThf_binary_pair" ):
                listener.exitThf_binary_pair(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitThf_binary_pair" ):
                return visitor.visitThf_binary_pair(self)
            else:
                return visitor.visitChildren(self)




    def thf_binary_pair(self):

        localctx = TptpParser.Thf_binary_pairContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_thf_binary_pair)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 524
            self.thf_unitary_formula()
            self.state = 525
            self.thf_pair_connective()
            self.state = 526
            self.thf_unitary_formula()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Thf_binary_tupleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def thf_or_formula(self):
            return self.getTypedRuleContext(TptpParser.Thf_or_formulaContext,0)


        def thf_and_formula(self):
            return self.getTypedRuleContext(TptpParser.Thf_and_formulaContext,0)


        def thf_apply_formula(self):
            return self.getTypedRuleContext(TptpParser.Thf_apply_formulaContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_thf_binary_tuple

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterThf_binary_tuple" ):
                listener.enterThf_binary_tuple(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitThf_binary_tuple" ):
                listener.exitThf_binary_tuple(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitThf_binary_tuple" ):
                return visitor.visitThf_binary_tuple(self)
            else:
                return visitor.visitChildren(self)




    def thf_binary_tuple(self):

        localctx = TptpParser.Thf_binary_tupleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_thf_binary_tuple)
        try:
            self.state = 531
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,14,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 528
                self.thf_or_formula(0)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 529
                self.thf_and_formula(0)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 530
                self.thf_apply_formula(0)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Thf_or_formulaContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def thf_unitary_formula(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TptpParser.Thf_unitary_formulaContext)
            else:
                return self.getTypedRuleContext(TptpParser.Thf_unitary_formulaContext,i)


        def Or(self):
            return self.getToken(TptpParser.Or, 0)

        def thf_or_formula(self):
            return self.getTypedRuleContext(TptpParser.Thf_or_formulaContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_thf_or_formula

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterThf_or_formula" ):
                listener.enterThf_or_formula(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitThf_or_formula" ):
                listener.exitThf_or_formula(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitThf_or_formula" ):
                return visitor.visitThf_or_formula(self)
            else:
                return visitor.visitChildren(self)



    def thf_or_formula(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = TptpParser.Thf_or_formulaContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 36
        self.enterRecursionRule(localctx, 36, self.RULE_thf_or_formula, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 534
            self.thf_unitary_formula()
            self.state = 535
            self.match(TptpParser.Or)
            self.state = 536
            self.thf_unitary_formula()
            self._ctx.stop = self._input.LT(-1)
            self.state = 543
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,15,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = TptpParser.Thf_or_formulaContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_thf_or_formula)
                    self.state = 538
                    if not self.precpred(self._ctx, 1):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                    self.state = 539
                    self.match(TptpParser.Or)
                    self.state = 540
                    self.thf_unitary_formula() 
                self.state = 545
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,15,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class Thf_and_formulaContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def thf_unitary_formula(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TptpParser.Thf_unitary_formulaContext)
            else:
                return self.getTypedRuleContext(TptpParser.Thf_unitary_formulaContext,i)


        def And(self):
            return self.getToken(TptpParser.And, 0)

        def thf_and_formula(self):
            return self.getTypedRuleContext(TptpParser.Thf_and_formulaContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_thf_and_formula

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterThf_and_formula" ):
                listener.enterThf_and_formula(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitThf_and_formula" ):
                listener.exitThf_and_formula(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitThf_and_formula" ):
                return visitor.visitThf_and_formula(self)
            else:
                return visitor.visitChildren(self)



    def thf_and_formula(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = TptpParser.Thf_and_formulaContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 38
        self.enterRecursionRule(localctx, 38, self.RULE_thf_and_formula, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 547
            self.thf_unitary_formula()
            self.state = 548
            self.match(TptpParser.And)
            self.state = 549
            self.thf_unitary_formula()
            self._ctx.stop = self._input.LT(-1)
            self.state = 556
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,16,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = TptpParser.Thf_and_formulaContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_thf_and_formula)
                    self.state = 551
                    if not self.precpred(self._ctx, 1):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                    self.state = 552
                    self.match(TptpParser.And)
                    self.state = 553
                    self.thf_unitary_formula() 
                self.state = 558
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,16,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class Thf_apply_formulaContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def thf_unitary_formula(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TptpParser.Thf_unitary_formulaContext)
            else:
                return self.getTypedRuleContext(TptpParser.Thf_unitary_formulaContext,i)


        def App(self):
            return self.getToken(TptpParser.App, 0)

        def thf_apply_formula(self):
            return self.getTypedRuleContext(TptpParser.Thf_apply_formulaContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_thf_apply_formula

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterThf_apply_formula" ):
                listener.enterThf_apply_formula(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitThf_apply_formula" ):
                listener.exitThf_apply_formula(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitThf_apply_formula" ):
                return visitor.visitThf_apply_formula(self)
            else:
                return visitor.visitChildren(self)



    def thf_apply_formula(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = TptpParser.Thf_apply_formulaContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 40
        self.enterRecursionRule(localctx, 40, self.RULE_thf_apply_formula, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 560
            self.thf_unitary_formula()
            self.state = 561
            self.match(TptpParser.App)
            self.state = 562
            self.thf_unitary_formula()
            self._ctx.stop = self._input.LT(-1)
            self.state = 569
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,17,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = TptpParser.Thf_apply_formulaContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_thf_apply_formula)
                    self.state = 564
                    if not self.precpred(self._ctx, 1):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                    self.state = 565
                    self.match(TptpParser.App)
                    self.state = 566
                    self.thf_unitary_formula() 
                self.state = 571
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,17,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class Thf_unitary_formulaContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def thf_quantified_formula(self):
            return self.getTypedRuleContext(TptpParser.Thf_quantified_formulaContext,0)


        def thf_unary_formula(self):
            return self.getTypedRuleContext(TptpParser.Thf_unary_formulaContext,0)


        def thf_atom(self):
            return self.getTypedRuleContext(TptpParser.Thf_atomContext,0)


        def thf_conditional(self):
            return self.getTypedRuleContext(TptpParser.Thf_conditionalContext,0)


        def thf_let(self):
            return self.getTypedRuleContext(TptpParser.Thf_letContext,0)


        def thf_tuple(self):
            return self.getTypedRuleContext(TptpParser.Thf_tupleContext,0)


        def thf_logic_formula(self):
            return self.getTypedRuleContext(TptpParser.Thf_logic_formulaContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_thf_unitary_formula

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterThf_unitary_formula" ):
                listener.enterThf_unitary_formula(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitThf_unitary_formula" ):
                listener.exitThf_unitary_formula(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitThf_unitary_formula" ):
                return visitor.visitThf_unitary_formula(self)
            else:
                return visitor.visitChildren(self)




    def thf_unitary_formula(self):

        localctx = TptpParser.Thf_unitary_formulaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_thf_unitary_formula)
        try:
            self.state = 582
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,18,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 572
                self.thf_quantified_formula()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 573
                self.thf_unary_formula()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 574
                self.thf_atom()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 575
                self.thf_conditional()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 576
                self.thf_let()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 577
                self.thf_tuple()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 578
                self.match(TptpParser.T__9)
                self.state = 579
                self.thf_logic_formula()
                self.state = 580
                self.match(TptpParser.T__10)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Thf_quantified_formulaContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def thf_quantification(self):
            return self.getTypedRuleContext(TptpParser.Thf_quantificationContext,0)


        def thf_unitary_formula(self):
            return self.getTypedRuleContext(TptpParser.Thf_unitary_formulaContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_thf_quantified_formula

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterThf_quantified_formula" ):
                listener.enterThf_quantified_formula(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitThf_quantified_formula" ):
                listener.exitThf_quantified_formula(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitThf_quantified_formula" ):
                return visitor.visitThf_quantified_formula(self)
            else:
                return visitor.visitChildren(self)




    def thf_quantified_formula(self):

        localctx = TptpParser.Thf_quantified_formulaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_thf_quantified_formula)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 584
            self.thf_quantification()
            self.state = 585
            self.thf_unitary_formula()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Thf_quantificationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def thf_quantifier(self):
            return self.getTypedRuleContext(TptpParser.Thf_quantifierContext,0)


        def thf_variable_list(self):
            return self.getTypedRuleContext(TptpParser.Thf_variable_listContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_thf_quantification

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterThf_quantification" ):
                listener.enterThf_quantification(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitThf_quantification" ):
                listener.exitThf_quantification(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitThf_quantification" ):
                return visitor.visitThf_quantification(self)
            else:
                return visitor.visitChildren(self)




    def thf_quantification(self):

        localctx = TptpParser.Thf_quantificationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_thf_quantification)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 587
            self.thf_quantifier()
            self.state = 588
            self.match(TptpParser.T__11)
            self.state = 589
            self.thf_variable_list()
            self.state = 590
            self.match(TptpParser.T__12)
            self.state = 591
            self.match(TptpParser.T__13)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Thf_variable_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def thf_variable(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TptpParser.Thf_variableContext)
            else:
                return self.getTypedRuleContext(TptpParser.Thf_variableContext,i)


        def getRuleIndex(self):
            return TptpParser.RULE_thf_variable_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterThf_variable_list" ):
                listener.enterThf_variable_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitThf_variable_list" ):
                listener.exitThf_variable_list(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitThf_variable_list" ):
                return visitor.visitThf_variable_list(self)
            else:
                return visitor.visitChildren(self)




    def thf_variable_list(self):

        localctx = TptpParser.Thf_variable_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_thf_variable_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 593
            self.thf_variable()
            self.state = 598
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==TptpParser.T__1:
                self.state = 594
                self.match(TptpParser.T__1)
                self.state = 595
                self.thf_variable()
                self.state = 600
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Thf_variableContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def thf_typed_variable(self):
            return self.getTypedRuleContext(TptpParser.Thf_typed_variableContext,0)


        def variable(self):
            return self.getTypedRuleContext(TptpParser.VariableContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_thf_variable

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterThf_variable" ):
                listener.enterThf_variable(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitThf_variable" ):
                listener.exitThf_variable(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitThf_variable" ):
                return visitor.visitThf_variable(self)
            else:
                return visitor.visitChildren(self)




    def thf_variable(self):

        localctx = TptpParser.Thf_variableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_thf_variable)
        try:
            self.state = 603
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,20,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 601
                self.thf_typed_variable()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 602
                self.variable()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Thf_typed_variableContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variable(self):
            return self.getTypedRuleContext(TptpParser.VariableContext,0)


        def thf_top_level_type(self):
            return self.getTypedRuleContext(TptpParser.Thf_top_level_typeContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_thf_typed_variable

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterThf_typed_variable" ):
                listener.enterThf_typed_variable(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitThf_typed_variable" ):
                listener.exitThf_typed_variable(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitThf_typed_variable" ):
                return visitor.visitThf_typed_variable(self)
            else:
                return visitor.visitChildren(self)




    def thf_typed_variable(self):

        localctx = TptpParser.Thf_typed_variableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_thf_typed_variable)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 605
            self.variable()
            self.state = 606
            self.match(TptpParser.T__13)
            self.state = 607
            self.thf_top_level_type()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Thf_unary_formulaContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def thf_unary_connective(self):
            return self.getTypedRuleContext(TptpParser.Thf_unary_connectiveContext,0)


        def thf_logic_formula(self):
            return self.getTypedRuleContext(TptpParser.Thf_logic_formulaContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_thf_unary_formula

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterThf_unary_formula" ):
                listener.enterThf_unary_formula(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitThf_unary_formula" ):
                listener.exitThf_unary_formula(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitThf_unary_formula" ):
                return visitor.visitThf_unary_formula(self)
            else:
                return visitor.visitChildren(self)




    def thf_unary_formula(self):

        localctx = TptpParser.Thf_unary_formulaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_thf_unary_formula)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 609
            self.thf_unary_connective()
            self.state = 610
            self.match(TptpParser.T__9)
            self.state = 611
            self.thf_logic_formula()
            self.state = 612
            self.match(TptpParser.T__10)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Thf_atomContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def thf_function(self):
            return self.getTypedRuleContext(TptpParser.Thf_functionContext,0)


        def variable(self):
            return self.getTypedRuleContext(TptpParser.VariableContext,0)


        def defined_term(self):
            return self.getTypedRuleContext(TptpParser.Defined_termContext,0)


        def thf_conn_term(self):
            return self.getTypedRuleContext(TptpParser.Thf_conn_termContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_thf_atom

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterThf_atom" ):
                listener.enterThf_atom(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitThf_atom" ):
                listener.exitThf_atom(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitThf_atom" ):
                return visitor.visitThf_atom(self)
            else:
                return visitor.visitChildren(self)




    def thf_atom(self):

        localctx = TptpParser.Thf_atomContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_thf_atom)
        try:
            self.state = 618
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TptpParser.Dollar_word, TptpParser.Dollar_dollar_word, TptpParser.Lower_word, TptpParser.Single_quoted]:
                self.enterOuterAlt(localctx, 1)
                self.state = 614
                self.thf_function()
                pass
            elif token in [TptpParser.Upper_word]:
                self.enterOuterAlt(localctx, 2)
                self.state = 615
                self.variable()
                pass
            elif token in [TptpParser.Real, TptpParser.Rational, TptpParser.Integer, TptpParser.Distinct_object]:
                self.enterOuterAlt(localctx, 3)
                self.state = 616
                self.defined_term()
                pass
            elif token in [TptpParser.Or, TptpParser.And, TptpParser.Iff, TptpParser.Impl, TptpParser.If, TptpParser.Niff, TptpParser.Nor, TptpParser.Nand, TptpParser.Not, TptpParser.ForallComb, TptpParser.Infix_inequality, TptpParser.Infix_equality, TptpParser.ExistsComb, TptpParser.ChoiceComb, TptpParser.DescriptionComb, TptpParser.EqComb, TptpParser.Assignment]:
                self.enterOuterAlt(localctx, 4)
                self.state = 617
                self.thf_conn_term()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Thf_functionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def atom(self):
            return self.getTypedRuleContext(TptpParser.AtomContext,0)


        def functor(self):
            return self.getTypedRuleContext(TptpParser.FunctorContext,0)


        def thf_arguments(self):
            return self.getTypedRuleContext(TptpParser.Thf_argumentsContext,0)


        def defined_functor(self):
            return self.getTypedRuleContext(TptpParser.Defined_functorContext,0)


        def system_functor(self):
            return self.getTypedRuleContext(TptpParser.System_functorContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_thf_function

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterThf_function" ):
                listener.enterThf_function(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitThf_function" ):
                listener.exitThf_function(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitThf_function" ):
                return visitor.visitThf_function(self)
            else:
                return visitor.visitChildren(self)




    def thf_function(self):

        localctx = TptpParser.Thf_functionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_thf_function)
        try:
            self.state = 636
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,22,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 620
                self.atom()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 621
                self.functor()
                self.state = 622
                self.match(TptpParser.T__9)
                self.state = 623
                self.thf_arguments()
                self.state = 624
                self.match(TptpParser.T__10)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 626
                self.defined_functor()
                self.state = 627
                self.match(TptpParser.T__9)
                self.state = 628
                self.thf_arguments()
                self.state = 629
                self.match(TptpParser.T__10)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 631
                self.system_functor()
                self.state = 632
                self.match(TptpParser.T__9)
                self.state = 633
                self.thf_arguments()
                self.state = 634
                self.match(TptpParser.T__10)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Thf_conn_termContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def thf_pair_connective(self):
            return self.getTypedRuleContext(TptpParser.Thf_pair_connectiveContext,0)


        def assoc_connective(self):
            return self.getTypedRuleContext(TptpParser.Assoc_connectiveContext,0)


        def thf_unary_connective(self):
            return self.getTypedRuleContext(TptpParser.Thf_unary_connectiveContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_thf_conn_term

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterThf_conn_term" ):
                listener.enterThf_conn_term(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitThf_conn_term" ):
                listener.exitThf_conn_term(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitThf_conn_term" ):
                return visitor.visitThf_conn_term(self)
            else:
                return visitor.visitChildren(self)




    def thf_conn_term(self):

        localctx = TptpParser.Thf_conn_termContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_thf_conn_term)
        try:
            self.state = 641
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TptpParser.Iff, TptpParser.Impl, TptpParser.If, TptpParser.Niff, TptpParser.Nor, TptpParser.Nand, TptpParser.Infix_inequality, TptpParser.Infix_equality, TptpParser.Assignment]:
                self.enterOuterAlt(localctx, 1)
                self.state = 638
                self.thf_pair_connective()
                pass
            elif token in [TptpParser.Or, TptpParser.And]:
                self.enterOuterAlt(localctx, 2)
                self.state = 639
                self.assoc_connective()
                pass
            elif token in [TptpParser.Not, TptpParser.ForallComb, TptpParser.ExistsComb, TptpParser.ChoiceComb, TptpParser.DescriptionComb, TptpParser.EqComb]:
                self.enterOuterAlt(localctx, 3)
                self.state = 640
                self.thf_unary_connective()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Thf_conditionalContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def thf_logic_formula(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TptpParser.Thf_logic_formulaContext)
            else:
                return self.getTypedRuleContext(TptpParser.Thf_logic_formulaContext,i)


        def getRuleIndex(self):
            return TptpParser.RULE_thf_conditional

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterThf_conditional" ):
                listener.enterThf_conditional(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitThf_conditional" ):
                listener.exitThf_conditional(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitThf_conditional" ):
                return visitor.visitThf_conditional(self)
            else:
                return visitor.visitChildren(self)




    def thf_conditional(self):

        localctx = TptpParser.Thf_conditionalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_thf_conditional)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 643
            self.match(TptpParser.T__14)
            self.state = 644
            self.thf_logic_formula()
            self.state = 645
            self.match(TptpParser.T__1)
            self.state = 646
            self.thf_logic_formula()
            self.state = 647
            self.match(TptpParser.T__1)
            self.state = 648
            self.thf_logic_formula()
            self.state = 649
            self.match(TptpParser.T__10)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Thf_letContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def thf_unitary_formula(self):
            return self.getTypedRuleContext(TptpParser.Thf_unitary_formulaContext,0)


        def thf_formula(self):
            return self.getTypedRuleContext(TptpParser.Thf_formulaContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_thf_let

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterThf_let" ):
                listener.enterThf_let(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitThf_let" ):
                listener.exitThf_let(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitThf_let" ):
                return visitor.visitThf_let(self)
            else:
                return visitor.visitChildren(self)




    def thf_let(self):

        localctx = TptpParser.Thf_letContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_thf_let)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 651
            self.match(TptpParser.T__15)
            self.state = 652
            self.thf_unitary_formula()
            self.state = 653
            self.match(TptpParser.T__1)
            self.state = 654
            self.thf_formula()
            self.state = 655
            self.match(TptpParser.T__10)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Thf_argumentsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def thf_formula_list(self):
            return self.getTypedRuleContext(TptpParser.Thf_formula_listContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_thf_arguments

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterThf_arguments" ):
                listener.enterThf_arguments(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitThf_arguments" ):
                listener.exitThf_arguments(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitThf_arguments" ):
                return visitor.visitThf_arguments(self)
            else:
                return visitor.visitChildren(self)




    def thf_arguments(self):

        localctx = TptpParser.Thf_argumentsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_thf_arguments)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 657
            self.thf_formula_list()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Thf_type_formulaContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def thf_typeable_formula(self):
            return self.getTypedRuleContext(TptpParser.Thf_typeable_formulaContext,0)


        def thf_top_level_type(self):
            return self.getTypedRuleContext(TptpParser.Thf_top_level_typeContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_thf_type_formula

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterThf_type_formula" ):
                listener.enterThf_type_formula(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitThf_type_formula" ):
                listener.exitThf_type_formula(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitThf_type_formula" ):
                return visitor.visitThf_type_formula(self)
            else:
                return visitor.visitChildren(self)




    def thf_type_formula(self):

        localctx = TptpParser.Thf_type_formulaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_thf_type_formula)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 659
            self.thf_typeable_formula()
            self.state = 660
            self.match(TptpParser.T__13)
            self.state = 661
            self.thf_top_level_type()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Thf_typeable_formulaContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def thf_atom(self):
            return self.getTypedRuleContext(TptpParser.Thf_atomContext,0)


        def thf_logic_formula(self):
            return self.getTypedRuleContext(TptpParser.Thf_logic_formulaContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_thf_typeable_formula

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterThf_typeable_formula" ):
                listener.enterThf_typeable_formula(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitThf_typeable_formula" ):
                listener.exitThf_typeable_formula(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitThf_typeable_formula" ):
                return visitor.visitThf_typeable_formula(self)
            else:
                return visitor.visitChildren(self)




    def thf_typeable_formula(self):

        localctx = TptpParser.Thf_typeable_formulaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_thf_typeable_formula)
        try:
            self.state = 668
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TptpParser.Or, TptpParser.And, TptpParser.Iff, TptpParser.Impl, TptpParser.If, TptpParser.Niff, TptpParser.Nor, TptpParser.Nand, TptpParser.Not, TptpParser.ForallComb, TptpParser.Infix_inequality, TptpParser.Infix_equality, TptpParser.ExistsComb, TptpParser.ChoiceComb, TptpParser.DescriptionComb, TptpParser.EqComb, TptpParser.Assignment, TptpParser.Real, TptpParser.Rational, TptpParser.Integer, TptpParser.Dollar_word, TptpParser.Dollar_dollar_word, TptpParser.Upper_word, TptpParser.Lower_word, TptpParser.Single_quoted, TptpParser.Distinct_object]:
                self.enterOuterAlt(localctx, 1)
                self.state = 663
                self.thf_atom()
                pass
            elif token in [TptpParser.T__9]:
                self.enterOuterAlt(localctx, 2)
                self.state = 664
                self.match(TptpParser.T__9)
                self.state = 665
                self.thf_logic_formula()
                self.state = 666
                self.match(TptpParser.T__10)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Thf_subtypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def thf_atom(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TptpParser.Thf_atomContext)
            else:
                return self.getTypedRuleContext(TptpParser.Thf_atomContext,i)


        def Subtype_sign(self):
            return self.getToken(TptpParser.Subtype_sign, 0)

        def getRuleIndex(self):
            return TptpParser.RULE_thf_subtype

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterThf_subtype" ):
                listener.enterThf_subtype(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitThf_subtype" ):
                listener.exitThf_subtype(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitThf_subtype" ):
                return visitor.visitThf_subtype(self)
            else:
                return visitor.visitChildren(self)




    def thf_subtype(self):

        localctx = TptpParser.Thf_subtypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_thf_subtype)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 670
            self.thf_atom()
            self.state = 671
            self.match(TptpParser.Subtype_sign)
            self.state = 672
            self.thf_atom()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Thf_top_level_typeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def thf_unitary_type(self):
            return self.getTypedRuleContext(TptpParser.Thf_unitary_typeContext,0)


        def thf_mapping_type(self):
            return self.getTypedRuleContext(TptpParser.Thf_mapping_typeContext,0)


        def thf_apply_type(self):
            return self.getTypedRuleContext(TptpParser.Thf_apply_typeContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_thf_top_level_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterThf_top_level_type" ):
                listener.enterThf_top_level_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitThf_top_level_type" ):
                listener.exitThf_top_level_type(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitThf_top_level_type" ):
                return visitor.visitThf_top_level_type(self)
            else:
                return visitor.visitChildren(self)




    def thf_top_level_type(self):

        localctx = TptpParser.Thf_top_level_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_thf_top_level_type)
        try:
            self.state = 677
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,25,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 674
                self.thf_unitary_type()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 675
                self.thf_mapping_type()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 676
                self.thf_apply_type()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Thf_unitary_typeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def thf_unitary_formula(self):
            return self.getTypedRuleContext(TptpParser.Thf_unitary_formulaContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_thf_unitary_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterThf_unitary_type" ):
                listener.enterThf_unitary_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitThf_unitary_type" ):
                listener.exitThf_unitary_type(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitThf_unitary_type" ):
                return visitor.visitThf_unitary_type(self)
            else:
                return visitor.visitChildren(self)




    def thf_unitary_type(self):

        localctx = TptpParser.Thf_unitary_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_thf_unitary_type)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 679
            self.thf_unitary_formula()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Thf_apply_typeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def thf_apply_formula(self):
            return self.getTypedRuleContext(TptpParser.Thf_apply_formulaContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_thf_apply_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterThf_apply_type" ):
                listener.enterThf_apply_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitThf_apply_type" ):
                listener.exitThf_apply_type(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitThf_apply_type" ):
                return visitor.visitThf_apply_type(self)
            else:
                return visitor.visitChildren(self)




    def thf_apply_type(self):

        localctx = TptpParser.Thf_apply_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_thf_apply_type)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 681
            self.thf_apply_formula(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Thf_binary_typeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def thf_mapping_type(self):
            return self.getTypedRuleContext(TptpParser.Thf_mapping_typeContext,0)


        def thf_xprod_type(self):
            return self.getTypedRuleContext(TptpParser.Thf_xprod_typeContext,0)


        def thf_union_type(self):
            return self.getTypedRuleContext(TptpParser.Thf_union_typeContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_thf_binary_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterThf_binary_type" ):
                listener.enterThf_binary_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitThf_binary_type" ):
                listener.exitThf_binary_type(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitThf_binary_type" ):
                return visitor.visitThf_binary_type(self)
            else:
                return visitor.visitChildren(self)




    def thf_binary_type(self):

        localctx = TptpParser.Thf_binary_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_thf_binary_type)
        try:
            self.state = 686
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,26,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 683
                self.thf_mapping_type()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 684
                self.thf_xprod_type(0)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 685
                self.thf_union_type(0)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Thf_mapping_typeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def thf_unitary_type(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TptpParser.Thf_unitary_typeContext)
            else:
                return self.getTypedRuleContext(TptpParser.Thf_unitary_typeContext,i)


        def Arrow(self):
            return self.getToken(TptpParser.Arrow, 0)

        def thf_mapping_type(self):
            return self.getTypedRuleContext(TptpParser.Thf_mapping_typeContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_thf_mapping_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterThf_mapping_type" ):
                listener.enterThf_mapping_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitThf_mapping_type" ):
                listener.exitThf_mapping_type(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitThf_mapping_type" ):
                return visitor.visitThf_mapping_type(self)
            else:
                return visitor.visitChildren(self)




    def thf_mapping_type(self):

        localctx = TptpParser.Thf_mapping_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_thf_mapping_type)
        try:
            self.state = 696
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,27,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 688
                self.thf_unitary_type()
                self.state = 689
                self.match(TptpParser.Arrow)
                self.state = 690
                self.thf_unitary_type()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 692
                self.thf_unitary_type()
                self.state = 693
                self.match(TptpParser.Arrow)
                self.state = 694
                self.thf_mapping_type()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Thf_xprod_typeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def thf_unitary_type(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TptpParser.Thf_unitary_typeContext)
            else:
                return self.getTypedRuleContext(TptpParser.Thf_unitary_typeContext,i)


        def Star(self):
            return self.getToken(TptpParser.Star, 0)

        def thf_xprod_type(self):
            return self.getTypedRuleContext(TptpParser.Thf_xprod_typeContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_thf_xprod_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterThf_xprod_type" ):
                listener.enterThf_xprod_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitThf_xprod_type" ):
                listener.exitThf_xprod_type(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitThf_xprod_type" ):
                return visitor.visitThf_xprod_type(self)
            else:
                return visitor.visitChildren(self)



    def thf_xprod_type(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = TptpParser.Thf_xprod_typeContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 84
        self.enterRecursionRule(localctx, 84, self.RULE_thf_xprod_type, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 699
            self.thf_unitary_type()
            self.state = 700
            self.match(TptpParser.Star)
            self.state = 701
            self.thf_unitary_type()
            self._ctx.stop = self._input.LT(-1)
            self.state = 708
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,28,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = TptpParser.Thf_xprod_typeContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_thf_xprod_type)
                    self.state = 703
                    if not self.precpred(self._ctx, 1):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                    self.state = 704
                    self.match(TptpParser.Star)
                    self.state = 705
                    self.thf_unitary_type() 
                self.state = 710
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,28,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class Thf_union_typeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def thf_unitary_type(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TptpParser.Thf_unitary_typeContext)
            else:
                return self.getTypedRuleContext(TptpParser.Thf_unitary_typeContext,i)


        def Plus(self):
            return self.getToken(TptpParser.Plus, 0)

        def thf_union_type(self):
            return self.getTypedRuleContext(TptpParser.Thf_union_typeContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_thf_union_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterThf_union_type" ):
                listener.enterThf_union_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitThf_union_type" ):
                listener.exitThf_union_type(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitThf_union_type" ):
                return visitor.visitThf_union_type(self)
            else:
                return visitor.visitChildren(self)



    def thf_union_type(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = TptpParser.Thf_union_typeContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 86
        self.enterRecursionRule(localctx, 86, self.RULE_thf_union_type, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 712
            self.thf_unitary_type()
            self.state = 713
            self.match(TptpParser.Plus)
            self.state = 714
            self.thf_unitary_type()
            self._ctx.stop = self._input.LT(-1)
            self.state = 721
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,29,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = TptpParser.Thf_union_typeContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_thf_union_type)
                    self.state = 716
                    if not self.precpred(self._ctx, 1):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                    self.state = 717
                    self.match(TptpParser.Plus)
                    self.state = 718
                    self.thf_unitary_type() 
                self.state = 723
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,29,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class Thf_sequentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def thf_tuple(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TptpParser.Thf_tupleContext)
            else:
                return self.getTypedRuleContext(TptpParser.Thf_tupleContext,i)


        def Gentzen_arrow(self):
            return self.getToken(TptpParser.Gentzen_arrow, 0)

        def thf_sequent(self):
            return self.getTypedRuleContext(TptpParser.Thf_sequentContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_thf_sequent

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterThf_sequent" ):
                listener.enterThf_sequent(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitThf_sequent" ):
                listener.exitThf_sequent(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitThf_sequent" ):
                return visitor.visitThf_sequent(self)
            else:
                return visitor.visitChildren(self)




    def thf_sequent(self):

        localctx = TptpParser.Thf_sequentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_thf_sequent)
        try:
            self.state = 732
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TptpParser.T__11, TptpParser.T__16, TptpParser.T__17, TptpParser.T__18]:
                self.enterOuterAlt(localctx, 1)
                self.state = 724
                self.thf_tuple()
                self.state = 725
                self.match(TptpParser.Gentzen_arrow)
                self.state = 726
                self.thf_tuple()
                pass
            elif token in [TptpParser.T__9]:
                self.enterOuterAlt(localctx, 2)
                self.state = 728
                self.match(TptpParser.T__9)
                self.state = 729
                self.thf_sequent()
                self.state = 730
                self.match(TptpParser.T__10)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Thf_tupleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def thf_formula_list(self):
            return self.getTypedRuleContext(TptpParser.Thf_formula_listContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_thf_tuple

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterThf_tuple" ):
                listener.enterThf_tuple(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitThf_tuple" ):
                listener.exitThf_tuple(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitThf_tuple" ):
                return visitor.visitThf_tuple(self)
            else:
                return visitor.visitChildren(self)




    def thf_tuple(self):

        localctx = TptpParser.Thf_tupleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_thf_tuple)
        try:
            self.state = 744
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TptpParser.T__16]:
                self.enterOuterAlt(localctx, 1)
                self.state = 734
                self.match(TptpParser.T__16)
                pass
            elif token in [TptpParser.T__11]:
                self.enterOuterAlt(localctx, 2)
                self.state = 735
                self.match(TptpParser.T__11)
                self.state = 736
                self.thf_formula_list()
                self.state = 737
                self.match(TptpParser.T__12)
                pass
            elif token in [TptpParser.T__17]:
                self.enterOuterAlt(localctx, 3)
                self.state = 739
                self.match(TptpParser.T__17)
                pass
            elif token in [TptpParser.T__18]:
                self.enterOuterAlt(localctx, 4)
                self.state = 740
                self.match(TptpParser.T__18)
                self.state = 741
                self.thf_formula_list()
                self.state = 742
                self.match(TptpParser.T__19)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Thf_formula_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def thf_logic_formula(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TptpParser.Thf_logic_formulaContext)
            else:
                return self.getTypedRuleContext(TptpParser.Thf_logic_formulaContext,i)


        def getRuleIndex(self):
            return TptpParser.RULE_thf_formula_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterThf_formula_list" ):
                listener.enterThf_formula_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitThf_formula_list" ):
                listener.exitThf_formula_list(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitThf_formula_list" ):
                return visitor.visitThf_formula_list(self)
            else:
                return visitor.visitChildren(self)




    def thf_formula_list(self):

        localctx = TptpParser.Thf_formula_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_thf_formula_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 746
            self.thf_logic_formula()
            self.state = 751
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==TptpParser.T__1:
                self.state = 747
                self.match(TptpParser.T__1)
                self.state = 748
                self.thf_logic_formula()
                self.state = 753
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Tfx_formulaContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tfx_logic_formula(self):
            return self.getTypedRuleContext(TptpParser.Tfx_logic_formulaContext,0)


        def thf_sequent(self):
            return self.getTypedRuleContext(TptpParser.Thf_sequentContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_tfx_formula

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTfx_formula" ):
                listener.enterTfx_formula(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTfx_formula" ):
                listener.exitTfx_formula(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTfx_formula" ):
                return visitor.visitTfx_formula(self)
            else:
                return visitor.visitChildren(self)




    def tfx_formula(self):

        localctx = TptpParser.Tfx_formulaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_tfx_formula)
        try:
            self.state = 756
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,33,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 754
                self.tfx_logic_formula()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 755
                self.thf_sequent()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Tfx_logic_formulaContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def thf_logic_formula(self):
            return self.getTypedRuleContext(TptpParser.Thf_logic_formulaContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_tfx_logic_formula

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTfx_logic_formula" ):
                listener.enterTfx_logic_formula(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTfx_logic_formula" ):
                listener.exitTfx_logic_formula(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTfx_logic_formula" ):
                return visitor.visitTfx_logic_formula(self)
            else:
                return visitor.visitChildren(self)




    def tfx_logic_formula(self):

        localctx = TptpParser.Tfx_logic_formulaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_tfx_logic_formula)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 758
            self.thf_logic_formula()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Tff_formulaContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tff_logic_formula(self):
            return self.getTypedRuleContext(TptpParser.Tff_logic_formulaContext,0)


        def tff_typed_atom(self):
            return self.getTypedRuleContext(TptpParser.Tff_typed_atomContext,0)


        def tff_sequent(self):
            return self.getTypedRuleContext(TptpParser.Tff_sequentContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_tff_formula

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTff_formula" ):
                listener.enterTff_formula(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTff_formula" ):
                listener.exitTff_formula(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTff_formula" ):
                return visitor.visitTff_formula(self)
            else:
                return visitor.visitChildren(self)




    def tff_formula(self):

        localctx = TptpParser.Tff_formulaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_tff_formula)
        try:
            self.state = 763
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,34,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 760
                self.tff_logic_formula()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 761
                self.tff_typed_atom()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 762
                self.tff_sequent()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Tff_logic_formulaContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tff_binary_formula(self):
            return self.getTypedRuleContext(TptpParser.Tff_binary_formulaContext,0)


        def tff_unitary_formula(self):
            return self.getTypedRuleContext(TptpParser.Tff_unitary_formulaContext,0)


        def tff_subtype(self):
            return self.getTypedRuleContext(TptpParser.Tff_subtypeContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_tff_logic_formula

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTff_logic_formula" ):
                listener.enterTff_logic_formula(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTff_logic_formula" ):
                listener.exitTff_logic_formula(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTff_logic_formula" ):
                return visitor.visitTff_logic_formula(self)
            else:
                return visitor.visitChildren(self)




    def tff_logic_formula(self):

        localctx = TptpParser.Tff_logic_formulaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_tff_logic_formula)
        try:
            self.state = 768
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,35,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 765
                self.tff_binary_formula()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 766
                self.tff_unitary_formula()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 767
                self.tff_subtype()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Tff_binary_formulaContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tff_binary_nonassoc(self):
            return self.getTypedRuleContext(TptpParser.Tff_binary_nonassocContext,0)


        def tff_binary_assoc(self):
            return self.getTypedRuleContext(TptpParser.Tff_binary_assocContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_tff_binary_formula

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTff_binary_formula" ):
                listener.enterTff_binary_formula(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTff_binary_formula" ):
                listener.exitTff_binary_formula(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTff_binary_formula" ):
                return visitor.visitTff_binary_formula(self)
            else:
                return visitor.visitChildren(self)




    def tff_binary_formula(self):

        localctx = TptpParser.Tff_binary_formulaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_tff_binary_formula)
        try:
            self.state = 772
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,36,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 770
                self.tff_binary_nonassoc()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 771
                self.tff_binary_assoc()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Tff_binary_nonassocContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tff_unitary_formula(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TptpParser.Tff_unitary_formulaContext)
            else:
                return self.getTypedRuleContext(TptpParser.Tff_unitary_formulaContext,i)


        def binary_connective(self):
            return self.getTypedRuleContext(TptpParser.Binary_connectiveContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_tff_binary_nonassoc

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTff_binary_nonassoc" ):
                listener.enterTff_binary_nonassoc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTff_binary_nonassoc" ):
                listener.exitTff_binary_nonassoc(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTff_binary_nonassoc" ):
                return visitor.visitTff_binary_nonassoc(self)
            else:
                return visitor.visitChildren(self)




    def tff_binary_nonassoc(self):

        localctx = TptpParser.Tff_binary_nonassocContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_tff_binary_nonassoc)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 774
            self.tff_unitary_formula()
            self.state = 775
            self.binary_connective()
            self.state = 776
            self.tff_unitary_formula()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Tff_binary_assocContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tff_or_formula(self):
            return self.getTypedRuleContext(TptpParser.Tff_or_formulaContext,0)


        def tff_and_formula(self):
            return self.getTypedRuleContext(TptpParser.Tff_and_formulaContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_tff_binary_assoc

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTff_binary_assoc" ):
                listener.enterTff_binary_assoc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTff_binary_assoc" ):
                listener.exitTff_binary_assoc(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTff_binary_assoc" ):
                return visitor.visitTff_binary_assoc(self)
            else:
                return visitor.visitChildren(self)




    def tff_binary_assoc(self):

        localctx = TptpParser.Tff_binary_assocContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_tff_binary_assoc)
        try:
            self.state = 780
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,37,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 778
                self.tff_or_formula(0)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 779
                self.tff_and_formula(0)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Tff_or_formulaContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tff_unitary_formula(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TptpParser.Tff_unitary_formulaContext)
            else:
                return self.getTypedRuleContext(TptpParser.Tff_unitary_formulaContext,i)


        def Or(self):
            return self.getToken(TptpParser.Or, 0)

        def tff_or_formula(self):
            return self.getTypedRuleContext(TptpParser.Tff_or_formulaContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_tff_or_formula

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTff_or_formula" ):
                listener.enterTff_or_formula(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTff_or_formula" ):
                listener.exitTff_or_formula(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTff_or_formula" ):
                return visitor.visitTff_or_formula(self)
            else:
                return visitor.visitChildren(self)



    def tff_or_formula(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = TptpParser.Tff_or_formulaContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 108
        self.enterRecursionRule(localctx, 108, self.RULE_tff_or_formula, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 783
            self.tff_unitary_formula()
            self.state = 784
            self.match(TptpParser.Or)
            self.state = 785
            self.tff_unitary_formula()
            self._ctx.stop = self._input.LT(-1)
            self.state = 792
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,38,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = TptpParser.Tff_or_formulaContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_tff_or_formula)
                    self.state = 787
                    if not self.precpred(self._ctx, 1):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                    self.state = 788
                    self.match(TptpParser.Or)
                    self.state = 789
                    self.tff_unitary_formula() 
                self.state = 794
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,38,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class Tff_and_formulaContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tff_unitary_formula(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TptpParser.Tff_unitary_formulaContext)
            else:
                return self.getTypedRuleContext(TptpParser.Tff_unitary_formulaContext,i)


        def And(self):
            return self.getToken(TptpParser.And, 0)

        def tff_and_formula(self):
            return self.getTypedRuleContext(TptpParser.Tff_and_formulaContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_tff_and_formula

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTff_and_formula" ):
                listener.enterTff_and_formula(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTff_and_formula" ):
                listener.exitTff_and_formula(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTff_and_formula" ):
                return visitor.visitTff_and_formula(self)
            else:
                return visitor.visitChildren(self)



    def tff_and_formula(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = TptpParser.Tff_and_formulaContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 110
        self.enterRecursionRule(localctx, 110, self.RULE_tff_and_formula, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 796
            self.tff_unitary_formula()
            self.state = 797
            self.match(TptpParser.And)
            self.state = 798
            self.tff_unitary_formula()
            self._ctx.stop = self._input.LT(-1)
            self.state = 805
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,39,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = TptpParser.Tff_and_formulaContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_tff_and_formula)
                    self.state = 800
                    if not self.precpred(self._ctx, 1):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                    self.state = 801
                    self.match(TptpParser.And)
                    self.state = 802
                    self.tff_unitary_formula() 
                self.state = 807
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,39,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class Tff_unitary_formulaContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tff_quantified_formula(self):
            return self.getTypedRuleContext(TptpParser.Tff_quantified_formulaContext,0)


        def tff_unary_formula(self):
            return self.getTypedRuleContext(TptpParser.Tff_unary_formulaContext,0)


        def tff_atomic_formula(self):
            return self.getTypedRuleContext(TptpParser.Tff_atomic_formulaContext,0)


        def tff_conditional(self):
            return self.getTypedRuleContext(TptpParser.Tff_conditionalContext,0)


        def tff_let(self):
            return self.getTypedRuleContext(TptpParser.Tff_letContext,0)


        def tff_logic_formula(self):
            return self.getTypedRuleContext(TptpParser.Tff_logic_formulaContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_tff_unitary_formula

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTff_unitary_formula" ):
                listener.enterTff_unitary_formula(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTff_unitary_formula" ):
                listener.exitTff_unitary_formula(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTff_unitary_formula" ):
                return visitor.visitTff_unitary_formula(self)
            else:
                return visitor.visitChildren(self)




    def tff_unitary_formula(self):

        localctx = TptpParser.Tff_unitary_formulaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 112, self.RULE_tff_unitary_formula)
        try:
            self.state = 817
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,40,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 808
                self.tff_quantified_formula()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 809
                self.tff_unary_formula()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 810
                self.tff_atomic_formula()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 811
                self.tff_conditional()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 812
                self.tff_let()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 813
                self.match(TptpParser.T__9)
                self.state = 814
                self.tff_logic_formula()
                self.state = 815
                self.match(TptpParser.T__10)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Tff_quantified_formulaContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fof_quantifier(self):
            return self.getTypedRuleContext(TptpParser.Fof_quantifierContext,0)


        def tff_variable_list(self):
            return self.getTypedRuleContext(TptpParser.Tff_variable_listContext,0)


        def tff_unitary_formula(self):
            return self.getTypedRuleContext(TptpParser.Tff_unitary_formulaContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_tff_quantified_formula

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTff_quantified_formula" ):
                listener.enterTff_quantified_formula(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTff_quantified_formula" ):
                listener.exitTff_quantified_formula(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTff_quantified_formula" ):
                return visitor.visitTff_quantified_formula(self)
            else:
                return visitor.visitChildren(self)




    def tff_quantified_formula(self):

        localctx = TptpParser.Tff_quantified_formulaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 114, self.RULE_tff_quantified_formula)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 819
            self.fof_quantifier()
            self.state = 820
            self.match(TptpParser.T__11)
            self.state = 821
            self.tff_variable_list()
            self.state = 822
            self.match(TptpParser.T__12)
            self.state = 823
            self.match(TptpParser.T__13)
            self.state = 824
            self.tff_unitary_formula()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Tff_variable_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tff_variable(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TptpParser.Tff_variableContext)
            else:
                return self.getTypedRuleContext(TptpParser.Tff_variableContext,i)


        def getRuleIndex(self):
            return TptpParser.RULE_tff_variable_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTff_variable_list" ):
                listener.enterTff_variable_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTff_variable_list" ):
                listener.exitTff_variable_list(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTff_variable_list" ):
                return visitor.visitTff_variable_list(self)
            else:
                return visitor.visitChildren(self)




    def tff_variable_list(self):

        localctx = TptpParser.Tff_variable_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 116, self.RULE_tff_variable_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 826
            self.tff_variable()
            self.state = 831
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==TptpParser.T__1:
                self.state = 827
                self.match(TptpParser.T__1)
                self.state = 828
                self.tff_variable()
                self.state = 833
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Tff_variableContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tff_typed_variable(self):
            return self.getTypedRuleContext(TptpParser.Tff_typed_variableContext,0)


        def variable(self):
            return self.getTypedRuleContext(TptpParser.VariableContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_tff_variable

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTff_variable" ):
                listener.enterTff_variable(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTff_variable" ):
                listener.exitTff_variable(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTff_variable" ):
                return visitor.visitTff_variable(self)
            else:
                return visitor.visitChildren(self)




    def tff_variable(self):

        localctx = TptpParser.Tff_variableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 118, self.RULE_tff_variable)
        try:
            self.state = 836
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,42,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 834
                self.tff_typed_variable()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 835
                self.variable()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Tff_typed_variableContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variable(self):
            return self.getTypedRuleContext(TptpParser.VariableContext,0)


        def tff_atomic_type(self):
            return self.getTypedRuleContext(TptpParser.Tff_atomic_typeContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_tff_typed_variable

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTff_typed_variable" ):
                listener.enterTff_typed_variable(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTff_typed_variable" ):
                listener.exitTff_typed_variable(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTff_typed_variable" ):
                return visitor.visitTff_typed_variable(self)
            else:
                return visitor.visitChildren(self)




    def tff_typed_variable(self):

        localctx = TptpParser.Tff_typed_variableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 120, self.RULE_tff_typed_variable)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 838
            self.variable()
            self.state = 839
            self.match(TptpParser.T__13)
            self.state = 840
            self.tff_atomic_type()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Tff_unary_formulaContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def unary_connective(self):
            return self.getTypedRuleContext(TptpParser.Unary_connectiveContext,0)


        def tff_unitary_formula(self):
            return self.getTypedRuleContext(TptpParser.Tff_unitary_formulaContext,0)


        def fof_infix_unary(self):
            return self.getTypedRuleContext(TptpParser.Fof_infix_unaryContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_tff_unary_formula

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTff_unary_formula" ):
                listener.enterTff_unary_formula(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTff_unary_formula" ):
                listener.exitTff_unary_formula(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTff_unary_formula" ):
                return visitor.visitTff_unary_formula(self)
            else:
                return visitor.visitChildren(self)




    def tff_unary_formula(self):

        localctx = TptpParser.Tff_unary_formulaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 122, self.RULE_tff_unary_formula)
        try:
            self.state = 846
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TptpParser.Not]:
                self.enterOuterAlt(localctx, 1)
                self.state = 842
                self.unary_connective()
                self.state = 843
                self.tff_unitary_formula()
                pass
            elif token in [TptpParser.T__17, TptpParser.T__18, TptpParser.T__23, TptpParser.T__24, TptpParser.T__25, TptpParser.Real, TptpParser.Rational, TptpParser.Integer, TptpParser.Dollar_word, TptpParser.Dollar_dollar_word, TptpParser.Upper_word, TptpParser.Lower_word, TptpParser.Single_quoted, TptpParser.Distinct_object]:
                self.enterOuterAlt(localctx, 2)
                self.state = 845
                self.fof_infix_unary()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Tff_atomic_formulaContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fof_atomic_formula(self):
            return self.getTypedRuleContext(TptpParser.Fof_atomic_formulaContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_tff_atomic_formula

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTff_atomic_formula" ):
                listener.enterTff_atomic_formula(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTff_atomic_formula" ):
                listener.exitTff_atomic_formula(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTff_atomic_formula" ):
                return visitor.visitTff_atomic_formula(self)
            else:
                return visitor.visitChildren(self)




    def tff_atomic_formula(self):

        localctx = TptpParser.Tff_atomic_formulaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 124, self.RULE_tff_atomic_formula)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 848
            self.fof_atomic_formula()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Tff_conditionalContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tff_logic_formula(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TptpParser.Tff_logic_formulaContext)
            else:
                return self.getTypedRuleContext(TptpParser.Tff_logic_formulaContext,i)


        def getRuleIndex(self):
            return TptpParser.RULE_tff_conditional

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTff_conditional" ):
                listener.enterTff_conditional(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTff_conditional" ):
                listener.exitTff_conditional(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTff_conditional" ):
                return visitor.visitTff_conditional(self)
            else:
                return visitor.visitChildren(self)




    def tff_conditional(self):

        localctx = TptpParser.Tff_conditionalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 126, self.RULE_tff_conditional)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 850
            self.match(TptpParser.T__20)
            self.state = 851
            self.tff_logic_formula()
            self.state = 852
            self.match(TptpParser.T__1)
            self.state = 853
            self.tff_logic_formula()
            self.state = 854
            self.match(TptpParser.T__1)
            self.state = 855
            self.tff_logic_formula()
            self.state = 856
            self.match(TptpParser.T__10)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Tff_letContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tff_let_term_defns(self):
            return self.getTypedRuleContext(TptpParser.Tff_let_term_defnsContext,0)


        def tff_formula(self):
            return self.getTypedRuleContext(TptpParser.Tff_formulaContext,0)


        def tff_let_formula_defns(self):
            return self.getTypedRuleContext(TptpParser.Tff_let_formula_defnsContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_tff_let

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTff_let" ):
                listener.enterTff_let(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTff_let" ):
                listener.exitTff_let(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTff_let" ):
                return visitor.visitTff_let(self)
            else:
                return visitor.visitChildren(self)




    def tff_let(self):

        localctx = TptpParser.Tff_letContext(self, self._ctx, self.state)
        self.enterRule(localctx, 128, self.RULE_tff_let)
        try:
            self.state = 870
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TptpParser.T__21]:
                self.enterOuterAlt(localctx, 1)
                self.state = 858
                self.match(TptpParser.T__21)
                self.state = 859
                self.tff_let_term_defns()
                self.state = 860
                self.match(TptpParser.T__1)
                self.state = 861
                self.tff_formula()
                self.state = 862
                self.match(TptpParser.T__10)
                pass
            elif token in [TptpParser.T__22]:
                self.enterOuterAlt(localctx, 2)
                self.state = 864
                self.match(TptpParser.T__22)
                self.state = 865
                self.tff_let_formula_defns()
                self.state = 866
                self.match(TptpParser.T__1)
                self.state = 867
                self.tff_formula()
                self.state = 868
                self.match(TptpParser.T__10)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Tff_let_term_defnsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tff_let_term_defn(self):
            return self.getTypedRuleContext(TptpParser.Tff_let_term_defnContext,0)


        def tff_let_term_list(self):
            return self.getTypedRuleContext(TptpParser.Tff_let_term_listContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_tff_let_term_defns

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTff_let_term_defns" ):
                listener.enterTff_let_term_defns(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTff_let_term_defns" ):
                listener.exitTff_let_term_defns(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTff_let_term_defns" ):
                return visitor.visitTff_let_term_defns(self)
            else:
                return visitor.visitChildren(self)




    def tff_let_term_defns(self):

        localctx = TptpParser.Tff_let_term_defnsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 130, self.RULE_tff_let_term_defns)
        try:
            self.state = 877
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TptpParser.T__9, TptpParser.Forall, TptpParser.Lower_word, TptpParser.Single_quoted]:
                self.enterOuterAlt(localctx, 1)
                self.state = 872
                self.tff_let_term_defn()
                pass
            elif token in [TptpParser.T__11]:
                self.enterOuterAlt(localctx, 2)
                self.state = 873
                self.match(TptpParser.T__11)
                self.state = 874
                self.tff_let_term_list()
                self.state = 875
                self.match(TptpParser.T__12)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Tff_let_term_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tff_let_term_defn(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TptpParser.Tff_let_term_defnContext)
            else:
                return self.getTypedRuleContext(TptpParser.Tff_let_term_defnContext,i)


        def getRuleIndex(self):
            return TptpParser.RULE_tff_let_term_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTff_let_term_list" ):
                listener.enterTff_let_term_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTff_let_term_list" ):
                listener.exitTff_let_term_list(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTff_let_term_list" ):
                return visitor.visitTff_let_term_list(self)
            else:
                return visitor.visitChildren(self)




    def tff_let_term_list(self):

        localctx = TptpParser.Tff_let_term_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 132, self.RULE_tff_let_term_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 879
            self.tff_let_term_defn()
            self.state = 884
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==TptpParser.T__1:
                self.state = 880
                self.match(TptpParser.T__1)
                self.state = 881
                self.tff_let_term_defn()
                self.state = 886
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Tff_let_term_defnContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Forall(self):
            return self.getToken(TptpParser.Forall, 0)

        def tff_variable_list(self):
            return self.getTypedRuleContext(TptpParser.Tff_variable_listContext,0)


        def tff_let_term_defn(self):
            return self.getTypedRuleContext(TptpParser.Tff_let_term_defnContext,0)


        def tff_let_term_binding(self):
            return self.getTypedRuleContext(TptpParser.Tff_let_term_bindingContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_tff_let_term_defn

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTff_let_term_defn" ):
                listener.enterTff_let_term_defn(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTff_let_term_defn" ):
                listener.exitTff_let_term_defn(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTff_let_term_defn" ):
                return visitor.visitTff_let_term_defn(self)
            else:
                return visitor.visitChildren(self)




    def tff_let_term_defn(self):

        localctx = TptpParser.Tff_let_term_defnContext(self, self._ctx, self.state)
        self.enterRule(localctx, 134, self.RULE_tff_let_term_defn)
        try:
            self.state = 895
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TptpParser.Forall]:
                self.enterOuterAlt(localctx, 1)
                self.state = 887
                self.match(TptpParser.Forall)
                self.state = 888
                self.match(TptpParser.T__11)
                self.state = 889
                self.tff_variable_list()
                self.state = 890
                self.match(TptpParser.T__12)
                self.state = 891
                self.match(TptpParser.T__13)
                self.state = 892
                self.tff_let_term_defn()
                pass
            elif token in [TptpParser.T__9, TptpParser.Lower_word, TptpParser.Single_quoted]:
                self.enterOuterAlt(localctx, 2)
                self.state = 894
                self.tff_let_term_binding()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Tff_let_term_bindingContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fof_plain_term(self):
            return self.getTypedRuleContext(TptpParser.Fof_plain_termContext,0)


        def Infix_equality(self):
            return self.getToken(TptpParser.Infix_equality, 0)

        def fof_term(self):
            return self.getTypedRuleContext(TptpParser.Fof_termContext,0)


        def tff_let_term_binding(self):
            return self.getTypedRuleContext(TptpParser.Tff_let_term_bindingContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_tff_let_term_binding

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTff_let_term_binding" ):
                listener.enterTff_let_term_binding(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTff_let_term_binding" ):
                listener.exitTff_let_term_binding(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTff_let_term_binding" ):
                return visitor.visitTff_let_term_binding(self)
            else:
                return visitor.visitChildren(self)




    def tff_let_term_binding(self):

        localctx = TptpParser.Tff_let_term_bindingContext(self, self._ctx, self.state)
        self.enterRule(localctx, 136, self.RULE_tff_let_term_binding)
        try:
            self.state = 905
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TptpParser.Lower_word, TptpParser.Single_quoted]:
                self.enterOuterAlt(localctx, 1)
                self.state = 897
                self.fof_plain_term()
                self.state = 898
                self.match(TptpParser.Infix_equality)
                self.state = 899
                self.fof_term()
                pass
            elif token in [TptpParser.T__9]:
                self.enterOuterAlt(localctx, 2)
                self.state = 901
                self.match(TptpParser.T__9)
                self.state = 902
                self.tff_let_term_binding()
                self.state = 903
                self.match(TptpParser.T__10)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Tff_let_formula_defnsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tff_let_formula_defn(self):
            return self.getTypedRuleContext(TptpParser.Tff_let_formula_defnContext,0)


        def tff_let_formula_list(self):
            return self.getTypedRuleContext(TptpParser.Tff_let_formula_listContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_tff_let_formula_defns

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTff_let_formula_defns" ):
                listener.enterTff_let_formula_defns(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTff_let_formula_defns" ):
                listener.exitTff_let_formula_defns(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTff_let_formula_defns" ):
                return visitor.visitTff_let_formula_defns(self)
            else:
                return visitor.visitChildren(self)




    def tff_let_formula_defns(self):

        localctx = TptpParser.Tff_let_formula_defnsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 138, self.RULE_tff_let_formula_defns)
        try:
            self.state = 912
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TptpParser.T__9, TptpParser.Forall, TptpParser.Lower_word, TptpParser.Single_quoted]:
                self.enterOuterAlt(localctx, 1)
                self.state = 907
                self.tff_let_formula_defn()
                pass
            elif token in [TptpParser.T__11]:
                self.enterOuterAlt(localctx, 2)
                self.state = 908
                self.match(TptpParser.T__11)
                self.state = 909
                self.tff_let_formula_list()
                self.state = 910
                self.match(TptpParser.T__12)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Tff_let_formula_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tff_let_formula_defn(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TptpParser.Tff_let_formula_defnContext)
            else:
                return self.getTypedRuleContext(TptpParser.Tff_let_formula_defnContext,i)


        def getRuleIndex(self):
            return TptpParser.RULE_tff_let_formula_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTff_let_formula_list" ):
                listener.enterTff_let_formula_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTff_let_formula_list" ):
                listener.exitTff_let_formula_list(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTff_let_formula_list" ):
                return visitor.visitTff_let_formula_list(self)
            else:
                return visitor.visitChildren(self)




    def tff_let_formula_list(self):

        localctx = TptpParser.Tff_let_formula_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 140, self.RULE_tff_let_formula_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 914
            self.tff_let_formula_defn()
            self.state = 919
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==TptpParser.T__1:
                self.state = 915
                self.match(TptpParser.T__1)
                self.state = 916
                self.tff_let_formula_defn()
                self.state = 921
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Tff_let_formula_defnContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Forall(self):
            return self.getToken(TptpParser.Forall, 0)

        def tff_variable_list(self):
            return self.getTypedRuleContext(TptpParser.Tff_variable_listContext,0)


        def tff_let_formula_defn(self):
            return self.getTypedRuleContext(TptpParser.Tff_let_formula_defnContext,0)


        def tff_let_formula_binding(self):
            return self.getTypedRuleContext(TptpParser.Tff_let_formula_bindingContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_tff_let_formula_defn

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTff_let_formula_defn" ):
                listener.enterTff_let_formula_defn(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTff_let_formula_defn" ):
                listener.exitTff_let_formula_defn(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTff_let_formula_defn" ):
                return visitor.visitTff_let_formula_defn(self)
            else:
                return visitor.visitChildren(self)




    def tff_let_formula_defn(self):

        localctx = TptpParser.Tff_let_formula_defnContext(self, self._ctx, self.state)
        self.enterRule(localctx, 142, self.RULE_tff_let_formula_defn)
        try:
            self.state = 930
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TptpParser.Forall]:
                self.enterOuterAlt(localctx, 1)
                self.state = 922
                self.match(TptpParser.Forall)
                self.state = 923
                self.match(TptpParser.T__11)
                self.state = 924
                self.tff_variable_list()
                self.state = 925
                self.match(TptpParser.T__12)
                self.state = 926
                self.match(TptpParser.T__13)
                self.state = 927
                self.tff_let_formula_defn()
                pass
            elif token in [TptpParser.T__9, TptpParser.Lower_word, TptpParser.Single_quoted]:
                self.enterOuterAlt(localctx, 2)
                self.state = 929
                self.tff_let_formula_binding()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Tff_let_formula_bindingContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fof_plain_atomic_formula(self):
            return self.getTypedRuleContext(TptpParser.Fof_plain_atomic_formulaContext,0)


        def Iff(self):
            return self.getToken(TptpParser.Iff, 0)

        def tff_unitary_formula(self):
            return self.getTypedRuleContext(TptpParser.Tff_unitary_formulaContext,0)


        def tff_let_formula_binding(self):
            return self.getTypedRuleContext(TptpParser.Tff_let_formula_bindingContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_tff_let_formula_binding

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTff_let_formula_binding" ):
                listener.enterTff_let_formula_binding(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTff_let_formula_binding" ):
                listener.exitTff_let_formula_binding(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTff_let_formula_binding" ):
                return visitor.visitTff_let_formula_binding(self)
            else:
                return visitor.visitChildren(self)




    def tff_let_formula_binding(self):

        localctx = TptpParser.Tff_let_formula_bindingContext(self, self._ctx, self.state)
        self.enterRule(localctx, 144, self.RULE_tff_let_formula_binding)
        try:
            self.state = 940
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TptpParser.Lower_word, TptpParser.Single_quoted]:
                self.enterOuterAlt(localctx, 1)
                self.state = 932
                self.fof_plain_atomic_formula()
                self.state = 933
                self.match(TptpParser.Iff)
                self.state = 934
                self.tff_unitary_formula()
                pass
            elif token in [TptpParser.T__9]:
                self.enterOuterAlt(localctx, 2)
                self.state = 936
                self.match(TptpParser.T__9)
                self.state = 937
                self.tff_let_formula_binding()
                self.state = 938
                self.match(TptpParser.T__10)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Tff_sequentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tff_formula_tuple(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TptpParser.Tff_formula_tupleContext)
            else:
                return self.getTypedRuleContext(TptpParser.Tff_formula_tupleContext,i)


        def Gentzen_arrow(self):
            return self.getToken(TptpParser.Gentzen_arrow, 0)

        def tff_sequent(self):
            return self.getTypedRuleContext(TptpParser.Tff_sequentContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_tff_sequent

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTff_sequent" ):
                listener.enterTff_sequent(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTff_sequent" ):
                listener.exitTff_sequent(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTff_sequent" ):
                return visitor.visitTff_sequent(self)
            else:
                return visitor.visitChildren(self)




    def tff_sequent(self):

        localctx = TptpParser.Tff_sequentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 146, self.RULE_tff_sequent)
        try:
            self.state = 950
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TptpParser.T__11, TptpParser.T__16]:
                self.enterOuterAlt(localctx, 1)
                self.state = 942
                self.tff_formula_tuple()
                self.state = 943
                self.match(TptpParser.Gentzen_arrow)
                self.state = 944
                self.tff_formula_tuple()
                pass
            elif token in [TptpParser.T__9]:
                self.enterOuterAlt(localctx, 2)
                self.state = 946
                self.match(TptpParser.T__9)
                self.state = 947
                self.tff_sequent()
                self.state = 948
                self.match(TptpParser.T__10)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Tff_formula_tupleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tff_formula_tuple_list(self):
            return self.getTypedRuleContext(TptpParser.Tff_formula_tuple_listContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_tff_formula_tuple

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTff_formula_tuple" ):
                listener.enterTff_formula_tuple(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTff_formula_tuple" ):
                listener.exitTff_formula_tuple(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTff_formula_tuple" ):
                return visitor.visitTff_formula_tuple(self)
            else:
                return visitor.visitChildren(self)




    def tff_formula_tuple(self):

        localctx = TptpParser.Tff_formula_tupleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 148, self.RULE_tff_formula_tuple)
        try:
            self.state = 957
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TptpParser.T__16]:
                self.enterOuterAlt(localctx, 1)
                self.state = 952
                self.match(TptpParser.T__16)
                pass
            elif token in [TptpParser.T__11]:
                self.enterOuterAlt(localctx, 2)
                self.state = 953
                self.match(TptpParser.T__11)
                self.state = 954
                self.tff_formula_tuple_list()
                self.state = 955
                self.match(TptpParser.T__12)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Tff_formula_tuple_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tff_logic_formula(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TptpParser.Tff_logic_formulaContext)
            else:
                return self.getTypedRuleContext(TptpParser.Tff_logic_formulaContext,i)


        def getRuleIndex(self):
            return TptpParser.RULE_tff_formula_tuple_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTff_formula_tuple_list" ):
                listener.enterTff_formula_tuple_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTff_formula_tuple_list" ):
                listener.exitTff_formula_tuple_list(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTff_formula_tuple_list" ):
                return visitor.visitTff_formula_tuple_list(self)
            else:
                return visitor.visitChildren(self)




    def tff_formula_tuple_list(self):

        localctx = TptpParser.Tff_formula_tuple_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 150, self.RULE_tff_formula_tuple_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 959
            self.tff_logic_formula()
            self.state = 964
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==TptpParser.T__1:
                self.state = 960
                self.match(TptpParser.T__1)
                self.state = 961
                self.tff_logic_formula()
                self.state = 966
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Tff_typed_atomContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def untyped_atom(self):
            return self.getTypedRuleContext(TptpParser.Untyped_atomContext,0)


        def tff_top_level_type(self):
            return self.getTypedRuleContext(TptpParser.Tff_top_level_typeContext,0)


        def tff_typed_atom(self):
            return self.getTypedRuleContext(TptpParser.Tff_typed_atomContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_tff_typed_atom

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTff_typed_atom" ):
                listener.enterTff_typed_atom(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTff_typed_atom" ):
                listener.exitTff_typed_atom(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTff_typed_atom" ):
                return visitor.visitTff_typed_atom(self)
            else:
                return visitor.visitChildren(self)




    def tff_typed_atom(self):

        localctx = TptpParser.Tff_typed_atomContext(self, self._ctx, self.state)
        self.enterRule(localctx, 152, self.RULE_tff_typed_atom)
        try:
            self.state = 975
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TptpParser.Dollar_dollar_word, TptpParser.Lower_word, TptpParser.Single_quoted]:
                self.enterOuterAlt(localctx, 1)
                self.state = 967
                self.untyped_atom()
                self.state = 968
                self.match(TptpParser.T__13)
                self.state = 969
                self.tff_top_level_type()
                pass
            elif token in [TptpParser.T__9]:
                self.enterOuterAlt(localctx, 2)
                self.state = 971
                self.match(TptpParser.T__9)
                self.state = 972
                self.tff_typed_atom()
                self.state = 973
                self.match(TptpParser.T__10)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Tff_subtypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def untyped_atom(self):
            return self.getTypedRuleContext(TptpParser.Untyped_atomContext,0)


        def Subtype_sign(self):
            return self.getToken(TptpParser.Subtype_sign, 0)

        def atom(self):
            return self.getTypedRuleContext(TptpParser.AtomContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_tff_subtype

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTff_subtype" ):
                listener.enterTff_subtype(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTff_subtype" ):
                listener.exitTff_subtype(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTff_subtype" ):
                return visitor.visitTff_subtype(self)
            else:
                return visitor.visitChildren(self)




    def tff_subtype(self):

        localctx = TptpParser.Tff_subtypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 154, self.RULE_tff_subtype)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 977
            self.untyped_atom()
            self.state = 978
            self.match(TptpParser.Subtype_sign)
            self.state = 979
            self.atom()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Tff_top_level_typeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tff_atomic_type(self):
            return self.getTypedRuleContext(TptpParser.Tff_atomic_typeContext,0)


        def tff_mapping_type(self):
            return self.getTypedRuleContext(TptpParser.Tff_mapping_typeContext,0)


        def tf1_quantified_type(self):
            return self.getTypedRuleContext(TptpParser.Tf1_quantified_typeContext,0)


        def tff_top_level_type(self):
            return self.getTypedRuleContext(TptpParser.Tff_top_level_typeContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_tff_top_level_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTff_top_level_type" ):
                listener.enterTff_top_level_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTff_top_level_type" ):
                listener.exitTff_top_level_type(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTff_top_level_type" ):
                return visitor.visitTff_top_level_type(self)
            else:
                return visitor.visitChildren(self)




    def tff_top_level_type(self):

        localctx = TptpParser.Tff_top_level_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 156, self.RULE_tff_top_level_type)
        try:
            self.state = 988
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,57,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 981
                self.tff_atomic_type()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 982
                self.tff_mapping_type()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 983
                self.tf1_quantified_type()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 984
                self.match(TptpParser.T__9)
                self.state = 985
                self.tff_top_level_type()
                self.state = 986
                self.match(TptpParser.T__10)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Tf1_quantified_typeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TyForall(self):
            return self.getToken(TptpParser.TyForall, 0)

        def tff_variable_list(self):
            return self.getTypedRuleContext(TptpParser.Tff_variable_listContext,0)


        def tff_monotype(self):
            return self.getTypedRuleContext(TptpParser.Tff_monotypeContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_tf1_quantified_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTf1_quantified_type" ):
                listener.enterTf1_quantified_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTf1_quantified_type" ):
                listener.exitTf1_quantified_type(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTf1_quantified_type" ):
                return visitor.visitTf1_quantified_type(self)
            else:
                return visitor.visitChildren(self)




    def tf1_quantified_type(self):

        localctx = TptpParser.Tf1_quantified_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 158, self.RULE_tf1_quantified_type)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 990
            self.match(TptpParser.TyForall)
            self.state = 991
            self.match(TptpParser.T__11)
            self.state = 992
            self.tff_variable_list()
            self.state = 993
            self.match(TptpParser.T__12)
            self.state = 994
            self.match(TptpParser.T__13)
            self.state = 995
            self.tff_monotype()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Tff_monotypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tff_atomic_type(self):
            return self.getTypedRuleContext(TptpParser.Tff_atomic_typeContext,0)


        def tff_mapping_type(self):
            return self.getTypedRuleContext(TptpParser.Tff_mapping_typeContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_tff_monotype

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTff_monotype" ):
                listener.enterTff_monotype(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTff_monotype" ):
                listener.exitTff_monotype(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTff_monotype" ):
                return visitor.visitTff_monotype(self)
            else:
                return visitor.visitChildren(self)




    def tff_monotype(self):

        localctx = TptpParser.Tff_monotypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 160, self.RULE_tff_monotype)
        try:
            self.state = 1002
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TptpParser.Dollar_word, TptpParser.Upper_word, TptpParser.Lower_word, TptpParser.Single_quoted]:
                self.enterOuterAlt(localctx, 1)
                self.state = 997
                self.tff_atomic_type()
                pass
            elif token in [TptpParser.T__9]:
                self.enterOuterAlt(localctx, 2)
                self.state = 998
                self.match(TptpParser.T__9)
                self.state = 999
                self.tff_mapping_type()
                self.state = 1000
                self.match(TptpParser.T__10)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Tff_unitary_typeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tff_atomic_type(self):
            return self.getTypedRuleContext(TptpParser.Tff_atomic_typeContext,0)


        def tff_xprod_type(self):
            return self.getTypedRuleContext(TptpParser.Tff_xprod_typeContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_tff_unitary_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTff_unitary_type" ):
                listener.enterTff_unitary_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTff_unitary_type" ):
                listener.exitTff_unitary_type(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTff_unitary_type" ):
                return visitor.visitTff_unitary_type(self)
            else:
                return visitor.visitChildren(self)




    def tff_unitary_type(self):

        localctx = TptpParser.Tff_unitary_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 162, self.RULE_tff_unitary_type)
        try:
            self.state = 1009
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TptpParser.Dollar_word, TptpParser.Upper_word, TptpParser.Lower_word, TptpParser.Single_quoted]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1004
                self.tff_atomic_type()
                pass
            elif token in [TptpParser.T__9]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1005
                self.match(TptpParser.T__9)
                self.state = 1006
                self.tff_xprod_type(0)
                self.state = 1007
                self.match(TptpParser.T__10)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Tff_atomic_typeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def type_constant(self):
            return self.getTypedRuleContext(TptpParser.Type_constantContext,0)


        def defined_type(self):
            return self.getTypedRuleContext(TptpParser.Defined_typeContext,0)


        def type_functor(self):
            return self.getTypedRuleContext(TptpParser.Type_functorContext,0)


        def tff_type_arguments(self):
            return self.getTypedRuleContext(TptpParser.Tff_type_argumentsContext,0)


        def variable(self):
            return self.getTypedRuleContext(TptpParser.VariableContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_tff_atomic_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTff_atomic_type" ):
                listener.enterTff_atomic_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTff_atomic_type" ):
                listener.exitTff_atomic_type(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTff_atomic_type" ):
                return visitor.visitTff_atomic_type(self)
            else:
                return visitor.visitChildren(self)




    def tff_atomic_type(self):

        localctx = TptpParser.Tff_atomic_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 164, self.RULE_tff_atomic_type)
        try:
            self.state = 1019
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,60,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1011
                self.type_constant()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1012
                self.defined_type()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1013
                self.type_functor()
                self.state = 1014
                self.match(TptpParser.T__9)
                self.state = 1015
                self.tff_type_arguments()
                self.state = 1016
                self.match(TptpParser.T__10)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1018
                self.variable()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Tff_type_argumentsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tff_atomic_type(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TptpParser.Tff_atomic_typeContext)
            else:
                return self.getTypedRuleContext(TptpParser.Tff_atomic_typeContext,i)


        def getRuleIndex(self):
            return TptpParser.RULE_tff_type_arguments

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTff_type_arguments" ):
                listener.enterTff_type_arguments(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTff_type_arguments" ):
                listener.exitTff_type_arguments(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTff_type_arguments" ):
                return visitor.visitTff_type_arguments(self)
            else:
                return visitor.visitChildren(self)




    def tff_type_arguments(self):

        localctx = TptpParser.Tff_type_argumentsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 166, self.RULE_tff_type_arguments)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1021
            self.tff_atomic_type()
            self.state = 1026
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==TptpParser.T__1:
                self.state = 1022
                self.match(TptpParser.T__1)
                self.state = 1023
                self.tff_atomic_type()
                self.state = 1028
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Tff_mapping_typeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tff_unitary_type(self):
            return self.getTypedRuleContext(TptpParser.Tff_unitary_typeContext,0)


        def Arrow(self):
            return self.getToken(TptpParser.Arrow, 0)

        def tff_atomic_type(self):
            return self.getTypedRuleContext(TptpParser.Tff_atomic_typeContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_tff_mapping_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTff_mapping_type" ):
                listener.enterTff_mapping_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTff_mapping_type" ):
                listener.exitTff_mapping_type(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTff_mapping_type" ):
                return visitor.visitTff_mapping_type(self)
            else:
                return visitor.visitChildren(self)




    def tff_mapping_type(self):

        localctx = TptpParser.Tff_mapping_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 168, self.RULE_tff_mapping_type)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1029
            self.tff_unitary_type()
            self.state = 1030
            self.match(TptpParser.Arrow)
            self.state = 1031
            self.tff_atomic_type()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Tff_xprod_typeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tff_unitary_type(self):
            return self.getTypedRuleContext(TptpParser.Tff_unitary_typeContext,0)


        def Star(self):
            return self.getToken(TptpParser.Star, 0)

        def tff_atomic_type(self):
            return self.getTypedRuleContext(TptpParser.Tff_atomic_typeContext,0)


        def tff_xprod_type(self):
            return self.getTypedRuleContext(TptpParser.Tff_xprod_typeContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_tff_xprod_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTff_xprod_type" ):
                listener.enterTff_xprod_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTff_xprod_type" ):
                listener.exitTff_xprod_type(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTff_xprod_type" ):
                return visitor.visitTff_xprod_type(self)
            else:
                return visitor.visitChildren(self)



    def tff_xprod_type(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = TptpParser.Tff_xprod_typeContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 170
        self.enterRecursionRule(localctx, 170, self.RULE_tff_xprod_type, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1034
            self.tff_unitary_type()
            self.state = 1035
            self.match(TptpParser.Star)
            self.state = 1036
            self.tff_atomic_type()
            self._ctx.stop = self._input.LT(-1)
            self.state = 1043
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,62,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = TptpParser.Tff_xprod_typeContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_tff_xprod_type)
                    self.state = 1038
                    if not self.precpred(self._ctx, 1):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                    self.state = 1039
                    self.match(TptpParser.Star)
                    self.state = 1040
                    self.tff_atomic_type() 
                self.state = 1045
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,62,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class Tcf_formulaContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tcf_logic_formula(self):
            return self.getTypedRuleContext(TptpParser.Tcf_logic_formulaContext,0)


        def tff_typed_atom(self):
            return self.getTypedRuleContext(TptpParser.Tff_typed_atomContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_tcf_formula

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTcf_formula" ):
                listener.enterTcf_formula(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTcf_formula" ):
                listener.exitTcf_formula(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTcf_formula" ):
                return visitor.visitTcf_formula(self)
            else:
                return visitor.visitChildren(self)




    def tcf_formula(self):

        localctx = TptpParser.Tcf_formulaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 172, self.RULE_tcf_formula)
        try:
            self.state = 1048
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,63,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1046
                self.tcf_logic_formula()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1047
                self.tff_typed_atom()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Tcf_logic_formulaContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tcf_quantified_formula(self):
            return self.getTypedRuleContext(TptpParser.Tcf_quantified_formulaContext,0)


        def cnf_formula(self):
            return self.getTypedRuleContext(TptpParser.Cnf_formulaContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_tcf_logic_formula

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTcf_logic_formula" ):
                listener.enterTcf_logic_formula(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTcf_logic_formula" ):
                listener.exitTcf_logic_formula(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTcf_logic_formula" ):
                return visitor.visitTcf_logic_formula(self)
            else:
                return visitor.visitChildren(self)




    def tcf_logic_formula(self):

        localctx = TptpParser.Tcf_logic_formulaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 174, self.RULE_tcf_logic_formula)
        try:
            self.state = 1052
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TptpParser.Forall]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1050
                self.tcf_quantified_formula()
                pass
            elif token in [TptpParser.T__9, TptpParser.T__17, TptpParser.T__18, TptpParser.T__23, TptpParser.T__24, TptpParser.T__25, TptpParser.Not, TptpParser.Real, TptpParser.Rational, TptpParser.Integer, TptpParser.Dollar_word, TptpParser.Dollar_dollar_word, TptpParser.Upper_word, TptpParser.Lower_word, TptpParser.Single_quoted, TptpParser.Distinct_object]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1051
                self.cnf_formula()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Tcf_quantified_formulaContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Forall(self):
            return self.getToken(TptpParser.Forall, 0)

        def tff_variable_list(self):
            return self.getTypedRuleContext(TptpParser.Tff_variable_listContext,0)


        def cnf_formula(self):
            return self.getTypedRuleContext(TptpParser.Cnf_formulaContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_tcf_quantified_formula

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTcf_quantified_formula" ):
                listener.enterTcf_quantified_formula(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTcf_quantified_formula" ):
                listener.exitTcf_quantified_formula(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTcf_quantified_formula" ):
                return visitor.visitTcf_quantified_formula(self)
            else:
                return visitor.visitChildren(self)




    def tcf_quantified_formula(self):

        localctx = TptpParser.Tcf_quantified_formulaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 176, self.RULE_tcf_quantified_formula)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1054
            self.match(TptpParser.Forall)
            self.state = 1055
            self.match(TptpParser.T__11)
            self.state = 1056
            self.tff_variable_list()
            self.state = 1057
            self.match(TptpParser.T__12)
            self.state = 1058
            self.match(TptpParser.T__13)
            self.state = 1059
            self.cnf_formula()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Fof_formulaContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fof_logic_formula(self):
            return self.getTypedRuleContext(TptpParser.Fof_logic_formulaContext,0)


        def fof_sequent(self):
            return self.getTypedRuleContext(TptpParser.Fof_sequentContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_fof_formula

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFof_formula" ):
                listener.enterFof_formula(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFof_formula" ):
                listener.exitFof_formula(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFof_formula" ):
                return visitor.visitFof_formula(self)
            else:
                return visitor.visitChildren(self)




    def fof_formula(self):

        localctx = TptpParser.Fof_formulaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 178, self.RULE_fof_formula)
        try:
            self.state = 1063
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,65,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1061
                self.fof_logic_formula()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1062
                self.fof_sequent()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Fof_logic_formulaContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fof_binary_formula(self):
            return self.getTypedRuleContext(TptpParser.Fof_binary_formulaContext,0)


        def fof_unitary_formula(self):
            return self.getTypedRuleContext(TptpParser.Fof_unitary_formulaContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_fof_logic_formula

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFof_logic_formula" ):
                listener.enterFof_logic_formula(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFof_logic_formula" ):
                listener.exitFof_logic_formula(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFof_logic_formula" ):
                return visitor.visitFof_logic_formula(self)
            else:
                return visitor.visitChildren(self)




    def fof_logic_formula(self):

        localctx = TptpParser.Fof_logic_formulaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 180, self.RULE_fof_logic_formula)
        try:
            self.state = 1067
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,66,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1065
                self.fof_binary_formula()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1066
                self.fof_unitary_formula()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Fof_binary_formulaContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fof_binary_nonassoc(self):
            return self.getTypedRuleContext(TptpParser.Fof_binary_nonassocContext,0)


        def fof_binary_assoc(self):
            return self.getTypedRuleContext(TptpParser.Fof_binary_assocContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_fof_binary_formula

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFof_binary_formula" ):
                listener.enterFof_binary_formula(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFof_binary_formula" ):
                listener.exitFof_binary_formula(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFof_binary_formula" ):
                return visitor.visitFof_binary_formula(self)
            else:
                return visitor.visitChildren(self)




    def fof_binary_formula(self):

        localctx = TptpParser.Fof_binary_formulaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 182, self.RULE_fof_binary_formula)
        try:
            self.state = 1071
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,67,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1069
                self.fof_binary_nonassoc()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1070
                self.fof_binary_assoc()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Fof_binary_nonassocContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fof_unitary_formula(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TptpParser.Fof_unitary_formulaContext)
            else:
                return self.getTypedRuleContext(TptpParser.Fof_unitary_formulaContext,i)


        def binary_connective(self):
            return self.getTypedRuleContext(TptpParser.Binary_connectiveContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_fof_binary_nonassoc

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFof_binary_nonassoc" ):
                listener.enterFof_binary_nonassoc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFof_binary_nonassoc" ):
                listener.exitFof_binary_nonassoc(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFof_binary_nonassoc" ):
                return visitor.visitFof_binary_nonassoc(self)
            else:
                return visitor.visitChildren(self)




    def fof_binary_nonassoc(self):

        localctx = TptpParser.Fof_binary_nonassocContext(self, self._ctx, self.state)
        self.enterRule(localctx, 184, self.RULE_fof_binary_nonassoc)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1073
            self.fof_unitary_formula()
            self.state = 1074
            self.binary_connective()
            self.state = 1075
            self.fof_unitary_formula()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Fof_binary_assocContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fof_or_formula(self):
            return self.getTypedRuleContext(TptpParser.Fof_or_formulaContext,0)


        def fof_and_formula(self):
            return self.getTypedRuleContext(TptpParser.Fof_and_formulaContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_fof_binary_assoc

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFof_binary_assoc" ):
                listener.enterFof_binary_assoc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFof_binary_assoc" ):
                listener.exitFof_binary_assoc(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFof_binary_assoc" ):
                return visitor.visitFof_binary_assoc(self)
            else:
                return visitor.visitChildren(self)




    def fof_binary_assoc(self):

        localctx = TptpParser.Fof_binary_assocContext(self, self._ctx, self.state)
        self.enterRule(localctx, 186, self.RULE_fof_binary_assoc)
        try:
            self.state = 1079
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,68,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1077
                self.fof_or_formula(0)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1078
                self.fof_and_formula(0)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Fof_or_formulaContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fof_unitary_formula(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TptpParser.Fof_unitary_formulaContext)
            else:
                return self.getTypedRuleContext(TptpParser.Fof_unitary_formulaContext,i)


        def Or(self):
            return self.getToken(TptpParser.Or, 0)

        def fof_or_formula(self):
            return self.getTypedRuleContext(TptpParser.Fof_or_formulaContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_fof_or_formula

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFof_or_formula" ):
                listener.enterFof_or_formula(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFof_or_formula" ):
                listener.exitFof_or_formula(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFof_or_formula" ):
                return visitor.visitFof_or_formula(self)
            else:
                return visitor.visitChildren(self)



    def fof_or_formula(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = TptpParser.Fof_or_formulaContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 188
        self.enterRecursionRule(localctx, 188, self.RULE_fof_or_formula, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1082
            self.fof_unitary_formula()
            self.state = 1083
            self.match(TptpParser.Or)
            self.state = 1084
            self.fof_unitary_formula()
            self._ctx.stop = self._input.LT(-1)
            self.state = 1091
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,69,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = TptpParser.Fof_or_formulaContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_fof_or_formula)
                    self.state = 1086
                    if not self.precpred(self._ctx, 1):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                    self.state = 1087
                    self.match(TptpParser.Or)
                    self.state = 1088
                    self.fof_unitary_formula() 
                self.state = 1093
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,69,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class Fof_and_formulaContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fof_unitary_formula(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TptpParser.Fof_unitary_formulaContext)
            else:
                return self.getTypedRuleContext(TptpParser.Fof_unitary_formulaContext,i)


        def And(self):
            return self.getToken(TptpParser.And, 0)

        def fof_and_formula(self):
            return self.getTypedRuleContext(TptpParser.Fof_and_formulaContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_fof_and_formula

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFof_and_formula" ):
                listener.enterFof_and_formula(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFof_and_formula" ):
                listener.exitFof_and_formula(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFof_and_formula" ):
                return visitor.visitFof_and_formula(self)
            else:
                return visitor.visitChildren(self)



    def fof_and_formula(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = TptpParser.Fof_and_formulaContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 190
        self.enterRecursionRule(localctx, 190, self.RULE_fof_and_formula, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1095
            self.fof_unitary_formula()
            self.state = 1096
            self.match(TptpParser.And)
            self.state = 1097
            self.fof_unitary_formula()
            self._ctx.stop = self._input.LT(-1)
            self.state = 1104
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,70,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = TptpParser.Fof_and_formulaContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_fof_and_formula)
                    self.state = 1099
                    if not self.precpred(self._ctx, 1):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                    self.state = 1100
                    self.match(TptpParser.And)
                    self.state = 1101
                    self.fof_unitary_formula() 
                self.state = 1106
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,70,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class Fof_unitary_formulaContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fof_quantified_formula(self):
            return self.getTypedRuleContext(TptpParser.Fof_quantified_formulaContext,0)


        def fof_unary_formula(self):
            return self.getTypedRuleContext(TptpParser.Fof_unary_formulaContext,0)


        def fof_atomic_formula(self):
            return self.getTypedRuleContext(TptpParser.Fof_atomic_formulaContext,0)


        def fof_logic_formula(self):
            return self.getTypedRuleContext(TptpParser.Fof_logic_formulaContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_fof_unitary_formula

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFof_unitary_formula" ):
                listener.enterFof_unitary_formula(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFof_unitary_formula" ):
                listener.exitFof_unitary_formula(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFof_unitary_formula" ):
                return visitor.visitFof_unitary_formula(self)
            else:
                return visitor.visitChildren(self)




    def fof_unitary_formula(self):

        localctx = TptpParser.Fof_unitary_formulaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 192, self.RULE_fof_unitary_formula)
        try:
            self.state = 1114
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,71,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1107
                self.fof_quantified_formula()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1108
                self.fof_unary_formula()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1109
                self.fof_atomic_formula()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1110
                self.match(TptpParser.T__9)
                self.state = 1111
                self.fof_logic_formula()
                self.state = 1112
                self.match(TptpParser.T__10)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Fof_quantified_formulaContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fof_quantifier(self):
            return self.getTypedRuleContext(TptpParser.Fof_quantifierContext,0)


        def fof_variable_list(self):
            return self.getTypedRuleContext(TptpParser.Fof_variable_listContext,0)


        def fof_unitary_formula(self):
            return self.getTypedRuleContext(TptpParser.Fof_unitary_formulaContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_fof_quantified_formula

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFof_quantified_formula" ):
                listener.enterFof_quantified_formula(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFof_quantified_formula" ):
                listener.exitFof_quantified_formula(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFof_quantified_formula" ):
                return visitor.visitFof_quantified_formula(self)
            else:
                return visitor.visitChildren(self)




    def fof_quantified_formula(self):

        localctx = TptpParser.Fof_quantified_formulaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 194, self.RULE_fof_quantified_formula)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1116
            self.fof_quantifier()
            self.state = 1117
            self.match(TptpParser.T__11)
            self.state = 1118
            self.fof_variable_list()
            self.state = 1119
            self.match(TptpParser.T__12)
            self.state = 1120
            self.match(TptpParser.T__13)
            self.state = 1121
            self.fof_unitary_formula()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Fof_variable_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variable(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TptpParser.VariableContext)
            else:
                return self.getTypedRuleContext(TptpParser.VariableContext,i)


        def getRuleIndex(self):
            return TptpParser.RULE_fof_variable_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFof_variable_list" ):
                listener.enterFof_variable_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFof_variable_list" ):
                listener.exitFof_variable_list(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFof_variable_list" ):
                return visitor.visitFof_variable_list(self)
            else:
                return visitor.visitChildren(self)




    def fof_variable_list(self):

        localctx = TptpParser.Fof_variable_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 196, self.RULE_fof_variable_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1123
            self.variable()
            self.state = 1128
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==TptpParser.T__1:
                self.state = 1124
                self.match(TptpParser.T__1)
                self.state = 1125
                self.variable()
                self.state = 1130
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Fof_unary_formulaContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def unary_connective(self):
            return self.getTypedRuleContext(TptpParser.Unary_connectiveContext,0)


        def fof_unitary_formula(self):
            return self.getTypedRuleContext(TptpParser.Fof_unitary_formulaContext,0)


        def fof_infix_unary(self):
            return self.getTypedRuleContext(TptpParser.Fof_infix_unaryContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_fof_unary_formula

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFof_unary_formula" ):
                listener.enterFof_unary_formula(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFof_unary_formula" ):
                listener.exitFof_unary_formula(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFof_unary_formula" ):
                return visitor.visitFof_unary_formula(self)
            else:
                return visitor.visitChildren(self)




    def fof_unary_formula(self):

        localctx = TptpParser.Fof_unary_formulaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 198, self.RULE_fof_unary_formula)
        try:
            self.state = 1135
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TptpParser.Not]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1131
                self.unary_connective()
                self.state = 1132
                self.fof_unitary_formula()
                pass
            elif token in [TptpParser.T__17, TptpParser.T__18, TptpParser.T__23, TptpParser.T__24, TptpParser.T__25, TptpParser.Real, TptpParser.Rational, TptpParser.Integer, TptpParser.Dollar_word, TptpParser.Dollar_dollar_word, TptpParser.Upper_word, TptpParser.Lower_word, TptpParser.Single_quoted, TptpParser.Distinct_object]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1134
                self.fof_infix_unary()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Fof_infix_unaryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fof_term(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TptpParser.Fof_termContext)
            else:
                return self.getTypedRuleContext(TptpParser.Fof_termContext,i)


        def Infix_inequality(self):
            return self.getToken(TptpParser.Infix_inequality, 0)

        def getRuleIndex(self):
            return TptpParser.RULE_fof_infix_unary

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFof_infix_unary" ):
                listener.enterFof_infix_unary(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFof_infix_unary" ):
                listener.exitFof_infix_unary(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFof_infix_unary" ):
                return visitor.visitFof_infix_unary(self)
            else:
                return visitor.visitChildren(self)




    def fof_infix_unary(self):

        localctx = TptpParser.Fof_infix_unaryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 200, self.RULE_fof_infix_unary)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1137
            self.fof_term()
            self.state = 1138
            self.match(TptpParser.Infix_inequality)
            self.state = 1139
            self.fof_term()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Fof_atomic_formulaContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fof_plain_atomic_formula(self):
            return self.getTypedRuleContext(TptpParser.Fof_plain_atomic_formulaContext,0)


        def fof_defined_atomic_formula(self):
            return self.getTypedRuleContext(TptpParser.Fof_defined_atomic_formulaContext,0)


        def fof_system_atomic_formula(self):
            return self.getTypedRuleContext(TptpParser.Fof_system_atomic_formulaContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_fof_atomic_formula

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFof_atomic_formula" ):
                listener.enterFof_atomic_formula(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFof_atomic_formula" ):
                listener.exitFof_atomic_formula(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFof_atomic_formula" ):
                return visitor.visitFof_atomic_formula(self)
            else:
                return visitor.visitChildren(self)




    def fof_atomic_formula(self):

        localctx = TptpParser.Fof_atomic_formulaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 202, self.RULE_fof_atomic_formula)
        try:
            self.state = 1144
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,74,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1141
                self.fof_plain_atomic_formula()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1142
                self.fof_defined_atomic_formula()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1143
                self.fof_system_atomic_formula()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Fof_plain_atomic_formulaContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fof_plain_term(self):
            return self.getTypedRuleContext(TptpParser.Fof_plain_termContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_fof_plain_atomic_formula

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFof_plain_atomic_formula" ):
                listener.enterFof_plain_atomic_formula(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFof_plain_atomic_formula" ):
                listener.exitFof_plain_atomic_formula(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFof_plain_atomic_formula" ):
                return visitor.visitFof_plain_atomic_formula(self)
            else:
                return visitor.visitChildren(self)




    def fof_plain_atomic_formula(self):

        localctx = TptpParser.Fof_plain_atomic_formulaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 204, self.RULE_fof_plain_atomic_formula)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1146
            self.fof_plain_term()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Fof_defined_atomic_formulaContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fof_defined_plain_formula(self):
            return self.getTypedRuleContext(TptpParser.Fof_defined_plain_formulaContext,0)


        def fof_defined_infix_formula(self):
            return self.getTypedRuleContext(TptpParser.Fof_defined_infix_formulaContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_fof_defined_atomic_formula

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFof_defined_atomic_formula" ):
                listener.enterFof_defined_atomic_formula(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFof_defined_atomic_formula" ):
                listener.exitFof_defined_atomic_formula(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFof_defined_atomic_formula" ):
                return visitor.visitFof_defined_atomic_formula(self)
            else:
                return visitor.visitChildren(self)




    def fof_defined_atomic_formula(self):

        localctx = TptpParser.Fof_defined_atomic_formulaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 206, self.RULE_fof_defined_atomic_formula)
        try:
            self.state = 1150
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,75,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1148
                self.fof_defined_plain_formula()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1149
                self.fof_defined_infix_formula()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Fof_defined_plain_formulaContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fof_defined_term(self):
            return self.getTypedRuleContext(TptpParser.Fof_defined_termContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_fof_defined_plain_formula

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFof_defined_plain_formula" ):
                listener.enterFof_defined_plain_formula(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFof_defined_plain_formula" ):
                listener.exitFof_defined_plain_formula(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFof_defined_plain_formula" ):
                return visitor.visitFof_defined_plain_formula(self)
            else:
                return visitor.visitChildren(self)




    def fof_defined_plain_formula(self):

        localctx = TptpParser.Fof_defined_plain_formulaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 208, self.RULE_fof_defined_plain_formula)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1152
            self.fof_defined_term()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Fof_defined_infix_formulaContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fof_term(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TptpParser.Fof_termContext)
            else:
                return self.getTypedRuleContext(TptpParser.Fof_termContext,i)


        def defined_infix_pred(self):
            return self.getTypedRuleContext(TptpParser.Defined_infix_predContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_fof_defined_infix_formula

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFof_defined_infix_formula" ):
                listener.enterFof_defined_infix_formula(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFof_defined_infix_formula" ):
                listener.exitFof_defined_infix_formula(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFof_defined_infix_formula" ):
                return visitor.visitFof_defined_infix_formula(self)
            else:
                return visitor.visitChildren(self)




    def fof_defined_infix_formula(self):

        localctx = TptpParser.Fof_defined_infix_formulaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 210, self.RULE_fof_defined_infix_formula)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1154
            self.fof_term()
            self.state = 1155
            self.defined_infix_pred()
            self.state = 1156
            self.fof_term()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Fof_system_atomic_formulaContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fof_system_term(self):
            return self.getTypedRuleContext(TptpParser.Fof_system_termContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_fof_system_atomic_formula

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFof_system_atomic_formula" ):
                listener.enterFof_system_atomic_formula(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFof_system_atomic_formula" ):
                listener.exitFof_system_atomic_formula(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFof_system_atomic_formula" ):
                return visitor.visitFof_system_atomic_formula(self)
            else:
                return visitor.visitChildren(self)




    def fof_system_atomic_formula(self):

        localctx = TptpParser.Fof_system_atomic_formulaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 212, self.RULE_fof_system_atomic_formula)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1158
            self.fof_system_term()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Fof_plain_termContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def constant(self):
            return self.getTypedRuleContext(TptpParser.ConstantContext,0)


        def functor(self):
            return self.getTypedRuleContext(TptpParser.FunctorContext,0)


        def fof_arguments(self):
            return self.getTypedRuleContext(TptpParser.Fof_argumentsContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_fof_plain_term

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFof_plain_term" ):
                listener.enterFof_plain_term(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFof_plain_term" ):
                listener.exitFof_plain_term(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFof_plain_term" ):
                return visitor.visitFof_plain_term(self)
            else:
                return visitor.visitChildren(self)




    def fof_plain_term(self):

        localctx = TptpParser.Fof_plain_termContext(self, self._ctx, self.state)
        self.enterRule(localctx, 214, self.RULE_fof_plain_term)
        try:
            self.state = 1166
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,76,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1160
                self.constant()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1161
                self.functor()
                self.state = 1162
                self.match(TptpParser.T__9)
                self.state = 1163
                self.fof_arguments()
                self.state = 1164
                self.match(TptpParser.T__10)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Fof_defined_termContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def defined_term(self):
            return self.getTypedRuleContext(TptpParser.Defined_termContext,0)


        def fof_defined_atomic_term(self):
            return self.getTypedRuleContext(TptpParser.Fof_defined_atomic_termContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_fof_defined_term

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFof_defined_term" ):
                listener.enterFof_defined_term(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFof_defined_term" ):
                listener.exitFof_defined_term(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFof_defined_term" ):
                return visitor.visitFof_defined_term(self)
            else:
                return visitor.visitChildren(self)




    def fof_defined_term(self):

        localctx = TptpParser.Fof_defined_termContext(self, self._ctx, self.state)
        self.enterRule(localctx, 216, self.RULE_fof_defined_term)
        try:
            self.state = 1170
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TptpParser.Real, TptpParser.Rational, TptpParser.Integer, TptpParser.Distinct_object]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1168
                self.defined_term()
                pass
            elif token in [TptpParser.Dollar_word]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1169
                self.fof_defined_atomic_term()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Fof_defined_atomic_termContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fof_defined_plain_term(self):
            return self.getTypedRuleContext(TptpParser.Fof_defined_plain_termContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_fof_defined_atomic_term

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFof_defined_atomic_term" ):
                listener.enterFof_defined_atomic_term(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFof_defined_atomic_term" ):
                listener.exitFof_defined_atomic_term(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFof_defined_atomic_term" ):
                return visitor.visitFof_defined_atomic_term(self)
            else:
                return visitor.visitChildren(self)




    def fof_defined_atomic_term(self):

        localctx = TptpParser.Fof_defined_atomic_termContext(self, self._ctx, self.state)
        self.enterRule(localctx, 218, self.RULE_fof_defined_atomic_term)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1172
            self.fof_defined_plain_term()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Fof_defined_plain_termContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def defined_constant(self):
            return self.getTypedRuleContext(TptpParser.Defined_constantContext,0)


        def defined_functor(self):
            return self.getTypedRuleContext(TptpParser.Defined_functorContext,0)


        def fof_arguments(self):
            return self.getTypedRuleContext(TptpParser.Fof_argumentsContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_fof_defined_plain_term

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFof_defined_plain_term" ):
                listener.enterFof_defined_plain_term(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFof_defined_plain_term" ):
                listener.exitFof_defined_plain_term(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFof_defined_plain_term" ):
                return visitor.visitFof_defined_plain_term(self)
            else:
                return visitor.visitChildren(self)




    def fof_defined_plain_term(self):

        localctx = TptpParser.Fof_defined_plain_termContext(self, self._ctx, self.state)
        self.enterRule(localctx, 220, self.RULE_fof_defined_plain_term)
        try:
            self.state = 1180
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,78,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1174
                self.defined_constant()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1175
                self.defined_functor()
                self.state = 1176
                self.match(TptpParser.T__9)
                self.state = 1177
                self.fof_arguments()
                self.state = 1178
                self.match(TptpParser.T__10)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Fof_system_termContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def system_constant(self):
            return self.getTypedRuleContext(TptpParser.System_constantContext,0)


        def system_functor(self):
            return self.getTypedRuleContext(TptpParser.System_functorContext,0)


        def fof_arguments(self):
            return self.getTypedRuleContext(TptpParser.Fof_argumentsContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_fof_system_term

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFof_system_term" ):
                listener.enterFof_system_term(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFof_system_term" ):
                listener.exitFof_system_term(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFof_system_term" ):
                return visitor.visitFof_system_term(self)
            else:
                return visitor.visitChildren(self)




    def fof_system_term(self):

        localctx = TptpParser.Fof_system_termContext(self, self._ctx, self.state)
        self.enterRule(localctx, 222, self.RULE_fof_system_term)
        try:
            self.state = 1188
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,79,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1182
                self.system_constant()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1183
                self.system_functor()
                self.state = 1184
                self.match(TptpParser.T__9)
                self.state = 1185
                self.fof_arguments()
                self.state = 1186
                self.match(TptpParser.T__10)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Fof_argumentsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fof_term(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TptpParser.Fof_termContext)
            else:
                return self.getTypedRuleContext(TptpParser.Fof_termContext,i)


        def getRuleIndex(self):
            return TptpParser.RULE_fof_arguments

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFof_arguments" ):
                listener.enterFof_arguments(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFof_arguments" ):
                listener.exitFof_arguments(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFof_arguments" ):
                return visitor.visitFof_arguments(self)
            else:
                return visitor.visitChildren(self)




    def fof_arguments(self):

        localctx = TptpParser.Fof_argumentsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 224, self.RULE_fof_arguments)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1190
            self.fof_term()
            self.state = 1195
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==TptpParser.T__1:
                self.state = 1191
                self.match(TptpParser.T__1)
                self.state = 1192
                self.fof_term()
                self.state = 1197
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Fof_termContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fof_function_term(self):
            return self.getTypedRuleContext(TptpParser.Fof_function_termContext,0)


        def variable(self):
            return self.getTypedRuleContext(TptpParser.VariableContext,0)


        def tff_conditional_term(self):
            return self.getTypedRuleContext(TptpParser.Tff_conditional_termContext,0)


        def tff_let_term(self):
            return self.getTypedRuleContext(TptpParser.Tff_let_termContext,0)


        def tff_tuple_term(self):
            return self.getTypedRuleContext(TptpParser.Tff_tuple_termContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_fof_term

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFof_term" ):
                listener.enterFof_term(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFof_term" ):
                listener.exitFof_term(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFof_term" ):
                return visitor.visitFof_term(self)
            else:
                return visitor.visitChildren(self)




    def fof_term(self):

        localctx = TptpParser.Fof_termContext(self, self._ctx, self.state)
        self.enterRule(localctx, 226, self.RULE_fof_term)
        try:
            self.state = 1203
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TptpParser.Real, TptpParser.Rational, TptpParser.Integer, TptpParser.Dollar_word, TptpParser.Dollar_dollar_word, TptpParser.Lower_word, TptpParser.Single_quoted, TptpParser.Distinct_object]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1198
                self.fof_function_term()
                pass
            elif token in [TptpParser.Upper_word]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1199
                self.variable()
                pass
            elif token in [TptpParser.T__23]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1200
                self.tff_conditional_term()
                pass
            elif token in [TptpParser.T__24, TptpParser.T__25]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1201
                self.tff_let_term()
                pass
            elif token in [TptpParser.T__17, TptpParser.T__18]:
                self.enterOuterAlt(localctx, 5)
                self.state = 1202
                self.tff_tuple_term()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Fof_function_termContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fof_plain_term(self):
            return self.getTypedRuleContext(TptpParser.Fof_plain_termContext,0)


        def fof_defined_term(self):
            return self.getTypedRuleContext(TptpParser.Fof_defined_termContext,0)


        def fof_system_term(self):
            return self.getTypedRuleContext(TptpParser.Fof_system_termContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_fof_function_term

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFof_function_term" ):
                listener.enterFof_function_term(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFof_function_term" ):
                listener.exitFof_function_term(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFof_function_term" ):
                return visitor.visitFof_function_term(self)
            else:
                return visitor.visitChildren(self)




    def fof_function_term(self):

        localctx = TptpParser.Fof_function_termContext(self, self._ctx, self.state)
        self.enterRule(localctx, 228, self.RULE_fof_function_term)
        try:
            self.state = 1208
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TptpParser.Lower_word, TptpParser.Single_quoted]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1205
                self.fof_plain_term()
                pass
            elif token in [TptpParser.Real, TptpParser.Rational, TptpParser.Integer, TptpParser.Dollar_word, TptpParser.Distinct_object]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1206
                self.fof_defined_term()
                pass
            elif token in [TptpParser.Dollar_dollar_word]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1207
                self.fof_system_term()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Tff_conditional_termContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tff_logic_formula(self):
            return self.getTypedRuleContext(TptpParser.Tff_logic_formulaContext,0)


        def fof_term(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TptpParser.Fof_termContext)
            else:
                return self.getTypedRuleContext(TptpParser.Fof_termContext,i)


        def getRuleIndex(self):
            return TptpParser.RULE_tff_conditional_term

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTff_conditional_term" ):
                listener.enterTff_conditional_term(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTff_conditional_term" ):
                listener.exitTff_conditional_term(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTff_conditional_term" ):
                return visitor.visitTff_conditional_term(self)
            else:
                return visitor.visitChildren(self)




    def tff_conditional_term(self):

        localctx = TptpParser.Tff_conditional_termContext(self, self._ctx, self.state)
        self.enterRule(localctx, 230, self.RULE_tff_conditional_term)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1210
            self.match(TptpParser.T__23)
            self.state = 1211
            self.tff_logic_formula()
            self.state = 1212
            self.match(TptpParser.T__1)
            self.state = 1213
            self.fof_term()
            self.state = 1214
            self.match(TptpParser.T__1)
            self.state = 1215
            self.fof_term()
            self.state = 1216
            self.match(TptpParser.T__10)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Tff_let_termContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tff_let_formula_defns(self):
            return self.getTypedRuleContext(TptpParser.Tff_let_formula_defnsContext,0)


        def fof_term(self):
            return self.getTypedRuleContext(TptpParser.Fof_termContext,0)


        def tff_let_term_defns(self):
            return self.getTypedRuleContext(TptpParser.Tff_let_term_defnsContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_tff_let_term

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTff_let_term" ):
                listener.enterTff_let_term(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTff_let_term" ):
                listener.exitTff_let_term(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTff_let_term" ):
                return visitor.visitTff_let_term(self)
            else:
                return visitor.visitChildren(self)




    def tff_let_term(self):

        localctx = TptpParser.Tff_let_termContext(self, self._ctx, self.state)
        self.enterRule(localctx, 232, self.RULE_tff_let_term)
        try:
            self.state = 1230
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TptpParser.T__24]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1218
                self.match(TptpParser.T__24)
                self.state = 1219
                self.tff_let_formula_defns()
                self.state = 1220
                self.match(TptpParser.T__1)
                self.state = 1221
                self.fof_term()
                self.state = 1222
                self.match(TptpParser.T__10)
                pass
            elif token in [TptpParser.T__25]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1224
                self.match(TptpParser.T__25)
                self.state = 1225
                self.tff_let_term_defns()
                self.state = 1226
                self.match(TptpParser.T__1)
                self.state = 1227
                self.fof_term()
                self.state = 1228
                self.match(TptpParser.T__10)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Tff_tuple_termContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fof_arguments(self):
            return self.getTypedRuleContext(TptpParser.Fof_argumentsContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_tff_tuple_term

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTff_tuple_term" ):
                listener.enterTff_tuple_term(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTff_tuple_term" ):
                listener.exitTff_tuple_term(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTff_tuple_term" ):
                return visitor.visitTff_tuple_term(self)
            else:
                return visitor.visitChildren(self)




    def tff_tuple_term(self):

        localctx = TptpParser.Tff_tuple_termContext(self, self._ctx, self.state)
        self.enterRule(localctx, 234, self.RULE_tff_tuple_term)
        try:
            self.state = 1237
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TptpParser.T__17]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1232
                self.match(TptpParser.T__17)
                pass
            elif token in [TptpParser.T__18]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1233
                self.match(TptpParser.T__18)
                self.state = 1234
                self.fof_arguments()
                self.state = 1235
                self.match(TptpParser.T__19)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Fof_sequentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fof_formula_tuple(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TptpParser.Fof_formula_tupleContext)
            else:
                return self.getTypedRuleContext(TptpParser.Fof_formula_tupleContext,i)


        def Gentzen_arrow(self):
            return self.getToken(TptpParser.Gentzen_arrow, 0)

        def fof_sequent(self):
            return self.getTypedRuleContext(TptpParser.Fof_sequentContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_fof_sequent

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFof_sequent" ):
                listener.enterFof_sequent(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFof_sequent" ):
                listener.exitFof_sequent(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFof_sequent" ):
                return visitor.visitFof_sequent(self)
            else:
                return visitor.visitChildren(self)




    def fof_sequent(self):

        localctx = TptpParser.Fof_sequentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 236, self.RULE_fof_sequent)
        try:
            self.state = 1247
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TptpParser.T__11, TptpParser.T__16]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1239
                self.fof_formula_tuple()
                self.state = 1240
                self.match(TptpParser.Gentzen_arrow)
                self.state = 1241
                self.fof_formula_tuple()
                pass
            elif token in [TptpParser.T__9]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1243
                self.match(TptpParser.T__9)
                self.state = 1244
                self.fof_sequent()
                self.state = 1245
                self.match(TptpParser.T__10)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Fof_formula_tupleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fof_formula_tuple_list(self):
            return self.getTypedRuleContext(TptpParser.Fof_formula_tuple_listContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_fof_formula_tuple

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFof_formula_tuple" ):
                listener.enterFof_formula_tuple(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFof_formula_tuple" ):
                listener.exitFof_formula_tuple(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFof_formula_tuple" ):
                return visitor.visitFof_formula_tuple(self)
            else:
                return visitor.visitChildren(self)




    def fof_formula_tuple(self):

        localctx = TptpParser.Fof_formula_tupleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 238, self.RULE_fof_formula_tuple)
        try:
            self.state = 1254
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TptpParser.T__16]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1249
                self.match(TptpParser.T__16)
                pass
            elif token in [TptpParser.T__11]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1250
                self.match(TptpParser.T__11)
                self.state = 1251
                self.fof_formula_tuple_list()
                self.state = 1252
                self.match(TptpParser.T__12)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Fof_formula_tuple_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fof_logic_formula(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TptpParser.Fof_logic_formulaContext)
            else:
                return self.getTypedRuleContext(TptpParser.Fof_logic_formulaContext,i)


        def getRuleIndex(self):
            return TptpParser.RULE_fof_formula_tuple_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFof_formula_tuple_list" ):
                listener.enterFof_formula_tuple_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFof_formula_tuple_list" ):
                listener.exitFof_formula_tuple_list(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFof_formula_tuple_list" ):
                return visitor.visitFof_formula_tuple_list(self)
            else:
                return visitor.visitChildren(self)




    def fof_formula_tuple_list(self):

        localctx = TptpParser.Fof_formula_tuple_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 240, self.RULE_fof_formula_tuple_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1256
            self.fof_logic_formula()
            self.state = 1261
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==TptpParser.T__1:
                self.state = 1257
                self.match(TptpParser.T__1)
                self.state = 1258
                self.fof_logic_formula()
                self.state = 1263
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Cnf_formulaContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def cnf_disjunction(self):
            return self.getTypedRuleContext(TptpParser.Cnf_disjunctionContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_cnf_formula

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCnf_formula" ):
                listener.enterCnf_formula(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCnf_formula" ):
                listener.exitCnf_formula(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCnf_formula" ):
                return visitor.visitCnf_formula(self)
            else:
                return visitor.visitChildren(self)




    def cnf_formula(self):

        localctx = TptpParser.Cnf_formulaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 242, self.RULE_cnf_formula)
        try:
            self.state = 1269
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TptpParser.T__17, TptpParser.T__18, TptpParser.T__23, TptpParser.T__24, TptpParser.T__25, TptpParser.Not, TptpParser.Real, TptpParser.Rational, TptpParser.Integer, TptpParser.Dollar_word, TptpParser.Dollar_dollar_word, TptpParser.Upper_word, TptpParser.Lower_word, TptpParser.Single_quoted, TptpParser.Distinct_object]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1264
                self.cnf_disjunction(0)
                pass
            elif token in [TptpParser.T__9]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1265
                self.match(TptpParser.T__9)
                self.state = 1266
                self.cnf_disjunction(0)
                self.state = 1267
                self.match(TptpParser.T__10)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Cnf_disjunctionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def cnf_literal(self):
            return self.getTypedRuleContext(TptpParser.Cnf_literalContext,0)


        def cnf_disjunction(self):
            return self.getTypedRuleContext(TptpParser.Cnf_disjunctionContext,0)


        def Or(self):
            return self.getToken(TptpParser.Or, 0)

        def getRuleIndex(self):
            return TptpParser.RULE_cnf_disjunction

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCnf_disjunction" ):
                listener.enterCnf_disjunction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCnf_disjunction" ):
                listener.exitCnf_disjunction(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCnf_disjunction" ):
                return visitor.visitCnf_disjunction(self)
            else:
                return visitor.visitChildren(self)



    def cnf_disjunction(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = TptpParser.Cnf_disjunctionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 244
        self.enterRecursionRule(localctx, 244, self.RULE_cnf_disjunction, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1272
            self.cnf_literal()
            self._ctx.stop = self._input.LT(-1)
            self.state = 1279
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,89,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = TptpParser.Cnf_disjunctionContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_cnf_disjunction)
                    self.state = 1274
                    if not self.precpred(self._ctx, 1):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                    self.state = 1275
                    self.match(TptpParser.Or)
                    self.state = 1276
                    self.cnf_literal() 
                self.state = 1281
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,89,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class Cnf_literalContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fof_atomic_formula(self):
            return self.getTypedRuleContext(TptpParser.Fof_atomic_formulaContext,0)


        def Not(self):
            return self.getToken(TptpParser.Not, 0)

        def fof_infix_unary(self):
            return self.getTypedRuleContext(TptpParser.Fof_infix_unaryContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_cnf_literal

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCnf_literal" ):
                listener.enterCnf_literal(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCnf_literal" ):
                listener.exitCnf_literal(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCnf_literal" ):
                return visitor.visitCnf_literal(self)
            else:
                return visitor.visitChildren(self)




    def cnf_literal(self):

        localctx = TptpParser.Cnf_literalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 246, self.RULE_cnf_literal)
        try:
            self.state = 1286
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,90,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1282
                self.fof_atomic_formula()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1283
                self.match(TptpParser.Not)
                self.state = 1284
                self.fof_atomic_formula()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1285
                self.fof_infix_unary()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Thf_quantifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fof_quantifier(self):
            return self.getTypedRuleContext(TptpParser.Fof_quantifierContext,0)


        def th0_quantifier(self):
            return self.getTypedRuleContext(TptpParser.Th0_quantifierContext,0)


        def th1_quantifier(self):
            return self.getTypedRuleContext(TptpParser.Th1_quantifierContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_thf_quantifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterThf_quantifier" ):
                listener.enterThf_quantifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitThf_quantifier" ):
                listener.exitThf_quantifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitThf_quantifier" ):
                return visitor.visitThf_quantifier(self)
            else:
                return visitor.visitChildren(self)




    def thf_quantifier(self):

        localctx = TptpParser.Thf_quantifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 248, self.RULE_thf_quantifier)
        try:
            self.state = 1291
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TptpParser.Forall, TptpParser.Exists]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1288
                self.fof_quantifier()
                pass
            elif token in [TptpParser.Lambda, TptpParser.Choice, TptpParser.Description]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1289
                self.th0_quantifier()
                pass
            elif token in [TptpParser.TyForall, TptpParser.TyExists]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1290
                self.th1_quantifier()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Th0_quantifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Lambda(self):
            return self.getToken(TptpParser.Lambda, 0)

        def Choice(self):
            return self.getToken(TptpParser.Choice, 0)

        def Description(self):
            return self.getToken(TptpParser.Description, 0)

        def getRuleIndex(self):
            return TptpParser.RULE_th0_quantifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTh0_quantifier" ):
                listener.enterTh0_quantifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTh0_quantifier" ):
                listener.exitTh0_quantifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTh0_quantifier" ):
                return visitor.visitTh0_quantifier(self)
            else:
                return visitor.visitChildren(self)




    def th0_quantifier(self):

        localctx = TptpParser.Th0_quantifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 250, self.RULE_th0_quantifier)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1293
            _la = self._input.LA(1)
            if not(((((_la - 61)) & ~0x3f) == 0 and ((1 << (_la - 61)) & ((1 << (TptpParser.Lambda - 61)) | (1 << (TptpParser.Choice - 61)) | (1 << (TptpParser.Description - 61)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Th1_quantifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TyForall(self):
            return self.getToken(TptpParser.TyForall, 0)

        def TyExists(self):
            return self.getToken(TptpParser.TyExists, 0)

        def getRuleIndex(self):
            return TptpParser.RULE_th1_quantifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTh1_quantifier" ):
                listener.enterTh1_quantifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTh1_quantifier" ):
                listener.exitTh1_quantifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTh1_quantifier" ):
                return visitor.visitTh1_quantifier(self)
            else:
                return visitor.visitChildren(self)




    def th1_quantifier(self):

        localctx = TptpParser.Th1_quantifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 252, self.RULE_th1_quantifier)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1295
            _la = self._input.LA(1)
            if not(_la==TptpParser.TyForall or _la==TptpParser.TyExists):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Thf_pair_connectiveContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Infix_equality(self):
            return self.getToken(TptpParser.Infix_equality, 0)

        def Infix_inequality(self):
            return self.getToken(TptpParser.Infix_inequality, 0)

        def binary_connective(self):
            return self.getTypedRuleContext(TptpParser.Binary_connectiveContext,0)


        def Assignment(self):
            return self.getToken(TptpParser.Assignment, 0)

        def getRuleIndex(self):
            return TptpParser.RULE_thf_pair_connective

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterThf_pair_connective" ):
                listener.enterThf_pair_connective(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitThf_pair_connective" ):
                listener.exitThf_pair_connective(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitThf_pair_connective" ):
                return visitor.visitThf_pair_connective(self)
            else:
                return visitor.visitChildren(self)




    def thf_pair_connective(self):

        localctx = TptpParser.Thf_pair_connectiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 254, self.RULE_thf_pair_connective)
        try:
            self.state = 1301
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TptpParser.Infix_equality]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1297
                self.match(TptpParser.Infix_equality)
                pass
            elif token in [TptpParser.Infix_inequality]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1298
                self.match(TptpParser.Infix_inequality)
                pass
            elif token in [TptpParser.Iff, TptpParser.Impl, TptpParser.If, TptpParser.Niff, TptpParser.Nor, TptpParser.Nand]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1299
                self.binary_connective()
                pass
            elif token in [TptpParser.Assignment]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1300
                self.match(TptpParser.Assignment)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Thf_unary_connectiveContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def unary_connective(self):
            return self.getTypedRuleContext(TptpParser.Unary_connectiveContext,0)


        def th1_unary_connective(self):
            return self.getTypedRuleContext(TptpParser.Th1_unary_connectiveContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_thf_unary_connective

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterThf_unary_connective" ):
                listener.enterThf_unary_connective(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitThf_unary_connective" ):
                listener.exitThf_unary_connective(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitThf_unary_connective" ):
                return visitor.visitThf_unary_connective(self)
            else:
                return visitor.visitChildren(self)




    def thf_unary_connective(self):

        localctx = TptpParser.Thf_unary_connectiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 256, self.RULE_thf_unary_connective)
        try:
            self.state = 1305
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TptpParser.Not]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1303
                self.unary_connective()
                pass
            elif token in [TptpParser.ForallComb, TptpParser.ExistsComb, TptpParser.ChoiceComb, TptpParser.DescriptionComb, TptpParser.EqComb]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1304
                self.th1_unary_connective()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Th1_unary_connectiveContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ForallComb(self):
            return self.getToken(TptpParser.ForallComb, 0)

        def ExistsComb(self):
            return self.getToken(TptpParser.ExistsComb, 0)

        def ChoiceComb(self):
            return self.getToken(TptpParser.ChoiceComb, 0)

        def DescriptionComb(self):
            return self.getToken(TptpParser.DescriptionComb, 0)

        def EqComb(self):
            return self.getToken(TptpParser.EqComb, 0)

        def getRuleIndex(self):
            return TptpParser.RULE_th1_unary_connective

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTh1_unary_connective" ):
                listener.enterTh1_unary_connective(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTh1_unary_connective" ):
                listener.exitTh1_unary_connective(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTh1_unary_connective" ):
                return visitor.visitTh1_unary_connective(self)
            else:
                return visitor.visitChildren(self)




    def th1_unary_connective(self):

        localctx = TptpParser.Th1_unary_connectiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 258, self.RULE_th1_unary_connective)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1307
            _la = self._input.LA(1)
            if not(((((_la - 53)) & ~0x3f) == 0 and ((1 << (_la - 53)) & ((1 << (TptpParser.ForallComb - 53)) | (1 << (TptpParser.ExistsComb - 53)) | (1 << (TptpParser.ChoiceComb - 53)) | (1 << (TptpParser.DescriptionComb - 53)) | (1 << (TptpParser.EqComb - 53)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Tff_pair_connectiveContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def binary_connective(self):
            return self.getTypedRuleContext(TptpParser.Binary_connectiveContext,0)


        def Assignment(self):
            return self.getToken(TptpParser.Assignment, 0)

        def getRuleIndex(self):
            return TptpParser.RULE_tff_pair_connective

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTff_pair_connective" ):
                listener.enterTff_pair_connective(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTff_pair_connective" ):
                listener.exitTff_pair_connective(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTff_pair_connective" ):
                return visitor.visitTff_pair_connective(self)
            else:
                return visitor.visitChildren(self)




    def tff_pair_connective(self):

        localctx = TptpParser.Tff_pair_connectiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 260, self.RULE_tff_pair_connective)
        try:
            self.state = 1311
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TptpParser.Iff, TptpParser.Impl, TptpParser.If, TptpParser.Niff, TptpParser.Nor, TptpParser.Nand]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1309
                self.binary_connective()
                pass
            elif token in [TptpParser.Assignment]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1310
                self.match(TptpParser.Assignment)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Fof_quantifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Forall(self):
            return self.getToken(TptpParser.Forall, 0)

        def Exists(self):
            return self.getToken(TptpParser.Exists, 0)

        def getRuleIndex(self):
            return TptpParser.RULE_fof_quantifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFof_quantifier" ):
                listener.enterFof_quantifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFof_quantifier" ):
                listener.exitFof_quantifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFof_quantifier" ):
                return visitor.visitFof_quantifier(self)
            else:
                return visitor.visitChildren(self)




    def fof_quantifier(self):

        localctx = TptpParser.Fof_quantifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 262, self.RULE_fof_quantifier)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1313
            _la = self._input.LA(1)
            if not(_la==TptpParser.Forall or _la==TptpParser.Exists):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Binary_connectiveContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Iff(self):
            return self.getToken(TptpParser.Iff, 0)

        def Impl(self):
            return self.getToken(TptpParser.Impl, 0)

        def If(self):
            return self.getToken(TptpParser.If, 0)

        def Niff(self):
            return self.getToken(TptpParser.Niff, 0)

        def Nor(self):
            return self.getToken(TptpParser.Nor, 0)

        def Nand(self):
            return self.getToken(TptpParser.Nand, 0)

        def getRuleIndex(self):
            return TptpParser.RULE_binary_connective

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBinary_connective" ):
                listener.enterBinary_connective(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBinary_connective" ):
                listener.exitBinary_connective(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBinary_connective" ):
                return visitor.visitBinary_connective(self)
            else:
                return visitor.visitChildren(self)




    def binary_connective(self):

        localctx = TptpParser.Binary_connectiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 264, self.RULE_binary_connective)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1315
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << TptpParser.Iff) | (1 << TptpParser.Impl) | (1 << TptpParser.If) | (1 << TptpParser.Niff) | (1 << TptpParser.Nor) | (1 << TptpParser.Nand))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Assoc_connectiveContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Or(self):
            return self.getToken(TptpParser.Or, 0)

        def And(self):
            return self.getToken(TptpParser.And, 0)

        def getRuleIndex(self):
            return TptpParser.RULE_assoc_connective

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssoc_connective" ):
                listener.enterAssoc_connective(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssoc_connective" ):
                listener.exitAssoc_connective(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAssoc_connective" ):
                return visitor.visitAssoc_connective(self)
            else:
                return visitor.visitChildren(self)




    def assoc_connective(self):

        localctx = TptpParser.Assoc_connectiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 266, self.RULE_assoc_connective)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1317
            _la = self._input.LA(1)
            if not(_la==TptpParser.Or or _la==TptpParser.And):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Unary_connectiveContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Not(self):
            return self.getToken(TptpParser.Not, 0)

        def getRuleIndex(self):
            return TptpParser.RULE_unary_connective

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnary_connective" ):
                listener.enterUnary_connective(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnary_connective" ):
                listener.exitUnary_connective(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnary_connective" ):
                return visitor.visitUnary_connective(self)
            else:
                return visitor.visitChildren(self)




    def unary_connective(self):

        localctx = TptpParser.Unary_connectiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 268, self.RULE_unary_connective)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1319
            self.match(TptpParser.Not)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Type_constantContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def type_functor(self):
            return self.getTypedRuleContext(TptpParser.Type_functorContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_type_constant

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterType_constant" ):
                listener.enterType_constant(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitType_constant" ):
                listener.exitType_constant(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitType_constant" ):
                return visitor.visitType_constant(self)
            else:
                return visitor.visitChildren(self)




    def type_constant(self):

        localctx = TptpParser.Type_constantContext(self, self._ctx, self.state)
        self.enterRule(localctx, 270, self.RULE_type_constant)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1321
            self.type_functor()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Type_functorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def atomic_word(self):
            return self.getTypedRuleContext(TptpParser.Atomic_wordContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_type_functor

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterType_functor" ):
                listener.enterType_functor(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitType_functor" ):
                listener.exitType_functor(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitType_functor" ):
                return visitor.visitType_functor(self)
            else:
                return visitor.visitChildren(self)




    def type_functor(self):

        localctx = TptpParser.Type_functorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 272, self.RULE_type_functor)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1323
            self.atomic_word()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Defined_typeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Dollar_word(self):
            return self.getToken(TptpParser.Dollar_word, 0)

        def getRuleIndex(self):
            return TptpParser.RULE_defined_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefined_type" ):
                listener.enterDefined_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefined_type" ):
                listener.exitDefined_type(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDefined_type" ):
                return visitor.visitDefined_type(self)
            else:
                return visitor.visitChildren(self)




    def defined_type(self):

        localctx = TptpParser.Defined_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 274, self.RULE_defined_type)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1325
            self.match(TptpParser.Dollar_word)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class System_typeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def atomic_system_word(self):
            return self.getTypedRuleContext(TptpParser.Atomic_system_wordContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_system_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSystem_type" ):
                listener.enterSystem_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSystem_type" ):
                listener.exitSystem_type(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSystem_type" ):
                return visitor.visitSystem_type(self)
            else:
                return visitor.visitChildren(self)




    def system_type(self):

        localctx = TptpParser.System_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 276, self.RULE_system_type)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1327
            self.atomic_system_word()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AtomContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def untyped_atom(self):
            return self.getTypedRuleContext(TptpParser.Untyped_atomContext,0)


        def defined_constant(self):
            return self.getTypedRuleContext(TptpParser.Defined_constantContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_atom

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAtom" ):
                listener.enterAtom(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAtom" ):
                listener.exitAtom(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAtom" ):
                return visitor.visitAtom(self)
            else:
                return visitor.visitChildren(self)




    def atom(self):

        localctx = TptpParser.AtomContext(self, self._ctx, self.state)
        self.enterRule(localctx, 278, self.RULE_atom)
        try:
            self.state = 1331
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TptpParser.Dollar_dollar_word, TptpParser.Lower_word, TptpParser.Single_quoted]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1329
                self.untyped_atom()
                pass
            elif token in [TptpParser.Dollar_word]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1330
                self.defined_constant()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Untyped_atomContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def constant(self):
            return self.getTypedRuleContext(TptpParser.ConstantContext,0)


        def system_constant(self):
            return self.getTypedRuleContext(TptpParser.System_constantContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_untyped_atom

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUntyped_atom" ):
                listener.enterUntyped_atom(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUntyped_atom" ):
                listener.exitUntyped_atom(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUntyped_atom" ):
                return visitor.visitUntyped_atom(self)
            else:
                return visitor.visitChildren(self)




    def untyped_atom(self):

        localctx = TptpParser.Untyped_atomContext(self, self._ctx, self.state)
        self.enterRule(localctx, 280, self.RULE_untyped_atom)
        try:
            self.state = 1335
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TptpParser.Lower_word, TptpParser.Single_quoted]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1333
                self.constant()
                pass
            elif token in [TptpParser.Dollar_dollar_word]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1334
                self.system_constant()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Defined_propositionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Dollar_word(self):
            return self.getToken(TptpParser.Dollar_word, 0)

        def getRuleIndex(self):
            return TptpParser.RULE_defined_proposition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefined_proposition" ):
                listener.enterDefined_proposition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefined_proposition" ):
                listener.exitDefined_proposition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDefined_proposition" ):
                return visitor.visitDefined_proposition(self)
            else:
                return visitor.visitChildren(self)




    def defined_proposition(self):

        localctx = TptpParser.Defined_propositionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 282, self.RULE_defined_proposition)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1337
            self.match(TptpParser.Dollar_word)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Defined_predicateContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Dollar_word(self):
            return self.getToken(TptpParser.Dollar_word, 0)

        def getRuleIndex(self):
            return TptpParser.RULE_defined_predicate

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefined_predicate" ):
                listener.enterDefined_predicate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefined_predicate" ):
                listener.exitDefined_predicate(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDefined_predicate" ):
                return visitor.visitDefined_predicate(self)
            else:
                return visitor.visitChildren(self)




    def defined_predicate(self):

        localctx = TptpParser.Defined_predicateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 284, self.RULE_defined_predicate)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1339
            self.match(TptpParser.Dollar_word)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Defined_infix_predContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Infix_equality(self):
            return self.getToken(TptpParser.Infix_equality, 0)

        def Assignment(self):
            return self.getToken(TptpParser.Assignment, 0)

        def getRuleIndex(self):
            return TptpParser.RULE_defined_infix_pred

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefined_infix_pred" ):
                listener.enterDefined_infix_pred(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefined_infix_pred" ):
                listener.exitDefined_infix_pred(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDefined_infix_pred" ):
                return visitor.visitDefined_infix_pred(self)
            else:
                return visitor.visitChildren(self)




    def defined_infix_pred(self):

        localctx = TptpParser.Defined_infix_predContext(self, self._ctx, self.state)
        self.enterRule(localctx, 286, self.RULE_defined_infix_pred)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1341
            _la = self._input.LA(1)
            if not(_la==TptpParser.Infix_equality or _la==TptpParser.Assignment):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConstantContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def functor(self):
            return self.getTypedRuleContext(TptpParser.FunctorContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_constant

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstant" ):
                listener.enterConstant(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstant" ):
                listener.exitConstant(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConstant" ):
                return visitor.visitConstant(self)
            else:
                return visitor.visitChildren(self)




    def constant(self):

        localctx = TptpParser.ConstantContext(self, self._ctx, self.state)
        self.enterRule(localctx, 288, self.RULE_constant)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1343
            self.functor()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunctorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def atomic_word(self):
            return self.getTypedRuleContext(TptpParser.Atomic_wordContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_functor

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctor" ):
                listener.enterFunctor(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctor" ):
                listener.exitFunctor(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunctor" ):
                return visitor.visitFunctor(self)
            else:
                return visitor.visitChildren(self)




    def functor(self):

        localctx = TptpParser.FunctorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 290, self.RULE_functor)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1345
            self.atomic_word()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class System_constantContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def system_functor(self):
            return self.getTypedRuleContext(TptpParser.System_functorContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_system_constant

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSystem_constant" ):
                listener.enterSystem_constant(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSystem_constant" ):
                listener.exitSystem_constant(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSystem_constant" ):
                return visitor.visitSystem_constant(self)
            else:
                return visitor.visitChildren(self)




    def system_constant(self):

        localctx = TptpParser.System_constantContext(self, self._ctx, self.state)
        self.enterRule(localctx, 292, self.RULE_system_constant)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1347
            self.system_functor()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class System_functorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def atomic_system_word(self):
            return self.getTypedRuleContext(TptpParser.Atomic_system_wordContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_system_functor

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSystem_functor" ):
                listener.enterSystem_functor(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSystem_functor" ):
                listener.exitSystem_functor(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSystem_functor" ):
                return visitor.visitSystem_functor(self)
            else:
                return visitor.visitChildren(self)




    def system_functor(self):

        localctx = TptpParser.System_functorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 294, self.RULE_system_functor)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1349
            self.atomic_system_word()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Defined_constantContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def defined_functor(self):
            return self.getTypedRuleContext(TptpParser.Defined_functorContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_defined_constant

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefined_constant" ):
                listener.enterDefined_constant(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefined_constant" ):
                listener.exitDefined_constant(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDefined_constant" ):
                return visitor.visitDefined_constant(self)
            else:
                return visitor.visitChildren(self)




    def defined_constant(self):

        localctx = TptpParser.Defined_constantContext(self, self._ctx, self.state)
        self.enterRule(localctx, 296, self.RULE_defined_constant)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1351
            self.defined_functor()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Defined_functorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def atomic_defined_word(self):
            return self.getTypedRuleContext(TptpParser.Atomic_defined_wordContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_defined_functor

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefined_functor" ):
                listener.enterDefined_functor(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefined_functor" ):
                listener.exitDefined_functor(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDefined_functor" ):
                return visitor.visitDefined_functor(self)
            else:
                return visitor.visitChildren(self)




    def defined_functor(self):

        localctx = TptpParser.Defined_functorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 298, self.RULE_defined_functor)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1353
            self.atomic_defined_word()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Defined_termContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def number(self):
            return self.getTypedRuleContext(TptpParser.NumberContext,0)


        def Distinct_object(self):
            return self.getToken(TptpParser.Distinct_object, 0)

        def getRuleIndex(self):
            return TptpParser.RULE_defined_term

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefined_term" ):
                listener.enterDefined_term(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefined_term" ):
                listener.exitDefined_term(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDefined_term" ):
                return visitor.visitDefined_term(self)
            else:
                return visitor.visitChildren(self)




    def defined_term(self):

        localctx = TptpParser.Defined_termContext(self, self._ctx, self.state)
        self.enterRule(localctx, 300, self.RULE_defined_term)
        try:
            self.state = 1357
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TptpParser.Real, TptpParser.Rational, TptpParser.Integer]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1355
                self.number()
                pass
            elif token in [TptpParser.Distinct_object]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1356
                self.match(TptpParser.Distinct_object)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VariableContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Upper_word(self):
            return self.getToken(TptpParser.Upper_word, 0)

        def getRuleIndex(self):
            return TptpParser.RULE_variable

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariable" ):
                listener.enterVariable(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariable" ):
                listener.exitVariable(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariable" ):
                return visitor.visitVariable(self)
            else:
                return visitor.visitChildren(self)




    def variable(self):

        localctx = TptpParser.VariableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 302, self.RULE_variable)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1359
            self.match(TptpParser.Upper_word)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SourceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def dag_source(self):
            return self.getTypedRuleContext(TptpParser.Dag_sourceContext,0)


        def internal_source(self):
            return self.getTypedRuleContext(TptpParser.Internal_sourceContext,0)


        def external_source(self):
            return self.getTypedRuleContext(TptpParser.External_sourceContext,0)


        def Lower_word(self):
            return self.getToken(TptpParser.Lower_word, 0)

        def sources(self):
            return self.getTypedRuleContext(TptpParser.SourcesContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_source

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSource" ):
                listener.enterSource(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSource" ):
                listener.exitSource(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSource" ):
                return visitor.visitSource(self)
            else:
                return visitor.visitChildren(self)




    def source(self):

        localctx = TptpParser.SourceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 304, self.RULE_source)
        try:
            self.state = 1369
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,98,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1361
                self.dag_source()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1362
                self.internal_source()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1363
                self.external_source()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1364
                self.match(TptpParser.Lower_word)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 1365
                self.match(TptpParser.T__11)
                self.state = 1366
                self.sources()
                self.state = 1367
                self.match(TptpParser.T__12)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SourcesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def source(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TptpParser.SourceContext)
            else:
                return self.getTypedRuleContext(TptpParser.SourceContext,i)


        def getRuleIndex(self):
            return TptpParser.RULE_sources

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSources" ):
                listener.enterSources(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSources" ):
                listener.exitSources(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSources" ):
                return visitor.visitSources(self)
            else:
                return visitor.visitChildren(self)




    def sources(self):

        localctx = TptpParser.SourcesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 306, self.RULE_sources)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1371
            self.source()
            self.state = 1376
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==TptpParser.T__1:
                self.state = 1372
                self.match(TptpParser.T__1)
                self.state = 1373
                self.source()
                self.state = 1378
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Dag_sourceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self):
            return self.getTypedRuleContext(TptpParser.NameContext,0)


        def inference_record(self):
            return self.getTypedRuleContext(TptpParser.Inference_recordContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_dag_source

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDag_source" ):
                listener.enterDag_source(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDag_source" ):
                listener.exitDag_source(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDag_source" ):
                return visitor.visitDag_source(self)
            else:
                return visitor.visitChildren(self)




    def dag_source(self):

        localctx = TptpParser.Dag_sourceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 308, self.RULE_dag_source)
        try:
            self.state = 1381
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TptpParser.Integer, TptpParser.Lower_word, TptpParser.Single_quoted]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1379
                self.name()
                pass
            elif token in [TptpParser.T__26]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1380
                self.inference_record()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Inference_recordContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def inference_rule(self):
            return self.getTypedRuleContext(TptpParser.Inference_ruleContext,0)


        def useful_info(self):
            return self.getTypedRuleContext(TptpParser.Useful_infoContext,0)


        def inference_parents(self):
            return self.getTypedRuleContext(TptpParser.Inference_parentsContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_inference_record

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInference_record" ):
                listener.enterInference_record(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInference_record" ):
                listener.exitInference_record(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInference_record" ):
                return visitor.visitInference_record(self)
            else:
                return visitor.visitChildren(self)




    def inference_record(self):

        localctx = TptpParser.Inference_recordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 310, self.RULE_inference_record)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1383
            self.match(TptpParser.T__26)
            self.state = 1384
            self.inference_rule()
            self.state = 1385
            self.match(TptpParser.T__1)
            self.state = 1386
            self.useful_info()
            self.state = 1387
            self.match(TptpParser.T__1)
            self.state = 1388
            self.inference_parents()
            self.state = 1389
            self.match(TptpParser.T__10)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Inference_ruleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def atomic_word(self):
            return self.getTypedRuleContext(TptpParser.Atomic_wordContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_inference_rule

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInference_rule" ):
                listener.enterInference_rule(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInference_rule" ):
                listener.exitInference_rule(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInference_rule" ):
                return visitor.visitInference_rule(self)
            else:
                return visitor.visitChildren(self)




    def inference_rule(self):

        localctx = TptpParser.Inference_ruleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 312, self.RULE_inference_rule)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1391
            self.atomic_word()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Inference_parentsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def parent_list(self):
            return self.getTypedRuleContext(TptpParser.Parent_listContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_inference_parents

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInference_parents" ):
                listener.enterInference_parents(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInference_parents" ):
                listener.exitInference_parents(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInference_parents" ):
                return visitor.visitInference_parents(self)
            else:
                return visitor.visitChildren(self)




    def inference_parents(self):

        localctx = TptpParser.Inference_parentsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 314, self.RULE_inference_parents)
        try:
            self.state = 1398
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TptpParser.T__16]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1393
                self.match(TptpParser.T__16)
                pass
            elif token in [TptpParser.T__11]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1394
                self.match(TptpParser.T__11)
                self.state = 1395
                self.parent_list()
                self.state = 1396
                self.match(TptpParser.T__12)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Parent_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def parent_info(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TptpParser.Parent_infoContext)
            else:
                return self.getTypedRuleContext(TptpParser.Parent_infoContext,i)


        def getRuleIndex(self):
            return TptpParser.RULE_parent_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParent_list" ):
                listener.enterParent_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParent_list" ):
                listener.exitParent_list(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParent_list" ):
                return visitor.visitParent_list(self)
            else:
                return visitor.visitChildren(self)




    def parent_list(self):

        localctx = TptpParser.Parent_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 316, self.RULE_parent_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1400
            self.parent_info()
            self.state = 1405
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==TptpParser.T__1:
                self.state = 1401
                self.match(TptpParser.T__1)
                self.state = 1402
                self.parent_info()
                self.state = 1407
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Parent_infoContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def source(self):
            return self.getTypedRuleContext(TptpParser.SourceContext,0)


        def parent_details(self):
            return self.getTypedRuleContext(TptpParser.Parent_detailsContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_parent_info

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParent_info" ):
                listener.enterParent_info(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParent_info" ):
                listener.exitParent_info(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParent_info" ):
                return visitor.visitParent_info(self)
            else:
                return visitor.visitChildren(self)




    def parent_info(self):

        localctx = TptpParser.Parent_infoContext(self, self._ctx, self.state)
        self.enterRule(localctx, 318, self.RULE_parent_info)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1408
            self.source()
            self.state = 1410
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==TptpParser.T__13:
                self.state = 1409
                self.parent_details()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Parent_detailsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def general_list(self):
            return self.getTypedRuleContext(TptpParser.General_listContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_parent_details

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParent_details" ):
                listener.enterParent_details(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParent_details" ):
                listener.exitParent_details(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParent_details" ):
                return visitor.visitParent_details(self)
            else:
                return visitor.visitChildren(self)




    def parent_details(self):

        localctx = TptpParser.Parent_detailsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 320, self.RULE_parent_details)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1412
            self.match(TptpParser.T__13)
            self.state = 1413
            self.general_list()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Internal_sourceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def intro_type(self):
            return self.getTypedRuleContext(TptpParser.Intro_typeContext,0)


        def optional_info(self):
            return self.getTypedRuleContext(TptpParser.Optional_infoContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_internal_source

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInternal_source" ):
                listener.enterInternal_source(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInternal_source" ):
                listener.exitInternal_source(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInternal_source" ):
                return visitor.visitInternal_source(self)
            else:
                return visitor.visitChildren(self)




    def internal_source(self):

        localctx = TptpParser.Internal_sourceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 322, self.RULE_internal_source)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1415
            self.match(TptpParser.T__27)
            self.state = 1416
            self.intro_type()
            self.state = 1418
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==TptpParser.T__1:
                self.state = 1417
                self.optional_info()


            self.state = 1420
            self.match(TptpParser.T__10)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Intro_typeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Lower_word(self):
            return self.getToken(TptpParser.Lower_word, 0)

        def getRuleIndex(self):
            return TptpParser.RULE_intro_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIntro_type" ):
                listener.enterIntro_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIntro_type" ):
                listener.exitIntro_type(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIntro_type" ):
                return visitor.visitIntro_type(self)
            else:
                return visitor.visitChildren(self)




    def intro_type(self):

        localctx = TptpParser.Intro_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 324, self.RULE_intro_type)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1422
            self.match(TptpParser.Lower_word)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class External_sourceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def file_source(self):
            return self.getTypedRuleContext(TptpParser.File_sourceContext,0)


        def theory(self):
            return self.getTypedRuleContext(TptpParser.TheoryContext,0)


        def creator_source(self):
            return self.getTypedRuleContext(TptpParser.Creator_sourceContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_external_source

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExternal_source" ):
                listener.enterExternal_source(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExternal_source" ):
                listener.exitExternal_source(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExternal_source" ):
                return visitor.visitExternal_source(self)
            else:
                return visitor.visitChildren(self)




    def external_source(self):

        localctx = TptpParser.External_sourceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 326, self.RULE_external_source)
        try:
            self.state = 1427
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TptpParser.T__28]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1424
                self.file_source()
                pass
            elif token in [TptpParser.T__29]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1425
                self.theory()
                pass
            elif token in [TptpParser.T__30]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1426
                self.creator_source()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class File_sourceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def file_name(self):
            return self.getTypedRuleContext(TptpParser.File_nameContext,0)


        def file_info(self):
            return self.getTypedRuleContext(TptpParser.File_infoContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_file_source

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFile_source" ):
                listener.enterFile_source(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFile_source" ):
                listener.exitFile_source(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFile_source" ):
                return visitor.visitFile_source(self)
            else:
                return visitor.visitChildren(self)




    def file_source(self):

        localctx = TptpParser.File_sourceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 328, self.RULE_file_source)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1429
            self.match(TptpParser.T__28)
            self.state = 1430
            self.file_name()
            self.state = 1432
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==TptpParser.T__1:
                self.state = 1431
                self.file_info()


            self.state = 1434
            self.match(TptpParser.T__10)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class File_infoContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self):
            return self.getTypedRuleContext(TptpParser.NameContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_file_info

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFile_info" ):
                listener.enterFile_info(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFile_info" ):
                listener.exitFile_info(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFile_info" ):
                return visitor.visitFile_info(self)
            else:
                return visitor.visitChildren(self)




    def file_info(self):

        localctx = TptpParser.File_infoContext(self, self._ctx, self.state)
        self.enterRule(localctx, 330, self.RULE_file_info)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1436
            self.match(TptpParser.T__1)
            self.state = 1437
            self.name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TheoryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def theory_name(self):
            return self.getTypedRuleContext(TptpParser.Theory_nameContext,0)


        def optional_info(self):
            return self.getTypedRuleContext(TptpParser.Optional_infoContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_theory

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTheory" ):
                listener.enterTheory(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTheory" ):
                listener.exitTheory(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTheory" ):
                return visitor.visitTheory(self)
            else:
                return visitor.visitChildren(self)




    def theory(self):

        localctx = TptpParser.TheoryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 332, self.RULE_theory)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1439
            self.match(TptpParser.T__29)
            self.state = 1440
            self.theory_name()
            self.state = 1442
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==TptpParser.T__1:
                self.state = 1441
                self.optional_info()


            self.state = 1444
            self.match(TptpParser.T__10)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Theory_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Lower_word(self):
            return self.getToken(TptpParser.Lower_word, 0)

        def getRuleIndex(self):
            return TptpParser.RULE_theory_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTheory_name" ):
                listener.enterTheory_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTheory_name" ):
                listener.exitTheory_name(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTheory_name" ):
                return visitor.visitTheory_name(self)
            else:
                return visitor.visitChildren(self)




    def theory_name(self):

        localctx = TptpParser.Theory_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 334, self.RULE_theory_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1446
            self.match(TptpParser.Lower_word)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Creator_sourceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def creator_name(self):
            return self.getTypedRuleContext(TptpParser.Creator_nameContext,0)


        def optional_info(self):
            return self.getTypedRuleContext(TptpParser.Optional_infoContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_creator_source

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreator_source" ):
                listener.enterCreator_source(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreator_source" ):
                listener.exitCreator_source(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCreator_source" ):
                return visitor.visitCreator_source(self)
            else:
                return visitor.visitChildren(self)




    def creator_source(self):

        localctx = TptpParser.Creator_sourceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 336, self.RULE_creator_source)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1448
            self.match(TptpParser.T__30)
            self.state = 1449
            self.creator_name()
            self.state = 1451
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==TptpParser.T__1:
                self.state = 1450
                self.optional_info()


            self.state = 1453
            self.match(TptpParser.T__10)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Creator_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def atomic_word(self):
            return self.getTypedRuleContext(TptpParser.Atomic_wordContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_creator_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreator_name" ):
                listener.enterCreator_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreator_name" ):
                listener.exitCreator_name(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCreator_name" ):
                return visitor.visitCreator_name(self)
            else:
                return visitor.visitChildren(self)




    def creator_name(self):

        localctx = TptpParser.Creator_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 338, self.RULE_creator_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1455
            self.atomic_word()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Optional_infoContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def useful_info(self):
            return self.getTypedRuleContext(TptpParser.Useful_infoContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_optional_info

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOptional_info" ):
                listener.enterOptional_info(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOptional_info" ):
                listener.exitOptional_info(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOptional_info" ):
                return visitor.visitOptional_info(self)
            else:
                return visitor.visitChildren(self)




    def optional_info(self):

        localctx = TptpParser.Optional_infoContext(self, self._ctx, self.state)
        self.enterRule(localctx, 340, self.RULE_optional_info)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1457
            self.match(TptpParser.T__1)
            self.state = 1458
            self.useful_info()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Useful_infoContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def info_items(self):
            return self.getTypedRuleContext(TptpParser.Info_itemsContext,0)


        def general_list(self):
            return self.getTypedRuleContext(TptpParser.General_listContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_useful_info

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUseful_info" ):
                listener.enterUseful_info(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUseful_info" ):
                listener.exitUseful_info(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUseful_info" ):
                return visitor.visitUseful_info(self)
            else:
                return visitor.visitChildren(self)




    def useful_info(self):

        localctx = TptpParser.Useful_infoContext(self, self._ctx, self.state)
        self.enterRule(localctx, 342, self.RULE_useful_info)
        try:
            self.state = 1466
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,109,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1460
                self.match(TptpParser.T__16)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1461
                self.match(TptpParser.T__11)
                self.state = 1462
                self.info_items()
                self.state = 1463
                self.match(TptpParser.T__12)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1465
                self.general_list()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Info_itemsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def info_item(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TptpParser.Info_itemContext)
            else:
                return self.getTypedRuleContext(TptpParser.Info_itemContext,i)


        def getRuleIndex(self):
            return TptpParser.RULE_info_items

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInfo_items" ):
                listener.enterInfo_items(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInfo_items" ):
                listener.exitInfo_items(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInfo_items" ):
                return visitor.visitInfo_items(self)
            else:
                return visitor.visitChildren(self)




    def info_items(self):

        localctx = TptpParser.Info_itemsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 344, self.RULE_info_items)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1468
            self.info_item()
            self.state = 1473
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==TptpParser.T__1:
                self.state = 1469
                self.match(TptpParser.T__1)
                self.state = 1470
                self.info_item()
                self.state = 1475
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Info_itemContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def formula_item(self):
            return self.getTypedRuleContext(TptpParser.Formula_itemContext,0)


        def inference_item(self):
            return self.getTypedRuleContext(TptpParser.Inference_itemContext,0)


        def general_function(self):
            return self.getTypedRuleContext(TptpParser.General_functionContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_info_item

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInfo_item" ):
                listener.enterInfo_item(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInfo_item" ):
                listener.exitInfo_item(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInfo_item" ):
                return visitor.visitInfo_item(self)
            else:
                return visitor.visitChildren(self)




    def info_item(self):

        localctx = TptpParser.Info_itemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 346, self.RULE_info_item)
        try:
            self.state = 1479
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,111,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1476
                self.formula_item()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1477
                self.inference_item()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1478
                self.general_function()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Formula_itemContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def description_item(self):
            return self.getTypedRuleContext(TptpParser.Description_itemContext,0)


        def iquote_item(self):
            return self.getTypedRuleContext(TptpParser.Iquote_itemContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_formula_item

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFormula_item" ):
                listener.enterFormula_item(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFormula_item" ):
                listener.exitFormula_item(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFormula_item" ):
                return visitor.visitFormula_item(self)
            else:
                return visitor.visitChildren(self)




    def formula_item(self):

        localctx = TptpParser.Formula_itemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 348, self.RULE_formula_item)
        try:
            self.state = 1483
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TptpParser.T__31]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1481
                self.description_item()
                pass
            elif token in [TptpParser.T__32]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1482
                self.iquote_item()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Description_itemContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def atomic_word(self):
            return self.getTypedRuleContext(TptpParser.Atomic_wordContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_description_item

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDescription_item" ):
                listener.enterDescription_item(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDescription_item" ):
                listener.exitDescription_item(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDescription_item" ):
                return visitor.visitDescription_item(self)
            else:
                return visitor.visitChildren(self)




    def description_item(self):

        localctx = TptpParser.Description_itemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 350, self.RULE_description_item)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1485
            self.match(TptpParser.T__31)
            self.state = 1486
            self.atomic_word()
            self.state = 1487
            self.match(TptpParser.T__10)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Iquote_itemContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def atomic_word(self):
            return self.getTypedRuleContext(TptpParser.Atomic_wordContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_iquote_item

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIquote_item" ):
                listener.enterIquote_item(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIquote_item" ):
                listener.exitIquote_item(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIquote_item" ):
                return visitor.visitIquote_item(self)
            else:
                return visitor.visitChildren(self)




    def iquote_item(self):

        localctx = TptpParser.Iquote_itemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 352, self.RULE_iquote_item)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1489
            self.match(TptpParser.T__32)
            self.state = 1490
            self.atomic_word()
            self.state = 1491
            self.match(TptpParser.T__10)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Inference_itemContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def inference_status(self):
            return self.getTypedRuleContext(TptpParser.Inference_statusContext,0)


        def assumptions_record(self):
            return self.getTypedRuleContext(TptpParser.Assumptions_recordContext,0)


        def new_symbol_record(self):
            return self.getTypedRuleContext(TptpParser.New_symbol_recordContext,0)


        def refutation(self):
            return self.getTypedRuleContext(TptpParser.RefutationContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_inference_item

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInference_item" ):
                listener.enterInference_item(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInference_item" ):
                listener.exitInference_item(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInference_item" ):
                return visitor.visitInference_item(self)
            else:
                return visitor.visitChildren(self)




    def inference_item(self):

        localctx = TptpParser.Inference_itemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 354, self.RULE_inference_item)
        try:
            self.state = 1497
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TptpParser.T__33, TptpParser.Lower_word, TptpParser.Single_quoted]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1493
                self.inference_status()
                pass
            elif token in [TptpParser.T__34]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1494
                self.assumptions_record()
                pass
            elif token in [TptpParser.T__36]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1495
                self.new_symbol_record()
                pass
            elif token in [TptpParser.T__35]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1496
                self.refutation()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Inference_statusContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def status_value(self):
            return self.getTypedRuleContext(TptpParser.Status_valueContext,0)


        def inference_info(self):
            return self.getTypedRuleContext(TptpParser.Inference_infoContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_inference_status

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInference_status" ):
                listener.enterInference_status(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInference_status" ):
                listener.exitInference_status(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInference_status" ):
                return visitor.visitInference_status(self)
            else:
                return visitor.visitChildren(self)




    def inference_status(self):

        localctx = TptpParser.Inference_statusContext(self, self._ctx, self.state)
        self.enterRule(localctx, 356, self.RULE_inference_status)
        try:
            self.state = 1504
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TptpParser.T__33]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1499
                self.match(TptpParser.T__33)
                self.state = 1500
                self.status_value()
                self.state = 1501
                self.match(TptpParser.T__10)
                pass
            elif token in [TptpParser.Lower_word, TptpParser.Single_quoted]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1503
                self.inference_info()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Status_valueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Lower_word(self):
            return self.getToken(TptpParser.Lower_word, 0)

        def getRuleIndex(self):
            return TptpParser.RULE_status_value

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatus_value" ):
                listener.enterStatus_value(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatus_value" ):
                listener.exitStatus_value(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStatus_value" ):
                return visitor.visitStatus_value(self)
            else:
                return visitor.visitChildren(self)




    def status_value(self):

        localctx = TptpParser.Status_valueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 358, self.RULE_status_value)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1506
            self.match(TptpParser.Lower_word)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Inference_infoContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def inference_rule(self):
            return self.getTypedRuleContext(TptpParser.Inference_ruleContext,0)


        def atomic_word(self):
            return self.getTypedRuleContext(TptpParser.Atomic_wordContext,0)


        def general_list(self):
            return self.getTypedRuleContext(TptpParser.General_listContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_inference_info

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInference_info" ):
                listener.enterInference_info(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInference_info" ):
                listener.exitInference_info(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInference_info" ):
                return visitor.visitInference_info(self)
            else:
                return visitor.visitChildren(self)




    def inference_info(self):

        localctx = TptpParser.Inference_infoContext(self, self._ctx, self.state)
        self.enterRule(localctx, 360, self.RULE_inference_info)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1508
            self.inference_rule()
            self.state = 1509
            self.match(TptpParser.T__9)
            self.state = 1510
            self.atomic_word()
            self.state = 1511
            self.match(TptpParser.T__1)
            self.state = 1512
            self.general_list()
            self.state = 1513
            self.match(TptpParser.T__10)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Assumptions_recordContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name_list(self):
            return self.getTypedRuleContext(TptpParser.Name_listContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_assumptions_record

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssumptions_record" ):
                listener.enterAssumptions_record(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssumptions_record" ):
                listener.exitAssumptions_record(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAssumptions_record" ):
                return visitor.visitAssumptions_record(self)
            else:
                return visitor.visitChildren(self)




    def assumptions_record(self):

        localctx = TptpParser.Assumptions_recordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 362, self.RULE_assumptions_record)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1515
            self.match(TptpParser.T__34)
            self.state = 1516
            self.match(TptpParser.T__11)
            self.state = 1517
            self.name_list()
            self.state = 1518
            self.match(TptpParser.T__12)
            self.state = 1519
            self.match(TptpParser.T__10)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RefutationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def file_source(self):
            return self.getTypedRuleContext(TptpParser.File_sourceContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_refutation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRefutation" ):
                listener.enterRefutation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRefutation" ):
                listener.exitRefutation(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRefutation" ):
                return visitor.visitRefutation(self)
            else:
                return visitor.visitChildren(self)




    def refutation(self):

        localctx = TptpParser.RefutationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 364, self.RULE_refutation)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1521
            self.match(TptpParser.T__35)
            self.state = 1522
            self.file_source()
            self.state = 1523
            self.match(TptpParser.T__10)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class New_symbol_recordContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def atomic_word(self):
            return self.getTypedRuleContext(TptpParser.Atomic_wordContext,0)


        def new_symbol_list(self):
            return self.getTypedRuleContext(TptpParser.New_symbol_listContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_new_symbol_record

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNew_symbol_record" ):
                listener.enterNew_symbol_record(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNew_symbol_record" ):
                listener.exitNew_symbol_record(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNew_symbol_record" ):
                return visitor.visitNew_symbol_record(self)
            else:
                return visitor.visitChildren(self)




    def new_symbol_record(self):

        localctx = TptpParser.New_symbol_recordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 366, self.RULE_new_symbol_record)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1525
            self.match(TptpParser.T__36)
            self.state = 1526
            self.atomic_word()
            self.state = 1527
            self.match(TptpParser.T__1)
            self.state = 1528
            self.match(TptpParser.T__11)
            self.state = 1529
            self.new_symbol_list()
            self.state = 1530
            self.match(TptpParser.T__12)
            self.state = 1531
            self.match(TptpParser.T__10)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class New_symbol_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def principal_symbol(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TptpParser.Principal_symbolContext)
            else:
                return self.getTypedRuleContext(TptpParser.Principal_symbolContext,i)


        def getRuleIndex(self):
            return TptpParser.RULE_new_symbol_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNew_symbol_list" ):
                listener.enterNew_symbol_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNew_symbol_list" ):
                listener.exitNew_symbol_list(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNew_symbol_list" ):
                return visitor.visitNew_symbol_list(self)
            else:
                return visitor.visitChildren(self)




    def new_symbol_list(self):

        localctx = TptpParser.New_symbol_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 368, self.RULE_new_symbol_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1533
            self.principal_symbol()
            self.state = 1538
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==TptpParser.T__1:
                self.state = 1534
                self.match(TptpParser.T__1)
                self.state = 1535
                self.principal_symbol()
                self.state = 1540
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Principal_symbolContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def functor(self):
            return self.getTypedRuleContext(TptpParser.FunctorContext,0)


        def variable(self):
            return self.getTypedRuleContext(TptpParser.VariableContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_principal_symbol

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrincipal_symbol" ):
                listener.enterPrincipal_symbol(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrincipal_symbol" ):
                listener.exitPrincipal_symbol(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPrincipal_symbol" ):
                return visitor.visitPrincipal_symbol(self)
            else:
                return visitor.visitChildren(self)




    def principal_symbol(self):

        localctx = TptpParser.Principal_symbolContext(self, self._ctx, self.state)
        self.enterRule(localctx, 370, self.RULE_principal_symbol)
        try:
            self.state = 1543
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TptpParser.Lower_word, TptpParser.Single_quoted]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1541
                self.functor()
                pass
            elif token in [TptpParser.Upper_word]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1542
                self.variable()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IncludeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def file_name(self):
            return self.getTypedRuleContext(TptpParser.File_nameContext,0)


        def formula_selection(self):
            return self.getTypedRuleContext(TptpParser.Formula_selectionContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_include

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInclude" ):
                listener.enterInclude(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInclude" ):
                listener.exitInclude(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInclude" ):
                return visitor.visitInclude(self)
            else:
                return visitor.visitChildren(self)




    def include(self):

        localctx = TptpParser.IncludeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 372, self.RULE_include)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1545
            self.match(TptpParser.T__37)
            self.state = 1546
            self.file_name()
            self.state = 1548
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==TptpParser.T__1:
                self.state = 1547
                self.formula_selection()


            self.state = 1550
            self.match(TptpParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Formula_selectionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name_list(self):
            return self.getTypedRuleContext(TptpParser.Name_listContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_formula_selection

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFormula_selection" ):
                listener.enterFormula_selection(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFormula_selection" ):
                listener.exitFormula_selection(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFormula_selection" ):
                return visitor.visitFormula_selection(self)
            else:
                return visitor.visitChildren(self)




    def formula_selection(self):

        localctx = TptpParser.Formula_selectionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 374, self.RULE_formula_selection)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1552
            self.match(TptpParser.T__1)
            self.state = 1553
            self.match(TptpParser.T__11)
            self.state = 1554
            self.name_list()
            self.state = 1555
            self.match(TptpParser.T__12)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Name_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TptpParser.NameContext)
            else:
                return self.getTypedRuleContext(TptpParser.NameContext,i)


        def getRuleIndex(self):
            return TptpParser.RULE_name_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterName_list" ):
                listener.enterName_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitName_list" ):
                listener.exitName_list(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitName_list" ):
                return visitor.visitName_list(self)
            else:
                return visitor.visitChildren(self)




    def name_list(self):

        localctx = TptpParser.Name_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 376, self.RULE_name_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1557
            self.name()
            self.state = 1562
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==TptpParser.T__1:
                self.state = 1558
                self.match(TptpParser.T__1)
                self.state = 1559
                self.name()
                self.state = 1564
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class General_termContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def general_data(self):
            return self.getTypedRuleContext(TptpParser.General_dataContext,0)


        def general_term(self):
            return self.getTypedRuleContext(TptpParser.General_termContext,0)


        def general_list(self):
            return self.getTypedRuleContext(TptpParser.General_listContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_general_term

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGeneral_term" ):
                listener.enterGeneral_term(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGeneral_term" ):
                listener.exitGeneral_term(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGeneral_term" ):
                return visitor.visitGeneral_term(self)
            else:
                return visitor.visitChildren(self)




    def general_term(self):

        localctx = TptpParser.General_termContext(self, self._ctx, self.state)
        self.enterRule(localctx, 378, self.RULE_general_term)
        try:
            self.state = 1571
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,119,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1565
                self.general_data()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1566
                self.general_data()
                self.state = 1567
                self.match(TptpParser.T__13)
                self.state = 1568
                self.general_term()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1570
                self.general_list()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class General_dataContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def atomic_word(self):
            return self.getTypedRuleContext(TptpParser.Atomic_wordContext,0)


        def general_function(self):
            return self.getTypedRuleContext(TptpParser.General_functionContext,0)


        def variable(self):
            return self.getTypedRuleContext(TptpParser.VariableContext,0)


        def number(self):
            return self.getTypedRuleContext(TptpParser.NumberContext,0)


        def Distinct_object(self):
            return self.getToken(TptpParser.Distinct_object, 0)

        def formula_data(self):
            return self.getTypedRuleContext(TptpParser.Formula_dataContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_general_data

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGeneral_data" ):
                listener.enterGeneral_data(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGeneral_data" ):
                listener.exitGeneral_data(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGeneral_data" ):
                return visitor.visitGeneral_data(self)
            else:
                return visitor.visitChildren(self)




    def general_data(self):

        localctx = TptpParser.General_dataContext(self, self._ctx, self.state)
        self.enterRule(localctx, 380, self.RULE_general_data)
        try:
            self.state = 1579
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,120,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1573
                self.atomic_word()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1574
                self.general_function()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1575
                self.variable()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1576
                self.number()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 1577
                self.match(TptpParser.Distinct_object)
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 1578
                self.formula_data()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class General_functionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def atomic_word(self):
            return self.getTypedRuleContext(TptpParser.Atomic_wordContext,0)


        def general_terms(self):
            return self.getTypedRuleContext(TptpParser.General_termsContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_general_function

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGeneral_function" ):
                listener.enterGeneral_function(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGeneral_function" ):
                listener.exitGeneral_function(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGeneral_function" ):
                return visitor.visitGeneral_function(self)
            else:
                return visitor.visitChildren(self)




    def general_function(self):

        localctx = TptpParser.General_functionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 382, self.RULE_general_function)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1581
            self.atomic_word()
            self.state = 1582
            self.match(TptpParser.T__9)
            self.state = 1583
            self.general_terms()
            self.state = 1584
            self.match(TptpParser.T__10)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Formula_dataContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def thf_formula(self):
            return self.getTypedRuleContext(TptpParser.Thf_formulaContext,0)


        def tff_formula(self):
            return self.getTypedRuleContext(TptpParser.Tff_formulaContext,0)


        def fof_formula(self):
            return self.getTypedRuleContext(TptpParser.Fof_formulaContext,0)


        def cnf_formula(self):
            return self.getTypedRuleContext(TptpParser.Cnf_formulaContext,0)


        def fof_term(self):
            return self.getTypedRuleContext(TptpParser.Fof_termContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_formula_data

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFormula_data" ):
                listener.enterFormula_data(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFormula_data" ):
                listener.exitFormula_data(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFormula_data" ):
                return visitor.visitFormula_data(self)
            else:
                return visitor.visitChildren(self)




    def formula_data(self):

        localctx = TptpParser.Formula_dataContext(self, self._ctx, self.state)
        self.enterRule(localctx, 384, self.RULE_formula_data)
        try:
            self.state = 1606
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TptpParser.T__38]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1586
                self.match(TptpParser.T__38)
                self.state = 1587
                self.thf_formula()
                self.state = 1588
                self.match(TptpParser.T__10)
                pass
            elif token in [TptpParser.T__39]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1590
                self.match(TptpParser.T__39)
                self.state = 1591
                self.tff_formula()
                self.state = 1592
                self.match(TptpParser.T__10)
                pass
            elif token in [TptpParser.T__40]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1594
                self.match(TptpParser.T__40)
                self.state = 1595
                self.fof_formula()
                self.state = 1596
                self.match(TptpParser.T__10)
                pass
            elif token in [TptpParser.T__41]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1598
                self.match(TptpParser.T__41)
                self.state = 1599
                self.cnf_formula()
                self.state = 1600
                self.match(TptpParser.T__10)
                pass
            elif token in [TptpParser.T__42]:
                self.enterOuterAlt(localctx, 5)
                self.state = 1602
                self.match(TptpParser.T__42)
                self.state = 1603
                self.fof_term()
                self.state = 1604
                self.match(TptpParser.T__10)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class General_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def general_terms(self):
            return self.getTypedRuleContext(TptpParser.General_termsContext,0)


        def getRuleIndex(self):
            return TptpParser.RULE_general_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGeneral_list" ):
                listener.enterGeneral_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGeneral_list" ):
                listener.exitGeneral_list(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGeneral_list" ):
                return visitor.visitGeneral_list(self)
            else:
                return visitor.visitChildren(self)




    def general_list(self):

        localctx = TptpParser.General_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 386, self.RULE_general_list)
        try:
            self.state = 1613
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TptpParser.T__16]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1608
                self.match(TptpParser.T__16)
                pass
            elif token in [TptpParser.T__11]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1609
                self.match(TptpParser.T__11)
                self.state = 1610
                self.general_terms()
                self.state = 1611
                self.match(TptpParser.T__12)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class General_termsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def general_term(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TptpParser.General_termContext)
            else:
                return self.getTypedRuleContext(TptpParser.General_termContext,i)


        def getRuleIndex(self):
            return TptpParser.RULE_general_terms

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGeneral_terms" ):
                listener.enterGeneral_terms(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGeneral_terms" ):
                listener.exitGeneral_terms(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGeneral_terms" ):
                return visitor.visitGeneral_terms(self)
            else:
                return visitor.visitChildren(self)




    def general_terms(self):

        localctx = TptpParser.General_termsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 388, self.RULE_general_terms)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1615
            self.general_term()
            self.state = 1620
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==TptpParser.T__1:
                self.state = 1616
                self.match(TptpParser.T__1)
                self.state = 1617
                self.general_term()
                self.state = 1622
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def atomic_word(self):
            return self.getTypedRuleContext(TptpParser.Atomic_wordContext,0)


        def Integer(self):
            return self.getToken(TptpParser.Integer, 0)

        def getRuleIndex(self):
            return TptpParser.RULE_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterName" ):
                listener.enterName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitName" ):
                listener.exitName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitName" ):
                return visitor.visitName(self)
            else:
                return visitor.visitChildren(self)




    def name(self):

        localctx = TptpParser.NameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 390, self.RULE_name)
        try:
            self.state = 1625
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TptpParser.Lower_word, TptpParser.Single_quoted]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1623
                self.atomic_word()
                pass
            elif token in [TptpParser.Integer]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1624
                self.match(TptpParser.Integer)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Atomic_wordContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Lower_word(self):
            return self.getToken(TptpParser.Lower_word, 0)

        def Single_quoted(self):
            return self.getToken(TptpParser.Single_quoted, 0)

        def getRuleIndex(self):
            return TptpParser.RULE_atomic_word

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAtomic_word" ):
                listener.enterAtomic_word(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAtomic_word" ):
                listener.exitAtomic_word(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAtomic_word" ):
                return visitor.visitAtomic_word(self)
            else:
                return visitor.visitChildren(self)




    def atomic_word(self):

        localctx = TptpParser.Atomic_wordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 392, self.RULE_atomic_word)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1627
            _la = self._input.LA(1)
            if not(_la==TptpParser.Lower_word or _la==TptpParser.Single_quoted):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Atomic_defined_wordContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Dollar_word(self):
            return self.getToken(TptpParser.Dollar_word, 0)

        def getRuleIndex(self):
            return TptpParser.RULE_atomic_defined_word

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAtomic_defined_word" ):
                listener.enterAtomic_defined_word(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAtomic_defined_word" ):
                listener.exitAtomic_defined_word(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAtomic_defined_word" ):
                return visitor.visitAtomic_defined_word(self)
            else:
                return visitor.visitChildren(self)




    def atomic_defined_word(self):

        localctx = TptpParser.Atomic_defined_wordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 394, self.RULE_atomic_defined_word)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1629
            self.match(TptpParser.Dollar_word)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Atomic_system_wordContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Dollar_dollar_word(self):
            return self.getToken(TptpParser.Dollar_dollar_word, 0)

        def getRuleIndex(self):
            return TptpParser.RULE_atomic_system_word

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAtomic_system_word" ):
                listener.enterAtomic_system_word(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAtomic_system_word" ):
                listener.exitAtomic_system_word(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAtomic_system_word" ):
                return visitor.visitAtomic_system_word(self)
            else:
                return visitor.visitChildren(self)




    def atomic_system_word(self):

        localctx = TptpParser.Atomic_system_wordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 396, self.RULE_atomic_system_word)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1631
            self.match(TptpParser.Dollar_dollar_word)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Integer(self):
            return self.getToken(TptpParser.Integer, 0)

        def Rational(self):
            return self.getToken(TptpParser.Rational, 0)

        def Real(self):
            return self.getToken(TptpParser.Real, 0)

        def getRuleIndex(self):
            return TptpParser.RULE_number

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumber" ):
                listener.enterNumber(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumber" ):
                listener.exitNumber(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumber" ):
                return visitor.visitNumber(self)
            else:
                return visitor.visitChildren(self)




    def number(self):

        localctx = TptpParser.NumberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 398, self.RULE_number)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1633
            _la = self._input.LA(1)
            if not(((((_la - 74)) & ~0x3f) == 0 and ((1 << (_la - 74)) & ((1 << (TptpParser.Real - 74)) | (1 << (TptpParser.Rational - 74)) | (1 << (TptpParser.Integer - 74)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class File_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Single_quoted(self):
            return self.getToken(TptpParser.Single_quoted, 0)

        def getRuleIndex(self):
            return TptpParser.RULE_file_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFile_name" ):
                listener.enterFile_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFile_name" ):
                listener.exitFile_name(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFile_name" ):
                return visitor.visitFile_name(self)
            else:
                return visitor.visitChildren(self)




    def file_name(self):

        localctx = TptpParser.File_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 400, self.RULE_file_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1635
            self.match(TptpParser.Single_quoted)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[18] = self.thf_or_formula_sempred
        self._predicates[19] = self.thf_and_formula_sempred
        self._predicates[20] = self.thf_apply_formula_sempred
        self._predicates[42] = self.thf_xprod_type_sempred
        self._predicates[43] = self.thf_union_type_sempred
        self._predicates[54] = self.tff_or_formula_sempred
        self._predicates[55] = self.tff_and_formula_sempred
        self._predicates[85] = self.tff_xprod_type_sempred
        self._predicates[94] = self.fof_or_formula_sempred
        self._predicates[95] = self.fof_and_formula_sempred
        self._predicates[122] = self.cnf_disjunction_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def thf_or_formula_sempred(self, localctx:Thf_or_formulaContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 1)
         

    def thf_and_formula_sempred(self, localctx:Thf_and_formulaContext, predIndex:int):
            if predIndex == 1:
                return self.precpred(self._ctx, 1)
         

    def thf_apply_formula_sempred(self, localctx:Thf_apply_formulaContext, predIndex:int):
            if predIndex == 2:
                return self.precpred(self._ctx, 1)
         

    def thf_xprod_type_sempred(self, localctx:Thf_xprod_typeContext, predIndex:int):
            if predIndex == 3:
                return self.precpred(self._ctx, 1)
         

    def thf_union_type_sempred(self, localctx:Thf_union_typeContext, predIndex:int):
            if predIndex == 4:
                return self.precpred(self._ctx, 1)
         

    def tff_or_formula_sempred(self, localctx:Tff_or_formulaContext, predIndex:int):
            if predIndex == 5:
                return self.precpred(self._ctx, 1)
         

    def tff_and_formula_sempred(self, localctx:Tff_and_formulaContext, predIndex:int):
            if predIndex == 6:
                return self.precpred(self._ctx, 1)
         

    def tff_xprod_type_sempred(self, localctx:Tff_xprod_typeContext, predIndex:int):
            if predIndex == 7:
                return self.precpred(self._ctx, 1)
         

    def fof_or_formula_sempred(self, localctx:Fof_or_formulaContext, predIndex:int):
            if predIndex == 8:
                return self.precpred(self._ctx, 1)
         

    def fof_and_formula_sempred(self, localctx:Fof_and_formulaContext, predIndex:int):
            if predIndex == 9:
                return self.precpred(self._ctx, 1)
         

    def cnf_disjunction_sempred(self, localctx:Cnf_disjunctionContext, predIndex:int):
            if predIndex == 10:
                return self.precpred(self._ctx, 1)
         




